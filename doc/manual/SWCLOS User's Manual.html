<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Introduction</title>
<meta http-equiv="Content-Type" content="text/html"/>
<meta http-equiv="Content-Style-Type" content="text/css"/>
<style type="text/css">
p.justify {
	TEXT-ALIGN: justify
}
body {
	FONT-SIZE: 10pt; BACKGROUND: white; MARGIN-LEFT: 5%; COLOR: black; MARGIN-RIGHT: 5%; FONT-FAMILY: Verdana, Arial, Helvetica, sans-serif; TEXT-ALIGN: justify
}
table {
	BORDER-RIGHT: 1px; BORDER-TOP: 1px; FONT-SIZE: 10pt; BORDER-LEFT: 1px; BORDER-BOTTOM: 1px; FONT-FAMILY: Verdana, Arial, sans-serif; BORDER-COLLAPSE: collapse; cellspacing: 0; cellpadding: 0
}
td {
	BORDER-TOP-WIDTH: 1px; PADDING-RIGHT: 5px; PADDING-LEFT: 5px; BORDER-LEFT-WIDTH: 0px; BORDER-LEFT-COLOR: #808080; BORDER-BOTTOM-WIDTH: 1px; BORDER-BOTTOM-COLOR: #808080; PADDING-BOTTOM: 5px; VERTICAL-ALIGN: middle; BORDER-TOP-COLOR: #808080; PADDING-TOP: 5px; BORDER-COLLAPSE: collapse; TEXT-ALIGN: left; BORDER-RIGHT-WIDTH: 0px; BORDER-RIGHT-COLOR: #808080; empty-cells: show
}
th {
	BORDER-TOP-WIDTH: 1px; PADDING-RIGHT: 5px; PADDING-LEFT: 5px; BORDER-LEFT-WIDTH: 0px; BORDER-LEFT-COLOR: #808080; BORDER-BOTTOM-WIDTH: 1px; BORDER-BOTTOM-COLOR: #808080; PADDING-BOTTOM: 5px; VERTICAL-ALIGN: middle; BORDER-TOP-COLOR: #808080; PADDING-TOP: 5px; BORDER-COLLAPSE: collapse; TEXT-ALIGN: center; BORDER-RIGHT-WIDTH: 0px; BORDER-RIGHT-COLOR: #808080; empty-cells: show
}
.noindent {
	MARGIN-LEFT: -5%; MARGIN-RIGHT: -5%
}
.moreindent {
	MARGIN-LEFT: 5%; MARGIN-RIGHT: 5%
}
.box {
	BORDER-RIGHT: 1px solid; PADDING-RIGHT: 10px; BORDER-TOP: 1px solid; PADDING-LEFT: 10px; PADDING-BOTTOM: 10px; BORDER-LEFT: 1px solid; PADDING-TOP: 10px; BORDER-BOTTOM: 1px solid; BACKGROUND-COLOR: #f0f0f0; page-break-inside: avoid
}
h1.title {
	FONT-WEIGHT: bold; FONT-SIZE: 160%
}
h1 {
	FONT-WEIGHT: bold; FONT-SIZE: 130%
}
h2 {
	FONT-WEIGHT: bold; FONT-SIZE: 105%
}
h3 {
	FONT-WEIGHT: bold; FONT-SIZE: 100%
}
h4 {
	FONT-SIZE: 100%; FONT-STYLE: italic
}
h5 {
	
}
ul {
	LIST-STYLE-TYPE: disc
}
dt {
	FONT-WEIGHT: bold
}
a:link {
	COLOR: rgb(0,0,255)
}
a:hover {
	COLOR: rgb(255,0,0)
}
pre {
	MARGIN-TOP: 1px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 1px; FONT-FAMILY: monospace
}
div.defname {
	FONT-WEIGHT: bold; FLOAT: left; TEXT-ALIGN: left
}
div.deftype {
	TEXT-ALIGN: right
}
div.titlebar {
	PADDING-RIGHT: 0.1em; PADDING-LEFT: 0.1em; PADDING-BOTTOM: 0.1em; PADDING-TOP: 0.1em; BACKGROUND-COLOR: #f0f0f0
}
div.defdescribe {
	MARGIN: 1px 0px 10px 80px; TEXT-ALIGN: justify
}
/* Reference style by Seiji */
.refhead { FONT-WEIGHT: bold }
.refbody { MARGIN-LEFT: 10px }
</style>

<meta content="MSHTML 6.00.2900.6003" name="GENERATOR"/></head>
<body>
<h2><a id="ch-Introduction" name="ch-Introduction">1. Introduction</a></h2>
<p>SWCLOS is a software toolkit for lisp programmers who want to process 
web ontologies in Lisp. The name is an acronym of Semantic Web Common Lisp Object 
System. As the name implies, SWCLOS is built on top of Common Lisp Object System 
(CLOS) for Semantic Webs. </p>
<p>In SWCLOS, every word in vocabularies of RDF, RDFS, 
OWL, and user-defined ontologies, denotes a CLOS object, and the computational 
semantics are based on RDF(S) and OWL rather than CLOS, whereas it still 
conforms to object-oriented paradigm. </p>
<p>SWCLOS is an amalgamation of Semantic Web Technology and Object-Oriented 
Programming (OOP) language. Compared with the other systems for Semantic Webs, 
SWCLOS has unique features. We may say pros and cons of SWCLOS are 
ascribed to the features of dynamic OOP language CLOS and the virtue of Lisp. If 
you believe you are a lisp programmer and you need developing an application for 
Semantic Technology, SWCLOS is the solution. Furthermore, if you have ever 
programmed CLOS programs, SWCLOS is the best choice. SWCLOS provides OWL Full 
level ontology meta-modeling facilities using CLOS meta-programming capability. 
You can encode CLOS programs for Semantic Webs on top of SWCLOS as you usually 
do in Lisp, whereas you must understand the difference of semantics between the 
standard CLOS and RDF(S)/OWL. </p>
<p>This document is userÅfs manual for SWCLOS programmers. Your program in SWCLOS 
can read ontology files in RDF/XML format, N-Triple format, and lisp 
S-expression which is specified for SWCLOS. Then, you can handle SWCLOS objects 
in Lisp, and write down computational results in the various formats mentioned 
above. Therefore, you can communicate with others in such formats for Semantic 
Webs. </p>
<p>If you are a CLOS programmer and want to understand what Semantic Technology 
is, SWCLOS provides you with a good chance to learn and get started Semantic 
Technology. </p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>2. &nbsp;SWCLOS Basics</h2>
<h3 height="30">2.1 &nbsp;How to Get SWCLOS</h3>
<p>SWCLOS is an Open Source Program that was originally developed at GALAXY 
EXPRESS CORPORATION in Japan, and the author of SWCLOS, 
has been continued updating it. The latest version is available from author's 
home page at National Institute of Informatics (NII) <a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2-en.htm">http://www-kasm.nii.ac.jp/~koide/SWCLOS2-en.htm</a>. 
</p>
<p>The SWCLOS current version is developed on Allegro Common Lisp (ACL) 8.1 and 8.2 
that is delivered by Franz Inc. for Windows or Mac OS X of Intell. We hope someone ports it to 
other lisp systems, although it is probably hard, because partly the 
implementation is concerned with ACL specific features. </p>
<h3 height="30">2.2 &nbsp;Proprietary Rights</h3>
<p>GALAXY EXPRESS CORPORATION held all copyrights and allowed anyone to use 
SWCLOS anyhow AS IS, except modifying the package name of <b>gx</b> and 
<b>gx-user</b>. ÅeGXÅf was the rocket 
name from GALAXY EXPRESS CORPORATION. See README file in delivery. </p>
<p><small>Note that the company GALAXY EXPRESS CORPORATION was undertaken by IHI 
Corporation at 2010, and the author is still working for IHI. So, 
he believes this term is inherited by IHI and still effective for the company 
IHI instead of GALAXY. Note that SWCLOS is a part of successful results of 
Japanese IT national programs titled ÅgBuilding Operation Support System for 
Large-Scale Systems using IT.Åh </small></p>
<h3 height="30">2.3 &nbsp;How to Start SWCLOS</h3>
<p>After compiling and loading SWCLOS into the <i>ACL modern lisp version</i>, it is 
much better to enter <b>gx-user</b> package in the lisp listener window to use 
SWCLOS.</p>
<p><table><tr><td><img alt="Caution" 
src="FIGURES/caution.PNG" border="0" width="20" height="20"/></td>
<td>Note that SWCLOS requires case-sensitive-lower on case mode of 
lisp-reader to distinguish upper and lower case of letters.</td></tr></table>
This features is not 
ANSI-standard today, but we hope it will be so, soon. </p>
<blockquote><code style="font-size:8pt">cg-user(1): (in-package gx-user)<br/>#&lt;The gx-user 
? package&gt;<br/>gx-user(2): <br/></code></blockquote>
<p>Franz has prepared a good tutorial for the case of letters. See <a 
href="http://www.franz.com/support/tutorials/casemode-tutorial.htm">http://www.franz.com/support/tutorials/casemode-tutorial.htm</a>. 
</p>
<h3 height="30">2.4 &nbsp;Monotonicity of Knowledge</h3>
<p>In Semantic Webs you assume that the knowledge always increases and the 
interpretation become monotonously more precise and richer. SWCLOS leverages the 
monotonicity principle in Semantic Webs to accept the forward reference in 
ontology description. In the current version, there are no delete functions for 
entities in ontologies, and there is no undo functionality (if you input inconsistent data, SWCLOS immediately 
signal an alarm and open the break window, so you can remedy problems immediately). Such functions will be 
provided at the next version. </p>
<p>You should use <b>put-value</b> function to put a new value to a 
slot value place with the above monotonic principle, instead of setf slot-value. 
Slot-value setting function (setf (slot-value ...) ...)
keeps the original CLOS semantics in this version. </p>
<h3 height="30">2.5 &nbsp;Open World Assumption and Three-Value Logic</h3>
<p>Semantic Webs assume that the World Wide Webs are dynamic, changeable, and 
open in the sense that no one knows all of WWWs. From the viewpoint of logic, 
Close World Assumption is a basic assumption of inference. Therefore, people who 
are accustomed to logic thinking should mind this point. </p>
<p>The primary function of Description Logics (DLs) is i) to classify objects to 
classes, ii) to determine whether or not a class is subsumed by another class. 
In SWCLOS, this work is performed by i) <b>gx:typep</b> and ii) 
<b>gx:subtypep</b> in the RDF universe, <b>subsumed-p</b> in the OWL universe. 
These functions return two values; the first value represents yes/no for query 
and the second represents the certainty. Therefore, we can deem such return 
values that the pair of <tt>&lt;t,t&gt;</tt> expresses boolean true, 
<tt>&lt;nil,t&gt;</tt> expresses boolean false, and <tt>&lt;nil,nil&gt;</tt> 
means unknown. Note <tt>&lt;t,nil&gt;</tt> never happens. This ternary-value 
logic is an extension of ANSI Common Lisp native specification on cl:subtypep, 
which returns two values described above. See the document of ANSI Common Lisp 
<a 
href="http://www.franz.com/support/documentation/8.2/ansicl/dictentr/subtypep.htm">http://www.franz.com/support/documentation/8.2/ansicl/dictentr/subtypep.htm</a>. 
However, you do not need to mind how to use ternary value logic. If you use only 
the first return value, your program does not care of unknown and it is regarded 
as boolean false. If you are interested how to compute ternary-value logic in 
SWCLOS, see the source code you obtained. </p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>3. &nbsp;URI, QName, and Resource</h2>
<p class="justify"><a href="http://www.w3.org/TR/rdf-primer/">The Resource 
Description Framework (RDF)</a> is a language for representing information about 
resources in the World Wide Webs, and it has a <a 
href="http://www.w3.org/TR/rdf-syntax-grammar/">special syntax in XML</a> called 
RDF/XML for short. In RDF, every resource, except literals and blank nodes, is 
identified with URI references. This idea originates from the meta-data markup 
for web resources. However, you do not need to mind in Semantic Webs or ontology 
descriptions whether resources in RDF really exist on the Webs or not. </p>
<p class="justify">In theory, a URI reference in RDF denotes an entity in the 
<i>universe of discourse</i>, namely a virtual world that reflects ideas on the 
real world. If a URI reference is a terminology in ontology, the URI reference 
in SWCLOS is bound with a CLOS object that represents a part of ontology on the 
denotation of a URI reference. You can input a URI reference object in SWCLOS 
using angle bracket reader macro &lsquo;&lt;&rsquo;, where URI reference reading is 
terminated by &lsquo;&gt;&rsquo;. In the following demonstration, note that expressions 
enveloped with &lsquo;&lt;&rsquo; and &lsquo;&gt;&rsquo; designate URIs, and expressions starting with a 
sharp character and enveloped with &lsquo;&lt;&rsquo; and &lsquo;&gt;&rsquo; designate objects in 
Lisp.</p><code style="font-size:8pt">gx-user(3): 
&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#Resource&gt;<br/>gx-user(4): 
(iri-value<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;)<br/>#&lt;rdfs:Class 
rdfs:Resource&gt;<br/></code>
<p class="justify">The QName is an abbreviation of URI reference with the <a 
href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">namespace function</a> 
for XML. For example, &ldquo;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;&rdquo; is 
abbreviated to &ldquo;rdfs:Resource&rdquo;. Here, the fragment-less URI or 
&ldquo;http://www.w3.org/2000/01/rdf-schema&rdquo; is mapped to &ldquo;rdfs&rdquo;, which is a prefix of 
QName, while a fragment &ldquo;Resource&rdquo; turns out a local part of QName. Franz Inc. 
provides URI APIs, in which a URI is implemented of CLOS objects typed to <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a>. 
In SWCLOS, a part of URI that corresponds to a prefix part of QName is connected 
to a lisp package, whereby a URI corresponds to a QName as lisp symbol in a 
package. Thus, a URI reference may have one by one mapping to a lisp symbol 
(QName), and vice versa, if it has a namespace. See the followings. 
</p><code style="font-size:8pt">gx-user(5): 
(uri2symbol<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;)<br/>rdfs:Resource<br/>gx-user(6): 
(symbol2uri 'rdfs:Resource)<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#Resource&gt;<br/></code>
<p class="justify">At the line 5 in the demonstration above, the URI is converted 
to the corresponding QName, and at line 6, the reverse operation is directed. 
Note that such correspondence can be established when SWCLOS loads an ontology 
including URI references, or when you input URI references as RDF entity in the 
lisp top level window. </p>
<p class="justify">In theory, the substance of RDF can be modeled as labeled 
uni-directional graph of edge and node called RDF graph. A start node of edge is 
called <i>subject</i>, an end node is called <i>object</i>, and an edge is 
called <i>predicate</i> in <i>triple</i>. So, a triple 
<i>subject/predicate/object</i> in text stands for the minimal structure in 
graph. A set of triples in text turns out a whole RDF graph. </p>
<p class="justify">A predicate in triple is a URI reference or QName, and the 
statement of predicate requires or produces the corresponding resource called 
property in RDF vocabulary. Note that any edge must be named by a URI in RDF. 
Furthermore, it must have a QName in SWCLOS, because it turns a slot name in 
CLOS. A subject in triple designates a non-literal resource, that is, the node 
must be expressed by a URI, otherwise it must be a blank node. The blank node 
has no URI but may be assigned with a blank node ID. An object in triple is 
either a resource (with or without URI) or a literal. The following shows an 
example of statement in N-Triple. </p><code style="font-size:8pt">&lt;JohnDoe&gt; 
&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;Man&gt; .</code> 
<p class="justify">In SWCLOS, a resource or an entity in RDF is realized as a CLOS 
object. A denotation of triple <i>subject/predicate/object</i> is represented by 
a subjective CLOS object and its slot of which the slot name is corresponding to 
a predicate. The slot value is an objective CLOS object (called <i>resource</i>) 
or lisp data (<i>literal</i>). </p>
<p class="justify">The subjective CLOS object is bound to the QName lisp symbol, 
if it is not a blank node.</p>
<blockquote><code style="font-size:8pt">gx-user(7): rdfs:Resource<br/>#&lt;rdfs:Class 
  rdfs:Resource&gt;<br/></code></blockquote>
<p class="justify">As well as a subjective CLOS object is bound to the QName, 
every subjective CLOS object, even if a blank node, is bound to the relevant 
URI. See the following demonstration. </p><code style="font-size:8pt">gx-user(8): 
(iri-value<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;)<br/>#&lt;rdfs:Class 
rdfs:Resource&gt;<br/>gx-user(9): 
&lt;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt;&gt;<br/>#&lt;rdfs:Class 
rdfs:Resource&gt;<br/></code>
<p class="justify"><a 
id="SWCLOSresourceobject" name="SWCLOSresourceobject"></a>Note that at line 9, the special reader macro for double angle 
brackets &lsquo;&lt;&lt;&rsquo; reads the character sequence of URI up to characters 
&lsquo;&gt;&gt;&rsquo; and then a bound value to the converted URI is returned. A CLOS 
object that represents a resource in RDF is called resource object in SWCLOS. 
</p>
<h3 height="30">3.1 &nbsp;IRI</h3>
<p class="justify">SWCLOS utilizes the URI APIs of Allegro Common Lisp (ACL). 
Please see the details <a 
href="http://www.franz.com/support/documentation/8.2/doc/uri.htm">http://www.franz.com/support/documentation/8.2/doc/uri.htm</a>. 
To implement value-bindable URI, a subclass of <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a> 
is defined with an extra value slot. This subclass is named IRI. Every IRI in 
SWCLOS is interned to ensure the uniqueness of IRI in system. </p>
<p><a 
id="SWCLOSiri" name="SWCLOSiri"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#iri">iri</a></div>
<div class="deftype">[Class]</div></div>
<div class="defdescribe">A subclass of <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a>. 
It has the definition of extra slot for value, to which the corresponding 
resource object is stored. </div></p>
<p>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#iri:iri">iri&nbsp;&nbsp;<i>thing</i></a></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">Four methods are defined for this generic function: When 
<i>thing</i> is an instance of <b>iri</b>, then interned value of it is 
returned. If <i>thing</i> is an instance of <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a>, 
its class is changed to <b>iri</b> and interned. The interned value is returned. 
When <i>thing</i> is a string, it is interned as a uri and its class is changed 
to <b>iri</b>. Otherwise, it signals an error. </div></p>
<p>
<a id="SWCLOSiri-value" name="SWCLOSiri-value"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#iri-value:string">iri-value&nbsp;&nbsp;<i>iri</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function returns a value in its value slot. 
<i>iri</i> must be an IRI or a string. This function is settable for an IRI. 
</div></p>
<p class="justify">There are several utilities for handling all uri and iri 
entries. See <a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#print-all-entity-uris">print-all-entity-uris</a>, 
<a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#do-all-entity-uris">do-all-entity-uris</a>, 
and <a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#list-all-entity-uris">list-all-entity-uris</a> 
in doc folder. </p>
<h3 height="30">3.2 &nbsp;QName</h3>
<p class="justify">A uri and iri in SWCLOS may be converted to the corresponding 
<a href="http://www.w3.org/TR/xml-names11/#ns-qualnames">QName</a>. The prefix 
of QName in XML is mapped to a lisp package in SWCLOS, and the local part is 
mapped to a symbol name in the package. A QName symbol is exported, because an 
exported lisp symbol has the same appearance as the QName in XML. A QName symbol 
is used to designate a resource name in S-expression. In fact, the description 
at the top level in SWCLOS requires a QName symbol instead of a URI in the 
context of define macros such as <a href="#SWCLOSdefConcept"><b>defConcept</b></a> 
and <a href="#SWCLOSdefIndividual"><b>defIndividual</b></a>. 
Some URI(IRI)s that have no prefix definition cannot be converted to QNames and 
remain as URI(IRI). </p>
<p class="justify">The mapping rule from URI to QName in SWCLOS is as follows. 
</p>
<ul>
  <li>If a URI has a fragment, SWCLOS attempts to create a QName symbol of which 
  name is the fragment and of which package is associated to the fragment-less 
  URI. If SWCLOS knows the mapping from the fragment-less URI to the package 
  name, the system automatically creates the QName symbol with its URI, 
  otherwise, in order to create the mapping from the fragment-less URI to the 
  package name, the system invokes the function that is bound to symbol <a 
  href="#SWCLOSuri2symbol-package-mapping-fun"><b>*uri2symbol-package-mapping-fun*</b></a> 
  with the fragment-less URI. </li>
  <li>If a URI has no fragment, then the irregular conversion procedure is 
  carried out as follows. SWCLOS firstly invokes the function bound to <a 
  href="#SWCLOSuri2symbol-name-mapping-fun"><b>*uri2symbol-name-mapping-fun*</b></a>. 
  If the returned value is a symbol, it is used. If the returned value is a 
  string, a symbol is created with the name and the associated package to the 
  URI. If SWCLOS does not know the associated package, then the system invokes 
  the function that is bound to symbol <b>*uri2symbol-package-mapping-fun*</b>, 
  and create a symbol. </li>
  <li>To the symbol <b>*uri2symbol-package-mapping-fun*</b>, currently as 
  default, the function that makes a query to users for package name is bound. </li>
  <li>When the function bound to <b>*uri2symbol-name-mapping-fun*</b> is 
  invoked, currently as default, if a URI has a fragment-less path, the 
  procedure for a fragment-less path parses the path into a directory and a 
  name. The name of path is a tail part in the path description and the other 
  part is a directory. The name is used for QName local part. The directory is 
  used for package association. Otherwise, in case of both no fragment in the 
  URI and no name in the path, a query to users is invoked for QName symbol 
  name. </li></ul>
<p class="justify">See the following demonstration.</p><code style="font-size:8pt">gx-user(17): 
(uri2symbol 
&lt;http://somewhere/maindir/subdir/JohnSmith&gt;)<br/>swsd:JohnSmith<br/>gx-user(18): 
(uri2symbol &lt;http://somewhere/JohnSmith&gt;)<br/>sw:JohnSmith<br/>gx-user(19): 
(uri2symbol &lt;http://JohnSmith/&gt;)<br/>no:J.S.</code> 
<p class="justify">At line 17, prefix query to users is carried out for 
&ldquo;&lt;http://somewhere/somedirectory/subdir/&gt;&rdquo;, and &ldquo;swsd&rdquo; is replied by a user. At 
line 18 for &ldquo;&lt;http://somewhere/&gt;&rdquo;, &ldquo;sw&rdquo; is replied. At line 19, the local name is 
required at first, then &ldquo;J.S.&rdquo; is supplied, then, &ldquo;no&rdquo;" is replied for the prefix 
query. </p>
<h3 height="30">3.3 &nbsp;URI Named Space</h3>
<p class="justify">A URI reference is unique in WWWs, and then <a 
href="http://www.w3.org/TR/1999/REC-xml-names-19990114/">XML namespace</a> 
supports the uniqueness of QName with a local part, which is unique in a name 
space. In SWCLOS, a local part of QName corresponds to symbol name in a package, 
and a namespace for a prefix part corresponds to a lisp package. To realize such 
mapping, we need the connection between a prefix part in URI and a lisp package, 
and when URI-to-symbol mapping is irregular such as demonstrated above, we 
further need the mapping from a URI to a symbol name in the lisp package. An 
instance of <b>uri-namedspace</b>, that is a subclass of <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a>, 
has two extra slots, package and environment, and it enables such named space 
environments for the URI name space. See the following demonstration. 
</p><code style="font-size:8pt">gx-user(2): (defpackage 
:ex<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(:documentation 
"http://somewhere/main/sub/file"))<br/>#&lt;The ex package&gt;<br/>gx-user(3): 
(set-uri-namedspace-from-pkg (find-package :ex))<br/>#&lt;The ex 
package&gt;<br/>gx-user(4): (get-uri-namedspace 
&lt;http://somewhere/main/sub/file&gt;)<br/>#&lt;uri-namedspace 
http://somewhere/main/sub/file&gt;<br/>gx-user(5): (uri2package 
"http://somewhere/main/sub/file")<br/>#&lt;The ex package&gt;<br/>gx-user(6): 
(uri2symbol "http://somewhere/main/sub/file#JohnSmith")<br/>ex:JohnSmith</code> 
<p class="justify">In the above demonstration, a URI string is set to a new 
package named ÅgexÅh as its documentation option at first, and then the regular 
mapping is set as prefix named space in system at line 3. So, URI to package 
mapping is established here as shown later on line 5. In regular mapping for a 
URI with fragment, regular URI to QName conversion is carried out in default 
rules without using the URI's symbol mapping environment. </p>
<p class="justify">A user may set any user-defined functions to global variable <a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*uri2symbol-name-mapping-fun*"><b>*uri2symbol-name-mapping-fun*</b></a> 
and <a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*uri2symbol-package-mapping-fun*"><b>*uri2symbol-package-mapping-fun*</b></a> 
in order to implement application-oriented rules for the irregular mapping in 
default. See the detail in the description of the documentation file of program 
in the doc folder and the source program. </p>
<p class="justify">When SWCLOS reads RDF/XML files, the namespace directions with 
<a 
href="http://www.w3.org/TR/REC-xml-names#NT-PrefixedAttName">PrefixedAttName</a> 
'xmlns:' and <a 
href="http://www.w3.org/TR/REC-xml-names#NT-DefaultAttName">DefaultAttName</a> 
'xmlns' make the mapping from a URI to the package name. On the other hand, from 
the standpoint of lisp expression, SWCLOS users can direct the mapping from a 
package to a uri in the package documentation as demonstrated above, in which a 
user put a corresponding URI as documentation of package. </p>
<p class="justify">Sometime you may be embarrassed at an error message of no 
package for a base-URI or a default namespace, when SWCLOS reads an RDF/XML 
file. It happens if an RDF/XML file does not include any Prefix name in the file 
for the file itself. In such a case, it is recommended that you supply two 
sentences, something like &ldquo;xmlns:base = '<i>somewhere</i>'&rdquo; and 
&ldquo;xmlns:<i>PREFIX</i> = '<i>somewhere</i>'&rdquo; into RDF attributes in the file. </p>
<p class="justify">Each <b>uri-namedspace</b> is stored in a hasharray which is 
bound to a global variable <a 
href="#SWCLOS*NameSpaces*"><b>*NameSpaces*</b></a>. 
The converting functions, <a 
href="#SWCLOSuri2symbol"><b>uri2symbol</b></a> 
and <a 
href="#SWCLOSsymbol2uri"><b>symbol2uri</b></a> 
use these mappings bound to <b>*NameSpaces*</b>. </p>
<p><a id="SWCLOS*NameSpaces*" name="SWCLOS*NameSpaces*"/>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*NameSpaces*">*NameSpaces*</a></div>
<div class="deftype">[Global Var]</div></div>
<div class="defdescribe">A variable where a hashtable is set. The hashtable is for 
interning prefix URIs that are instances of <b>uri-namedspace</b>. See the 
document of <a 
href="http://www.franz.com/support/documentation/8.2/doc/uri.htm#interning-uris-1">interning 
URIs</a>. The interning into this hashtable is carried out at the occurrence of 
the first mapping from a fragment-less URI, a name-less URI, or a specially 
directed URI to a package. See <a 
href="#SWCLOSuri2symbol">uri2symbol</a>. 
</div></p>
<p><a id="SWCLOSuri-namedspace" name="SWCLOSuri-namedspace"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#uri-namedspace">uri-namedspace</a></div>
<div class="deftype">[Class]</div></div>
<div class="defdescribe">Subclass of <a 
href="http://www.franz.com/support/documentation/8.2/doc/classes/uri/uri.htm">net.uri:uri</a> 
class. This subclass has two extra slot definitions; package slot definition and 
env slot definition. The associated lisp package is stored into the package slot 
and the irregular associations in the namespace between URIs and QName symbol 
names are stored into the env slot of this instance object. </div></p>
<p><a id="SWCLOSlist-all-uri-namedspaces" 
name="SWCLOSlist-all-uri-namedspaces"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#list-all-uri-namedspaces">list-all-uri-namedspaces 
</a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function returns a list of all uri-namedspaces in 
the system. </div></p>
<p><a id="SWCLOSset-uri-namedspace" name="SWCLOSset-uri-namedspace"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#set-uri-namedspace">set-uri-namedspace 
<i>prefix-uri</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function changes <i>prefix-uri</i> to a namedspace 
and registers it to system. You need to set a lisp package into the 
uri-namedspace package slot before the usage. </div></p>
<p><a id="SWCLOSget-uri-namedspace" name="SWCLOSget-uri-namedspace"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#get-uri-namedspace">get-uri-namedspace 
<i>prefix-uri</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function retrieves the uri-namedspace from 
<i>prefix-uri</i> and returns it. If <i>prefix-uri</i> is not an uri, cl:nil is 
returned. </div></p>
<p><a id="SWCLOSset-uri-namedspace-from-pkg" 
name="SWCLOSset-uri-namedspace-from-pkg"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#set-uri-namedspace-from-pkg">set-uri-namedspace-from-pkg 
<i>pkg</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function registers the namespace associated to 
<i>pkg</i>. The <i>pkg</i> must have a uri string in <i>pkg</i>'s document slot. 
</div></p>
<p><a id="SWCLOSdefault-namespace" name="SWCLOSdefault-namespace"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*default-namespace*">*default-namespace*</a></div>
<div class="deftype">[Global Var]</div></div>
<div class="defdescribe">When a default namespace is indicated by DefaultAttName 
'xmlns' in RDF/XML files and the system reads it, the namespace URI is set to 
this variable. This is often used in scoping of let form. </div></p>
<p><a id="SWCLOSbase-uri" name="SWCLOSbase-uri"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*base-uri*">*base-uri*</a></div>
<div class="deftype">[Global Var]</div></div>
<div class="defdescribe">When a base URI is indicated by &lsquo;xml:base&rsquo; in RDF/XML 
files and the system reads it, the URI is set to this variable. This is often 
used in scoping of let form. </div></p>
<p><a id="SWCLOSuri2symbol-package-mapping-fun" 
name="SWCLOSuri2symbol-package-mapping-fun"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*uri2symbol-package-mapping-fun*">*uri2symbol-package-mapping-fun*</a></div>
<div class="deftype">[Global Var]</div></div>
<div class="defdescribe">When there is no associated package for a URI, the 
function bound to this variable is invoked, and the return value is used as 
package for the corresponding QName symbol. This mechanism is useful to 
implement user-specific or application specific conversion as irregular mapping 
rule. The function bound to this symbol has to have one parameter, i.e., a URI. 
</div></p>
<p><a id="SWCLOSuri2symbol-name-mapping-fun" 
name="SWCLOSuri2symbol-name-mapping-fun"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#*uri2symbol-name-mapping-fun*">*uri2symbol-name-mapping-fun*</a></div>
<div class="deftype">[Global Var]</div></div>
<div class="defdescribe">When there is no associated name for a URI, the function 
bound to this variable is invoked, and the return value is used as name for 
QName symbol. This mechanism is useful to implement user-specific or 
application-specific conversion as irregular rule. The function bound to this 
symbol has to have one parameter, i.e., a URI. </div></p>
<p><a id="SWCLOSuri2symbol" name="SWCLOSuri2symbol"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#parse-uri">uri2symbol 
<i>uri</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">converts <i>uri</i> to the corresponding QName symbol and 
returns it. If <i>uri</i> is null (cl:nil) or null string, it returns cl:nil. If 
<i>uri</i> is a string, its parsed uri is used. <a 
href="#SWCLOS*NameSpaces*"><b>*NameSpaces*</b></a> 
is consulted for the association between a fragment-less or name-less URI and 
package. In the case of irregular mapping, the functions bound to <a 
href="#SWCLOSuri2symbol-package-mapping-fun"><b>*uri2symbol-package-mapping-fun*</b></a> 
and <a 
href="#SWCLOSuri2symbol-name-mapping-fun"><b>*uri2symbol-name-mapping-fun*</b></a> 
are called and the return value is used. See the mapping rule described above. 
</div></p>
<p><a id="SWCLOSsymbol2uri" name="SWCLOSsymbol2uri"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#symbol2uri">symbol2uri 
<i>symbol</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns a uri from rdf:about slot of this resource object 
if this <i>symbol</i> is defined as QName and the <a href="#SWCLOSresourceobject">resource 
object</a> is bound to this <i>symbol</i>. Otherwise this function retrieves the 
uri string from the symbol package of <i>symbol</i>, then returns a uri 
associated to <i>symbol</i> in the env slot if the association exists, or 
returns a uri that is made from package-corresponding (fragment-less) URI and 
symbol-name (as URI fragment). </div></p>
<p class="justify">Note that all resource names or QName symbols are exported. 
Therefore, in a dedicated package for a resource namespace, the following code 
is an example that lists up all defined uri in the namespace. 
</p><code style="font-size:8pt">gx-user(7): (loop for x being each external-symbol<br/>in (find-package 
:rdfs)<br/>collect (symbol2uri x))<br/>(#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#subPropertyOf&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#Datatype&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#domain&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#label&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#seeAlso&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#Container&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#subClassOf&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#isDefinedBy&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#Resource&gt;<br/>#&lt;uri 
http://www.w3.org/2000/01/rdf-schema#range&gt; ...)<br/></code><br/>
<p class="justify"><b>list-all-entities-in</b> performs almost same 
work.</p><code style="font-size:8pt">gx-user(4): (list-all-entities-in :rdfs)<br/>(rdfs:subPropertyOf 
rdfs:Datatype rdfs:domain rdfs:label rdfs:seeAlso<br/>rdfs:Container 
rdfs:subClassOf rdfs:isDefinedBy<br/>rdfs:Resource rdfs:range ...)<br/></code>
<p><a 
id="SWCLOSlist-all-entities-in" name="SWCLOSlist-all-entities-in"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#list-all-entities-in:uri">list-all-entities-in 
<i>space</i></a></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe"><i>space</i> must be a package, a package name, a package 
name string, or a uri. This method returns a list of all of external symbols in 
<i>space</i>. Note that even if a user defined external symbols in <i>space</i> 
without RDF resource definition, they are listed. See also <a 
href="#SWCLOSlist-all-resources">list-all-resources</a>. 
</div></p>
<p class="justify">Precisely speaking, we have some semantic gap between a URI 
namespace and a lisp package. The lisp package is always global in the current 
session. Namely, a lisp package for the namespace should be unique anywhere and 
anytime. The URI is also globally unique, but its namespace is a temporal 
setting for the URI abbreviation in the scope of a RDF/XML file or a Web page. 
In a RDF/XML file, a settled namespace for a URI is scoped within the file, and 
it is legal that someone set a different name of namespace for the identical URI 
in another RDF/XML file. Thus, in ideal the two files should be correctly merged 
regardless of namespaces but regarding URIs. For example, if you have two 
ontology files, one has a namespace &lsquo;wine&rsquo; for some URI and another has a 
namespace &lsquo;vin&rsquo; for the same URI, the system must read both in the same 
namespace. However, Lisp cannot read symbols in different packages into some one 
package. To solve this problem, the lisp package nicknames are utilized here. 
When SWCLOS detects the mapping different package names onto a same URI, the 
newly indicated prefix turns out a nickname for the previously mapped package. 
Even so, note that the first encountered package name is a nominal name and 
nickname's prefixes do not appear in S-expression.</p>
<h3 height="30">3.4 &nbsp;Resource</h3>
<p class="justify">In addition to the URI-value mapping mentioned above, a CLOS 
object as resource is also set as symbol-value to the QName symbol, if it has a 
QName, or to an assigned nodeID symbol, if it has a nodeID. To test whether a 
CLOS object is a resource object or not, you may use lisp native type predicate 
<a 
href="http://www.franz.com/support/documentation/8.2/ansicl/dictentr/typep.htm">cl:typep</a> 
as follows. Note to use <a 
href="#SWCLOStypep"><b>gx:typep</b></a> 
predicate, if you need a type-testing predicate that exactly obeys RDFS 
semantics up to the range of URIs and Literals. </p>
<blockquote><code style="font-size:8pt">gx-user(2): (cl:typep rdfs:Resource 
  rdfs:Resource)<br/>t<br/>gx-user(3): (cl:typep rdfs:Class 
  rdfs:Resource)<br/>t<br/>gx-user(4): (cl:typep rdf:Property 
  rdfs:Resource)<br/>t<br/></code></blockquote>
<p class="justify">In the example above, three resource objects, named 
rdfs:Resource, rdfs:Class, and rdf:Property, are tested whether they are 
instances of class rdfs:Resource.</p>
<p class="justify"><a id="SWCLOSobject?" name="SWCLOSobject?"></a>Predicate <b>rsc-object-p</b> is prepared for testing whether 
an CLOS object is a resource object or not. It is same as (cl:typep x 
rdfs:Resource) in the semantics but it is faster a bit and simplifies your code. 
Note that <b>object?</b> is used for testing a QName symbol or a nodeID symbol 
to which a resource object is bound.</p>
<blockquote><code style="font-size:8pt">gx-user(5): (object? 'rdfs:Resource)<br/>t<br/>gx-user(6): 
  (object? 'rdfs:Class)<br/>t<br/>gx-user(7): (object? 
  'rdf:Property)<br/>t<br/></code></blockquote><br/>
<p>
<div class="titlebar" height="1em">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#object?">object? 
<i>symbol</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>symbol</i> has a resource object, 
otherwise returns false. </div></p>
<p class="justify"><a id="SWCLOSlist-all-resources" name="SWCLOSlist-all-resources"></a>To list up all resources defined in the system, you can use 
<b>list-all-resources</b> as follows.</p><code style="font-size:8pt">gx(8): (list-all-resources 
t)<br/>(#&lt;rdfs:Class rdfs:Resource&gt; #&lt;rdfs:Class rdfs:Container&gt; 
<br/>&nbsp;#&lt;rdfs:Class rdf:Alt&gt; #&lt;rdfs:Class rdf:Seq&gt; 
#&lt;rdfs:Class rdf:Bag&gt;<br/>&nbsp;#&lt;rdfs:Class 
gx::ill-structured-XMLLiteral&gt; #&lt;rdfs:Class rdf:Statement&gt; 
<br/>&nbsp;#&lt;rdfs:Class rdf:List&gt; #&lt;rdf:List rdf:nil&gt; #&lt;rdfs:Class 
rdfs:Literal&gt;<br/>&nbsp;...)<br/></code><br/>
<p>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#list-all-resources">list-all-resources 
[<i>with-system-rdf-object-p</i>]</a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function lists up all of resources that are defined 
as instance of rdfs:Resource. An instance of rdf:XMLLiteral is not included in 
the list. <i>with-system-rdf-object-p</i> is optional and RDF(S) and OWL 
resources are included if true is supplied, otherwise only user-defined 
resources are included. </div></p>
<p class="justify">In most cases, a resource object is named with a QName. The 
method <a href="#SWCLOSname"><b>name</b></a> 
gets the name from a resource object and returns its QName symbol. The resource 
object is set to the QName symbol. On the other hand, resource objects that have 
no name are called <i>anonymous</i> resource, or <i>blank node</i>, or 
<i>bnode</i> for short, and you can access them through <b>iri-value</b> 
function rather than symbol value.</p><code style="font-size:8pt">gx-user(2): (name 
rdfs:Resource)<br/>rdfs:Resource<br/>gx-user(3): (addObject rdfs:Resource 
'((rdf:about "NothingElseURI")))<br/>#&lt;rdfs:Resource 
:anonymous&gt;<br/>gx-user(4): 
&lt;&lt;NothingElseURI&gt;&gt;<br/>#&lt;rdfs:Resource 
:anonymous&gt;<br/>gx-user(5): (slot-value &lt;&lt;NothingElseURI&gt;&gt; 
'rdf:about)<br/>"NothingElseURI"<br/>gx-user(6): (anonymous-p 
&lt;&lt;NothingElseURI&gt;&gt;)<br/>t<br/></code>
<p class="justify">Note that in the above demonstration, an anonymous object is 
created at line 3, whose URI string is "NothingElseURI". So, 
&lt;NothingElseURI&gt; at line 4 is parsed to a uri, and the resource object is 
retrieved through <b>iri-value</b> and returned it.</p>
<p><a id="SWCLOSnamed-p" 
name="SWCLOSnamed-p"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#named-p">named-p 
<i>resource</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if a resource object <i>resource</i> has a 
name, otherwise false. If <i>resource</i> is not a resource object, it returns 
false. </div></p>
<p><a id="SWCLOSanonymous-p" name="SWCLOSanonymous-p"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#anonymous-p">anonymous-p 
<i>resource</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>resource</i> has no name, otherwise 
false. If <i>resource</i> is not a resource object, it returns false. </div></p>
<p><a id="SWCLOSname" name="SWCLOSname"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#name:resource">name 
<i>resource</i></a></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">returns the name of <i>resource</i>, if named. Otherwise 
cl:nil. Note that this function is different from <a 
href="http://www.franz.com/support/documentation/8.2/doc/operators/cg/n/name.htm">cg:name</a> 
in ACL. </div></p>
<h3 height="30">3.5 &nbsp;NodeID</h3>
<p class="justify">A nodeID is used for referring anonymous node, especially in 
N-Triple notation. It looks like QName that has &lsquo;_&rsquo; as prefix and meaningless 
local name such as &lsquo;a01&rsquo;. However, a nodeID is not associated to any URI and has 
no global identification. There is a package dedicated for nodeID in SWCLOS, its 
package name is &lsquo;_&rsquo;, and a nodeID is also a lisp symbol in SWCLOS. You can bind 
any blank node to a nodeID symbol in the current session, but there is no way to 
store and reload the information on nodeID bindings by SWCLOS. The following 
functions are for the nodeID. However, there are useful functions no more on 
NodeIDs in SWCLOS. Be careful to use NodeIDs with respect to the identity of 
blank nodes according to RDF Semantics. See <a 
href="http://www.w3.org/TR/rdf-mt/">RDF Semantics</a>.</p>
<p><a id="SWCLOSnodeID?" 
name="SWCLOSnodeID?"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#nodeID?">nodeID? 
<i>name</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe"><i>name</i> should be a symbol. This function returns <a 
href="http://www.franz.com/support/documentation/8.2/ansicl/glossary/t.htm#true">true</a> 
if <i>name</i> can be regarded as a nodeID, namely its package name is &lsquo;_&rsquo;, 
otherwise returns <a 
href="http://www.franz.com/support/documentation/8.2/ansicl/glossary/f.htm#false">false</a>. 
This function does not care of a bound value of <i>name</i>. </div></p>
<p><a id="SWCLOSnodeID2symbol" name="SWCLOSnodeID2symbol"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#nodeID2symbol">nodeID2symbol 
<i>str</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">interns a nodeID symbol whose name is <i>str</i> in the 
nodeID package, exports and returns it. Users must ensure the uniqueness of the 
nodeID in this function usage. </div></p>
<p><a id="SWCLOSmake-unique-nodeID" name="SWCLOSmake-unique-nodeID"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdf.html#make-unique-nodeID">make-unique-nodeID 
<i>str</i></a></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">interns a nodeID symbol whose name begins with <i>str</i> 
and has succeeding digits, exports and returns it. The system assures the 
uniqueness of the nodeID in the current system. </div></p>
<p class="justify">As well as character &lsquo;&lt;&rsquo; being a reader macro on for URI, 
character &lsquo;_&rsquo; is also a reader macro so that the character sequence of the 
succeeding colon and other characters makes an exported lisp symbol, and the 
symbol is handed to eval function if it is bound. Otherwise new anonymous 
resource object is created and bound to the symbol, then the symbol is handed to 
eval function. See the following demonstration. </p><code style="font-size:8pt">gx-user(2): 
_:a01<br/>#&lt;|rdfs:Resource| :anonymous&gt;<br/>gx-user(3): (quote 
_:a01)<br/>_:a01<br/>gx-user(4): (list _:a01 _:a02)<br/>(#&lt;|rdfs:Resource| 
:anonymous&gt; #&lt;|rdfs:Resource| :anonymous&gt;)<br/>gx-user(5): (eq _:a01 
_:a01)<br/>t<br/>gx-user(6): (eq _:a01 _:a02)<br/>nil<br/></code>
<p class="justify">Where |rdfs:Resource| denotes the alternative to rdfs:Resource 
in SWCLOS, which is provided instead of rdfs:Resource when rdfs:Resource is 
specified as class of instances. It is expected that rdfs:Resource should be an 
abstract class in CLOS and finally all slots are defined at subclasses of 
rdfs:Resource, even if some slot definitions might be tentatively designated to 
rdfs:Resource. |rdfs:Resource| is useful to suppress making wasteful slot 
definitions at rdfs:Resource.</p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>4. &nbsp;RDF Resource Objects</h2>
<h3 height="30">4.1 &nbsp;Resource Objects and the Syntax in S-expression </h3>
<p>In RDF graph model, a node is represented by either resource nodes or 
literals. A resource node is either a named node, which has a globally unique 
URI, or a blank node, which has no URI. A literal is a kind of string or number, 
or an instance of XMLLiteral. Figure 4.1, which is taken from <a 
href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML Syntax 
Specification</a>, shows an example of RDF graph. In the figure, a rectangle 
represents a literal and an ellipse represents an anonymous blank node or a 
resource node that contains a URI inside. In SWCLOS, Figure 4.1 is expressed as 
follows in S-expression. </p><br/>
<p align="center"><a id="figure4.1" name="figure4.1"><img alt="RDF Graph Example" 
src="FIGURES/RDFGraphExample.png" border="0"/> </a></p>
<p align="center"><b>Figure 4.1 RDF Graph Example (from <a 
href="http://www.w3.org/TR/rdf-syntax-grammar/">RDF/XML Syntax 
Specification</a>)</b></p>
<code style="font-size:8pt">(rdf:Description 
<br/>&nbsp;&nbsp;(rdf:about&nbsp;"http://www.w3.org/TR/rdf-syntax-grammar")<br/>
&nbsp;&nbsp;(ex:editor<br/>&nbsp;&nbsp;&nbsp;&nbsp;(rdf:Description<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex:homePage<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:Description&nbsp;(rdf:about&nbsp;"http://purl.org/net/dajobe/")))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex:fullName&nbsp;"Dave 
Beckett")))<br/>
&nbsp;&nbsp;(dc:title&nbsp;"RDF/XML&nbsp;Syntax&nbsp;Specification&nbsp;(Revised)"))</code>
<br/>
<p>Whereas rdf:about in SWCLOS looks like a property in RDF, it is not a 
property in RDF but an XML attribute that takes a place in RDF/XML format 
resource definition. The ex:editor, ex:homePage, ex:fullName, and dc:title are 
RDF properties in QName representation for the corresponding URIs on the edges 
in the figure. The terminology &lsquo;rdf:Description&rsquo; that appears in S-expression 
for RDF graph representation just denotes a sequence for RDF description. With 
<a 
href="#SWCLOSaddForm"><b>addForm</b></a> 
function, this statement turns out a resource object. See the syntax in BNF 
described below. Precisely, the assertion above produces three CLOS objects, 
that is, two named resource objects and one anonymous resource object, in 
addition to two lisp strings. </p>
<h3 height="30">4.2 &nbsp;Adding and Getting a Resource Form</h3>
<p>SWCLOS allows users to add such a form as mentioned in the previous section, 
that is, <i>nested object-centered representation</i> of RDF graph into the lisp 
environment. However, if a resource name is not supplied, the created object is 
anonymous. See the following example. If you type the lines as the 
demonstration, a dialogue window will pop up twice at the line 5 for package 
name of uri &ldquo;http://purl.org/net/&rdquo; and &ldquo;http://www.w3.org/TR/&rdquo;. Please note to 
push &lsquo;cancel&rsquo; button in this case. If you gave some package name for the query, 
SWCLOS would create the package and make a symbol, e.g., 
<i>package-name-you-input</i>:dajobe. Then, you would obtain a different look at 
line 6, where the symbol name <i>package-name-you-input</i>:dajobe would appear 
instead of &lsquo;(rdf:Description (rdf:about "http://purl.org/net/dajobe/"))&rsquo; for the 
anonymous object. </p>
<code style="font-size:8pt">gx-user(3): (defpackage 
ex)<br/>#&lt;The ex package&gt;<br/>gx-user(4): (defpackage dc)<br/>#&lt;The dc 
package&gt;<br/>gx-user(5): (addForm '(rdf:Description<br/>&nbsp;&nbsp;(rdf:about 
"http://www.w3.org/TR/rdf-syntax-grammar")<br/>&nbsp;&nbsp;(ex::editor<br/>&nbsp;&nbsp;&nbsp;&nbsp;(rdf:Description<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex::homePage<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:Description 
(rdf:about 
"http://purl.org/net/dajobe/")))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex::fullName 
"Dave Beckett")))<br/>&nbsp;&nbsp;(dc::title "RDF/XML Syntax Specification 
(Revised)")))<br/>Warning: Entail by rdf1: ex::editor rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: dc::title rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: ex::homePage rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: ex::fullName rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| common-lisp:nil&gt;<br/>gx-user(6): (pprint 
(get-form 
&lt;&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt;&gt;))<br/><br/>(rdf:Description 
(rdf:about 
"http://www.w3.org/TR/rdf-syntax-grammar")<br/>&nbsp;&nbsp;(ex:editor<br/>&nbsp;&nbsp;&nbsp;&nbsp;(rdf:Description<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex:homePage 
(rdf:Description (rdf:about 
"http://purl.org/net/dajobe/")))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(ex:fullName 
"Dave Beckett")))<br/>&nbsp;&nbsp;(dc:title "RDF/XML Syntax Specification 
(Revised)"))<br/></code>
<p>Do not care about those warnings at line 5 at this time. It will be explained 
at <a 
href="#Section5.5"><b>Section 
5.5</b></a>. In this example, an RDF graph shown in <b>Figure 4.1</b> is 
inputted through a form in S-expression in SWCLOS, and three objects are created 
in the environment. You can backwardly generate the form in RDF graph from the 
subjective resource object using <b>get-form</b> in the lisp top level. </p>
<p>The value of property &lsquo;ex:editor&rsquo; is anonymous. The value of &lsquo;ex:homePage&rsquo; is 
also anonymous, because SWCLOS did not obtain the name by your cancellation for 
its package name. Note that SWCLOS cannot identify anonymous objects by name, 
even if they have the URI in rdf:about attribute. (However, you can get anonymous objects through corresponding URIs with function iri-value.)</p>
<p>Function <b>addForm</b> interprets a <i>form</i> according to the following 
BNF syntax, where {A--Z} means any character from A to Z, and {<i>SomeNode</i> - 
<i>element</i>} means the possibility of <i>SomeNode</i> minus <i>element</i>. 
Also note &lsquo;<i>xyz</i>&rsquo; means a sequence of character <i>x</i>, <i>y</i>, and 
<i>z</i>. #\x means a character <i>x</i>. </p><i>form</i> ::= <i>number</i> | 
<i>string</i> | <i>uri</i> | <i>qname</i> | <i>langedString</i> | 
<i>datatypeString</i> 
|<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* <i>lang-tag</i> <i>ws</i><sup>+</sup> <i>string</i> <i>ws</i>* &lsquo;)&rsquo; | &lsquo;(&rsquo; 
<i>ws</i>* <i>datatype</i> <i>ws</i><sup>+</sup> <i>datum</i> <i>ws</i>* &lsquo;)&rsquo; | 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* &lsquo;@&rsquo; <i>ws</i><sup>+</sup> <i>lang-tag</i> <i>ws</i><sup>+</sup> <i>string</i> <i>ws</i>* 
&lsquo;)&rsquo; | <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* &lsquo;^^&rsquo; <i>ws</i><sup>+</sup> <i>datatype</i> <i>ws</i><sup>+</sup> <i>datum</i> <i>ws</i>* 
&lsquo;)&rsquo; | <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* &lsquo;rdf:Description&rsquo; [<i>ws</i><sup>+</sup> <i>nform</i>] {<i>ws</i><sup>+</sup> 
<i>lang-form</i> | <i>ws</i><sup>+</sup> <i>slot-form</i>}* <i>ws</i>* &lsquo;)&rsquo; 
|<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* <i>type-tag</i> [<i>ws</i><sup>+</sup> <i>nform</i>] {<i>ws</i><sup>+</sup> 
<i>lang-form</i> | <i>ws</i><sup>+</sup> <i>slot-form</i>}* <i>ws</i>* 
&lsquo;)&rsquo;<br/><i>lang-form</i> ::= &lsquo;(&rsquo; <i>ws</i>* &lsquo;xml:lang&rsquo; <i>ws</i><sup>+</sup> <i>lang-tag</i> 
<i>ws</i>* &lsquo;)&rsquo; <br/><i>slot-form</i> ::= &lsquo;(&rsquo; <i>ws</i>* &lsquo;rdf:about&rsquo; <i>ws</i><sup>+</sup> 
<i>uri</i> <i>ws</i>* &lsquo;)&rsquo; | &lsquo;(&rsquo; <i>ws</i>* &lsquo;rdf:ID&rsquo; <i>ws</i><sup>+</sup> <i>name</i> 
<i>ws</i>* &lsquo;)&rsquo; | 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* &lsquo;rdf:nodeID&rsquo; <i>ws</i><sup>+</sup> <i>bname</i> <i>ws</i>* &lsquo;)&rsquo; | &lsquo;(&rsquo; <i>ws</i>* 
&lsquo;:name&rsquo; <i>ws</i><sup>+</sup> <i>name</i> <i>ws</i>* &lsquo;)&rsquo; | 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lsquo;(&rsquo; 
<i>ws</i>* <i>role</i> {<i>ws</i><sup>+</sup> <i>lang-tag</i>}? {<i>ws</i><sup>+</sup> <i>form</i>}<sup>+</sup> 
<i>ws</i>* &lsquo;)&rsquo; <br/><i>langedString</i> ::= <i>string</i> &lsquo;@&rsquo; <i>language</i> 
<br/><i>language</i> ::= {a--z}<sup>+</sup> {&lsquo;-&rsquo; {a--z0--9}<sup>+</sup>}*, comforming to <a 
href="ftp://ftp.isi.edu/in-notes/bcp/bcp47.txt">IETF BCP 47</a> 
<br/><i>lang-tag</i> ::= &lsquo;:&rsquo; {a--z}<sup>+</sup> {&lsquo;-&rsquo; {a--zA--Z0--9}<sup>+</sup>}*, comforming to <a 
href="ftp://ftp.isi.edu/in-notes/bcp/bcp47.txt">IETF BCP 
47</a><br/><i>datatypeString</i> ::= <i>string</i> &lsquo;^^&rsquo; <i>datatype</i> 
<br/><i>datatype</i> ::= <i>symbol</i> - &lsquo;cl:nil&rsquo; - &lsquo;t&rsquo;, comforming to xsd 
datatype (see <a 
href="#SWCLOSdatatype">Section 
6</a>)<br/><i>nform</i> ::= <i>name</i> | &lsquo;(&rsquo; <i>ws</i>* &lsquo;:name&rsquo; <i>ws</i><sup>+</sup> <i>name</i> <i>ws</i>* &lsquo;)&rsquo; 
<br/><i>role</i> ::= <i>symbol</i> - &lsquo;cl:nil&rsquo; - &lsquo;t&rsquo; <br/><i>type-tag</i> ::= 
<i>symbol</i> - &lsquo;cl:nil&rsquo; - &lsquo;t&rsquo; <br/><i>symbol</i> ::= <i>qname</i> | 
<i>unexported-qname</i> <br/><i>qname</i> ::= [<i>prefixName</i> &lsquo;:&rsquo;] <i>name</i> 
<br/><i>unexported-qname</i> ::= <i>prefixName</i> &lsquo;::&rsquo; <i>name</i> 
<br/><i>prefixName</i> ::= {<i>nameStartChar</i> - &lsquo;:&rsquo; - &lsquo;_&rsquo;} <i>nameChar</i>* 
<br/><i>name</i> ::= <i>nameStartChar</i> <i>nameChar</i>* <br/><i>bname</i> ::= 
&lsquo;_:&rsquo; <i>name</i> <br/><i>nameStartChar</i> ::= See <a 
href="http://www.w3.org/TR/xml11/#NT-NameStartChar">XML 1.1 NameStartChar</a>. 
<br/><i>nameChar</i> ::= See <a 
href="http://www.w3.org/TR/xml11/#NT-NameChar">XML 1.1 NameChar</a>. 
<br/><i>string</i> ::= &lsquo;"&rsquo; <i>scharacter</i>* &lsquo;"&rsquo; <br/><i>scharacter</i> ::= 
{<i>echaracter</i> -- &lsquo;"&rsquo;} | &lsquo;\"&rsquo; <br/><i>echaracter</i> ::= <i>character</i> | 
&lsquo;#\Tab&rsquo; | &lsquo;#\Newline&rsquo; | &lsquo;#\Return&rsquo; <br/><i>character</i> ::= &lsquo;#\\&rsquo; | {#\Space -- #\[} | 
{#\] -- #x10FFFF}, up to the limit of UNICODE <br/><i>ws</i> ::= &lsquo;#\Space&rsquo; | &lsquo;#\Tab&rsquo; 
| &lsquo;#\Newline&rsquo; <br/><i>uri</i> ::= string conformable to <a 
href="http://www.ietf.org/rfc/rfc1630.txt">URI in W3C</a> <br/><i>datum</i> ::= 
string or lisp object that conforms to designated datatype<br/><i>number</i> ::= 
number character sequence in Lisp, cf. <a 
href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node189.html#SECTION002612000000000000000">Parsing 
of Numbers and Symbols</a> <br/><br/>
<p><a id="SWCLOSaddForm" name="SWCLOSaddForm"/>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#addform">addForm</a> 
<i>form</i> [<i>role</i>]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">typically returns a resource object for <i>form</i>. In the top 
  level, <i>role</i> is not supplied. Otherwise, <i>role</i> must be supplied in 
  recursive call with <i>form</i> as <i>role</i>'s filler. <br/>
  <ul>
    <li>When <i>form</i> is a lisp number, a lisp string, an instance of 
    <b>rdf:inLang</b>, and an instance of rdfs:Literal, it is returned. </li>
    <li>When <i>form</i> is a <a 
    href="#SWCLOSiri"><b>uri</b></a>, 
    it is returned if <i>role</i> is null (at top level), rdf:about, 
    rdfs:isDefinedBy, or the <i>role</i>'s range is xsd:anyURI or its subtype, 
    else the uri is converted to the QName symbol and <b>addForm</b> is 
    recursively called with the converted QName symbol. </li>
    <li>When <i>form</i> is a symbol, its resource object (symbol value) is 
    returned if it exists, else the resource is created using the range 
    entailment rule. </li>
    <li>When <i>form</i> is a resource object, it is returned. </li>
    <li>If <i>form</i> is a lang form, the language environment is changed to 
    the designated language. The scoping of language environment is inside this 
    function calling. </li>
    <li>If <i>form</i> is a lang-tag form, an <i>rdf:inLang</i> structure 
    instance is created and returned. </li>
    <li>If <i>form</i> is a type-tag form, then <i>datum</i> is interpreted as 
    <i>type-tag</i> if possible and returns the result, otherwise signals an 
    error. </li>
    <li>When this function interprets a slot form or &lsquo;(<i>role</i> 
    <i>filler</i>)&rsquo;, it recursively calls itself with parameter <i>filler</i> 
    for <i>form</i> and <i>role</i> for <i>role</i>, and returns the result. </li>
    <li>Otherwise, this function recursively calls for each of slot forms and 
    the list of evaluated slots is obtained, then function <b>addObject</b> is 
    invoked for the class(es) that is/are computed from <i>type-tag</i> and 
    entailment rules with the evaluated slots. The result of <b>addObject</b> is 
    returned. </li></ul>A user usually do not use this function directly, instead 
  a user should use <a 
  href="#SWCLOSdefIndividual"><b>defIndividual</b></a> 
  or <a 
  href="#SWCLOSdefConcept"><b>defConcept</b></a> 
  (<a 
  href="#SWCLOSdefResource"><b>defResource</b></a>) 
  or <a 
  href="#SWCLOSdefProperty"><b>defProperty</b></a> 
  macro for resource definition. <br/>See also <a 
  href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#addForm">addForm</a> 
  in documentation in doc folder. </div></p>
<p>
<a id="SWCLOSget-form" 
name="SWCLOSget-form"></a>
<div class="titlebar">
<div class="defname"><a 
href="http://www-kasm.nii.ac.jp/~koide/SWCLOS2/doc/overview-rdfs.html#get-form">get-form</a> 
<i>resource</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">generates and returns the form of <i>resource</i> in S-expression. 
</div></p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>5. &nbsp;RDFS Vocabularies and Semantics</h2>
<p>The RDF ontology description language, <a 
href="http://www.w3.org/TR/rdf-schema/">RDF Schema (RDFS)</a>, is a semantic 
extension of RDF. It provides a device to describe groups of same kind resources 
(classes) and the inclusiveness among these groups. RDFS provides the minimal 
set for describing concepts for ontology. The vocabulary contains rdfs:Resource 
and rdfs:Class, which provide the classification notion together with the 
property rdf:type, and the subsumption notion of classification with the 
property rdfs:subClassOf. These semantics of RDFS is similar to the CLOS 
perspective, namely rdf:type to instance-class relation and rdfs:subClassOf to 
subclass-superclass relation. Therefore, RDFS classes are mapped onto CLOS 
classes and RDFS instances are mapped onto CLOS instances in SWCLOS.</p>
<h3 height="30">5.1 &nbsp;Resource Classes, Metaclasses, and Instances </h3>
<p><b>Figure 5.1</b> shows the relationship in RDF(S) vocabulary. A broken 
curved line stands for rdf:type relation, and a solid straight line stands for 
rdfs:subClassOf relation. rdfs:Resource is a superclass of all other classes, 
and rdfs:Class is a class of all classes, including rdfs:Class itself. A class 
of classes is called <i>metaclass</i> in CLOS. So, rdfs:Class and rdfs:Datatype 
in RDFS vocabulary are metaclasses in CLOS.</p>
<p align="center"><img alt="RDFS Graph" 
src="FIGURES/RDFSHierarchy.PNG" border="0"/> </p>
<p align="center"><b>Figure 5.1 RDFS Hierarchy Graph</b></p>
<p></p>
<p>The notion of metaclass, class, and instance is very important in CLOS. 
Therefore, predicates for these categories on RDF resources are prepared. See 
the followings.</p>
<code style="font-size:8pt">gx-user(33): (rsc-object-p 
rdfs:Class)<br/>t<br/>gx-user(34): (rsc-object-p 
rdfs:Resource)<br/>t<br/>gx-user(35): (rsc-object-p 
rdf:Property)<br/>t<br/>gx-user(36): (rsc-object-p 
rdfs:comment)<br/>t<br/>gx-user(37): (rsc-object-p "This is a 
comment.")<br/>nil<br/>gx-user(38): (rsc-object-p "This is also a 
comment."@en)<br/>nil<br/>gx-user(39): (rsc-object-p 
"1"^^xsd:nonNegativeInteger)<br/>t<br/>gx-user(40): (rsc-object-p 
1)<br/>nil<br/>gx-user(41): (rsc-object-p &lt;Foo&gt;)<br/>nil<br/>gx-user(42): 
(rsc-object-p &lt;&lt;Foo&gt;&gt;)<br/>t<br/>gx-user(43): (rdf-class-p 
rdfs:Class)<br/>t<br/>gx-user(44): (rdf-class-p 
rdfs:Resource)<br/>t<br/>gx-user(45): (rdf-class-p 
rdf:Property)<br/>t<br/>gx-user(46): (rdf-class-p 
rdfs:comment)<br/>nil<br/>gx-user(47): (rdf-metaclass-p 
rdfs:Class)<br/>t<br/>gx-user(48): (rdf-metaclass-p 
rdfs:Resource)<br/>nil<br/>gx-user(48): (rdf-instance-p 
rdf:Property)<br/>nil<br/>gx-user(49): (rdf-instance-p 
rdfs:comment)<br/>t<br/>gx-user(50): (rdf-class-p rdf:List)<br/>t<br/>gx-user(51): 
(rdf-instance-p rdf:nil)<br/>t<br/></code>
<p><a id="SWCLOSrsc-object-p" name="SWCLOSrsc-object-p"/>
<div class="titlebar">
<div class="defname">rsc-object-p <i>x</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>x</i> is not a literal but an resource object in RDF. Actually, this 
  function returns true, if <i>x</i> is an instance of rdfs:Resource in CLOS. 
  This is same as (cl:typep x rdfs:Resource), but more efficient a little bit. 
</div></p>
<p><a id="SWCLOSclass-p" name="SWCLOSclass-p"/>
<div class="titlebar">
<div class="defname">rdf-class-p <i>thing</i></div>
<div class="deftype">[Function]]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>thing</i> is a class of resource in RDF. Actually, this function returns 
  true, if <i>thing</i> is rdfs:Class or an instance of rdfs:Class in CLOS. 
</div></p>
<p><a id="SWCLOSmetaclass-p" name="SWCLOSmetaclass-p"/>
<div class="titlebar">
<div class="defname">rdf-metaclass-p <i>thing</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>thing</i> is a metaclass of resource. Actually, this function returns 
  true, if <i>thing</i> is rdfs:Class or an instance and simultaneously subclass 
  of rdfs:Class in CLOS. </div></p>
<p><a id="SWCLOSstrict-class-p" name="SWCLOSstrict-class-p"/>
<div class="titlebar">
<div class="defname">strict-class-p <i>thing</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>thing</i> is a class but not a metaclass of resource. </div></p>

<a id="SWCLOSrdf-instance-p" name="SWCLOSrdf-instance-p"/>
<div class="titlebar">
<div class="defname">rdf-instance-p <i>thing</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>thing</i> is an instance of rdfs:Resource but not an instance of 
  rdfs:Class. </div>
<p><a id="SWCLOSresource?" name="SWCLOSresource?"/>
<div class="titlebar">
<div class="defname">resource? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>symbol</i> is a symbol and its value is a resource. </div></p>
<p><a id="SWCLOSclass?" name="SWCLOSclass?"/>
<div class="titlebar">
<div class="defname">class? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>symbol</i> is a symbol and its value is a class of resource. 
</div></p>
<p><a id="SWCLOSmetaclass?" name="SWCLOSmetaclass?">
<div class="titlebar">
<div class="defname">metaclass? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>symbol</i> is a symbol and its value is a meta class of resource. 
</div></p>
<p><a id="SWCLOSstrict-class?" name="SWCLOSstrict-class?">
<div class="titlebar">
<div class="defname">strict-class? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>symbol</i> is a symbol and its value is a class but not a metaclass of 
  resource. </div></p>
<p><a id="SWCLOSinstance?" name="SWCLOSinstance?">
<div class="titlebar">
<div class="defname">instance? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a>, 
  if <i>symbol</i> is a symbol and its value is an instance of resource. 
</div></p><br/>
<h3 height="30">5.2 &nbsp;rdf:type and rdfs:subClassOf</h3>
<p><b>Figure 5.1</b> depicts class-instance relations described with rdf:type 
property. Class-subclass relations are described with rdfs:subClassOf property, 
and property-subproperty relations are described with rdfs:subPropertyOf in RDFS 
vocabulary. </p>
<p>To get rdf:type property value of resources, you may use <a 
href="#SWCLOStype-of"><b>gx:type-of</b></a> 
and <a 
href="http://www.franz.com/support/documentation/8.0/ansicl/dictentr/class-of.htm">cl:class-of</a> 
function. Note that <b>gx:type-of</b> is customized type-of function for 
resources instead of cl:type-of so that it brings RDFS semantics, but 
cl:class-of is a native function in CLOS. Therefore, while <b>gx:type-of</b> for 
rdfs:Class returns rdfs:Class in RDFS semantics, cl:class-of for rdfs:Class 
returns actual metaclass object of rdfs:Class in CLOS as shown below. </p>
<blockquote>
<code style="font-size:8pt">gx-user(10): (type-of 
  1)<br/>xsd:byte<br/>gx-user(11): (type-of 
  "1"^^xsd:integer)<br/>xsd:integer<br/>gx-user(14): (type-of 
  rdf:Property)<br/>rdfs:Class<br/>gx-user(15): (class-of 
  rdf:Property)<br/>#&lt;rdfsClass rdfs:Class&gt;<br/>gx-user(16): (type-of 
  rdfs:comment)<br/>rdf:Property<br/>gx-user(17): (class-of 
  rdfs:comment)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(18): (type-of 
  rdfs:Datatype)<br/>rdfs:Class<br/>gx-user(19): (class-of 
  rdfs:Datatype)<br/>#&lt;rdfsClass rdfs:Class&gt;<br/>gx-user(20): (type-of 
  rdfs:Class)<br/>rdfs:Class<br/>gx-user(21): (class-of 
  rdfs:Class)<br/>#&lt;gx::meta-node rdfsClass&gt;<br/></code></blockquote>
<p><a id="SWCLOStype-of" name="SWCLOStype-of">
<div class="titlebar">
<div class="defname">type-of <i>resource</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the name of the class of <i>resource</i>. This function is 
  almost same as cl:type-of, but exactly obeys RDFS semantics. The return value 
  for rdfs:Class object is the name of itself. </div></p>
<p>To get instances of a class, the function <b>collect-direct-instances-of</b> 
retrieves the direct instances of a class, and the function 
<b>collect-all-instances-of</b> collects all instances from the class and its 
subclasses. </p>
<blockquote><code style="font-size:8pt">gx-user(31): (collect-direct-instances-of 
  rdf:List)<br/>(#&lt;rdf:List rdf:nil&gt;)<br/>gx-user(32): 
  (collect-all-instances-of rdfs:Class)<br/>(#&lt;rdfs:Class |rdfs:Resource|&gt; 
  #&lt;rdfs:Class rdf:Alt&gt;<br/>&nbsp;#&lt;rdfs:Class rdf:Seq&gt; 
  #&lt;rdfs:Class rdf:Bag&gt;<br/>&nbsp;#&lt;rdfs:Class 
  rdfs:ContainerMembershipProperty&gt;<br/>&nbsp;#&lt;rdfs:Class rdfs:Literal&gt; 
  #&lt;rdfs:Class rdfs:Container&gt;<br/>&nbsp;#&lt;rdfs:Class 
  gx::shadow-class&gt; #&lt;rdfs:Class rdf:List&gt;<br/>&nbsp;#&lt;rdfs:Class 
  gx::ill-structured-XMLLiteral&gt; ...)</code><br/>
</blockquote>
<p><a id="SWCLOScollect-direct-instances-of" name="SWCLOScollect-direct-instances-of"/>
<div class="titlebar">
<div class="defname">collect-direct-instances-of <i>class</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe"><i>class</i> is a symbol or a class object. This method returns 
  instances that are directly defined to <i>class</i>. Note that this is not 
  affected by literal classes. </div></p>
<p><a id="SWCLOScollect-all-instances-of" name="SWCLOScollect-all-instances-of"/>
<div class="titlebar">
<div class="defname">collect-all-instances-of <i>class</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe"><i>class</i> is a symbol or a class object. This method returns 
  instances that are defined to <i>class</i> and subclasses of <i>class</i>. For 
  OWL classes, this method collects not only direct instances of <i>class</i> 
  and its subclasses but also indirect instances by OWL semantics. 
</div></p>
<p>Note that <b>gx:typep</b> also accepts uris, QName symbols, and literal data 
in different semantics from cl:typep.</p>
<blockquote>
<code style="font-size:8pt">gx-user(7): (typep 
  &lt;http://somewhere/&gt; rdfs:Resource)<br/>t<br/>t<br/>gx-user(8): (typep "This 
  is literal." rdfs:Resource)<br/>t<br/>t<br/>gx-user(9): (typep 1 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(10): (typep "This is literal." 
  rdfs:Literal)<br/>t<br/>t<br/>gx-user(11): (typep 1 
  rdfs:Literal)<br/>t<br/>t<br/></code></blockquote>
<p><a id="SWCLOStypep" name="SWCLOStypep"/>
<div class="titlebar">
<div class="defname">typep <i>resource type</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>resource</i> is a member of <i>type</i> in RDF 
  semantics. </div></p>
<p>The class-subclass relation in RDFS is defined with rdfs:subClassOf property, 
and the relation is similar to the CLOS class-subclass relation. However, 
<b>gx:subtypep</b> is available to test class-subclass relation in RDF 
semantics. Namely, it accepts uris, QName symbols, and data types in different 
way from cl:subtypep. See the followings. </p>
<code style="font-size:8pt">gx-user(35): (subtypep rdf:Alt 
rdfs:Container)<br/>t<br/>t<br/>gx-user(36): (subtypep rdf:Alt 
rdfs:Resource)<br/>t<br/>t<br/>gx-user(37): (subtypep 
&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#Alt&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdfs:Resource)<br/>t<br/>t<br/>gx-user(38): 
(subtypep xsd:integer rdfs:Literal)<br/>t<br/>t<br/>gx-user(39): (subtypep 
xsd:integer rdfs:Resource)<br/>t<br/>t<br/></code>
<p><a id="SWCLOSsubtypep" name="SWCLOSsubtypep"/>
<div class="titlebar">
<div class="defname">subtypep <i>type1 type2</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>type1</i> is a subtype of <i>type2</i> in RDF 
  semantics. </div></p>
<p>The rdfs:subClassOf value of a resource class is retrieved using slot-value 
with slot-name rdfs:subClassOf. </p>
<code style="font-size:8pt">gx-user(40): 
(slot-value rdf:Alt 'rdfs:subClassOf)<br/>#&lt;rdfs:Class 
rdfs:Container&gt;<br/></code>
<br/>
<h3 height="30">5.3 rdfs:subPropertyOf</h3>
<p>The properties, which are instances of rdf:Property, have super-property and 
sub-property notion, although CLOS instances do not have the super-sub relation 
on slots. Therefore, the super-sub notion upon properties is implemented in 
SWCLOS. <b>subproperty-p</b> tests the super-sub relation on property. 
<b>superproperty-of</b> and <b>subproperty-of</b> functions retrieve direct 
super-properties and sub-properties of a parameter. The detail of property is 
explained at <a 
href="#SWCLOSdomainrange">Section 
8</a>. </p>
<code style="font-size:8pt">gx-user(3): (subproperty-p rdfs:isDefinedBy 
rdfs:seeAlso)<br/>t<br/>gx-user(4): (subproperty-of 
rdfs:seeAlso)<br/>(#&lt;rdf:Property rdfs:isDefinedBy&gt;)<br/>gx-user(5): 
(superproperty-of rdfs:isDefinedBy)<br/>(#&lt;rdf:Property 
rdfs:seeAlso&gt;)<br/></code>
<p><a id="SWCLOSsubproperty-p" name="SWCLOSsubproperty-p"/>
<div class="titlebar">
<div class="defname">subproperty-p <i>property1 property2</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true, if <i>property1</i> is an subproperty of 
  <i>property2</i>. Otherwise, cl:nil is returned. </div></p>
<p><a id="SWCLOSsuperproperty-of" name="SWCLOSsuperproperty-of"/>
<div class="titlebar">
<div class="defname">superproperty-of <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns a direct superproperty of <i>property</i>, if exists. 
  Otherwise, cl:nil is returned. </div></p>
<p><a id="SWCLOSsubproperty-of" name="SWCLOSsubproperty-of">
<div class="titlebar">
<div class="defname">subproperty-of <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns a direct subproperty of <i>property</i>, if exists. 
  Otherwise, cl:nil is returned. </div></p>
<h3 height="30">5.4 &nbsp;Properties and Slots </h3>
<p>In RDF, the property is the first-class entity that exists as resource. 
Therefore, the property resource exists as CLOS object, an instance of the class 
rdf:Property, in SWCLOS. </p>
<p>An RDF triple, <i>subject/predicate/object</i> is realized by a subjective 
CLOS object, a slot name, and its slot value in SWCLOS. Therefore, getting an 
<i>object</i> value in a triple in RDF graph is equal to getting a slot value of 
the slot name corresponding to the property name. </p>
<p>Note that the line 2 in the following example just demonstrated rdfs:comment 
resource object as the first-class entity. The line 3 shows the role of property 
as predicate in triples. The line 4 shows the comment value on rdfs:comment. 
Please see the difference and discriminate a property as an resource object and 
a property as predicate or a role of binary relationship.</p>
<blockquote><code style="font-size:8pt">gx-user(2): 
  rdfs:comment<br/>#&lt;rdf:Property rdfs:comment&gt;<br/>gx-user(3): (slot-value 
  rdfs:Resource 'rdfs:comment)<br/>"The class resource, 
  everything."<br/>gx-user(4): (slot-value rdfs:comment 'rdfs:comment)<br/>"A 
  description of the subject resource."</code></blockquote>
<p>However, rdf:type has very special semantics. It specifies the type of 
object, and it is transformed to a class-instance relation in CLOS. Therefore, 
we get rdf:type value in several ways. </p>
<blockquote><code style="font-size:8pt">gx-user(2): (slot-value rdfs:comment 
  'rdf:type)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(3): (class-of 
  rdfs:comment)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(4): (type-of 
  rdfs:comment)<br/>rdf:Property<br/>gx-user(5): (-&gt; rdfs:comment 
  rdf:type)<br/>rdf:Property<br/></code></blockquote>
<p>The function '-&gt;' allows users to traverse over an RDF graph according to 
a given path and return the value (node name or literal) at the arrival 
point.</p>
<code style="font-size:8pt">gx-user(6): (-&gt; rdfs:comment rdf:type 
rdf:type)<br/>rdfs:Class<br/>gx-user(7): (-&gt; rdfs:comment rdf:type rdf:type 
rdfs:comment)<br/>"The class of classes."<br/>gx-user(8): (-&gt; rdfs:comment 
rdf:type rdf:type rdfs:comment rdf:type)<br/>xsd:string<br/></code>
<p><a id="SWCLOS->" name="SWCLOS->">
<div class="titlebar">
<div class="defname">-&gt; <i>node edge1 ... </i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">starting at <i>node</i>, this function traverses over the RDF 
  graph according to the path given as parameters, <i>edge1 ...</i> , and 
  returns the arrival node. In case of multiple paths are possible, this 
  function takes one route encountered at first. If there is no route which 
  coincides with path, cl:nil is returned. If an edge is a list, i.e., a 
  specifier for edge, in which the first is a property name and the second is a 
  type specifier as filter, then a route where the designated type satisfies the 
  edge value as type is chosen. Note that this search has no backtrack. 
</div></p>
<a id=Section5.5 name=Section5.5/>
<h3 height="30">5.5 &nbsp;Adding Resource Objects and Forward Reference</h3>
<p>In CLOS, a class must be defined before making its instance. A CLOS 
programmer cannot add a slot value to an instance object without the slot 
definition upon the class. In contrast, adding a triple, 
<i>subject/predicate/object</i>, is a basic manner in constructing ontology in 
RDF. It implies that SWCLOS must add a slot value without the slot definition in 
the class. Therefore, SWCLOS enabled the piecewise slot addition for objects. 
Furthermore, the capability for forward referencing is required. Namely, SWCLOS 
must be able to accept undefined classes and instances as referent. Fortunately 
we have the principle of monotonicity in Semantic Webs and many entailment rules 
in RDF, RDFS and OWL. SWCLOS exploited the principle of monotonicity and a 
number of entailment rules in order to realize the forward referencing for 
objects. See SWCLOS <a 
href="http://iswc2004.semanticweb.org/demos/32/">paper1</a>, <a 
href="http://www.mel.nist.gov/msid/conferences/SWESE/repository/8owl-vs-OOP.pdf">paper2</a>, 
<a href="http://www-kasm.nii.ac.jp/papers/takeda/06/koide06aswc.pdf">paper3 at 
ASWC2006</a>, and <a 
href="http://portal.acm.org/citation.cfm?id=1562868.1562872">paper4 at 
ELW2009</a> on theoretical details. In this document, we explain the usage of 
this piecewise adding functionality. </p>
<p><b>Figure 5.2</b> illustrates a part of Wine Ontology described in RDFS 
rather than OWL. You may make this RDF graph in a usual manner of CLOS object 
definition, namely in order from abstract classes to special classes and from 
classes to instances. However, SWCLOS allows you to define any object in any 
order with the premise of monotonicity principle. SWCLOS ensures the final 
result shown in Figure 5.2, when all pieces of knowledge are inputted.</p>
<p align="center"><a name="Figure 5.2"/><img alt="RDF Graph in Wine Ontology" 
src="FIGURES/WineRDF.PNG" border="0"/> </p>
<p align="center"><b>Figure 5.2 RDF Graph in Wine Ontology</b></p>
<p>The followings are an example to create the RDF graph shown in Figure 
5.2.</p>
<code style="font-size:8pt">gx-user(2): (defpackage vin)<br/>#&lt;The vin 
package&gt;<br/>gx-user(3): (defIndividual 
vin::ElyseZinfandel<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
vin::Zinfandel)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin::hasMaker 
vin::Elyse))<br/>Warning: Entail by rdf1: vin::hasMaker rdf:type 
rdf:Property.<br/>Warning: Range entail by rdf:type: vin::Zinfandel rdf:type 
rdfs:Class.<br/>#&lt;vin:Zinfandel vin:ElyseZinfandel&gt;<br/>gx-user(4): 
vin:Elyse<br/>#&lt;|rdfs:Resource| vin:Elyse&gt;<br/>gx-user(5): (defIndividual 
vin:Elyse (rdf:type vin::Winery))<br/>Warning: Range entail by rdf:type: 
vin::Winery rdf:type rdfs:Class.<br/>#&lt;vin:Winery vin:Elyse&gt;<br/>gx-user(6): 
(defConcept vin:Zinfandel (rdfs:subClassOf vin::Wine))<br/>Warning: Range 
entailX1 by rdfs:subClassOf: vin::Wine rdf:type rdfs:Class.<br/>#&lt;rdfs:Class 
vin:Zinfandel&gt;<br/>gx-user(7): (slot-value vin:Zinfandel 
'rdfs:subClassOf)<br/>#&lt;rdfs:Class vin:Wine&gt;<br/>gx-user(8): (subtypep 
vin:Zinfandel rdfs:Resource)<br/>t<br/>t<br/></code>
<p>At the beginning of the example above, a lisp package named 'vin' was created 
for Wine Ontology. Then, vin:ElyseZinfandel, whose maker is vin:Elyse, was 
defined. Note that all of 'vin' vocabulary in Wine Ontology are to be interned 
in 'vin' package before reading as QName. Otherwise, when you input a new lisp 
symbol as QName, you must use double colons, because you have no way to make 
exported symbols directly with neither calling export function nor defining them 
at the time of the package definition. Since SWCLOS interprets lisp symbols at 
the position of resources as QName and automatically exports them, then you may 
specify the QName symbols with one colon afterwards.</p>
<p>The macro <a 
href="#SWCLOSdefIndividual">defIndividual</a> 
is used to define an individual or an instance of resource. At line 3, 
vin:Zinfandel, vin:hasMaker, and vin:Elyse are referred to but not defined as 
QName yet. So, SWCLOS reasoned out at least that vin:Zinfandel must be an 
instance of rdfs:Class, vin:hasMaker must be an instance of rdf:Property, and 
vin:Elyse must be an instance of rdfs:Resource using some of entailment rules in 
RDF and RDFS. See Section 9. The line 3 in the above example not only made an 
instance slot for vin:ElyseZinfandel, vin:hasMaker and vin:Elyse, but also 
automatically defined the CLOS slot definition of vin:hasMaker at the class 
vin:Zinfandel.</p>
<p>The line 4 to 5 shows the type of vin:Elyse is changed from rdfs:Resource to 
vin:Winery. Note that vin:Winery is a subclass of rdfs:Resource and shares 
rdfs:Class as its type with rdfs:Resource. The line 6 to 8 demonstrates that 
vin:Wine is added into the rdfs:subClassOf slot of vin:Zinfandel. Exactly, the 
superclass of vin:Zinfandel is refined from rdfs:Resource to vin:Wine, because 
it is directed, and rdfs:Resource as superclass of vin:Zinfandel is involved by 
the transitivity of subsumption through vin:Wine. Thus, the automatic 
redefinition in SWCLOS is possible and knowledge monotonously increases. The 
forward reference involves the entailment through the various entailment rules, 
and the statement of explicit assertion refines the results of earlier 
entailing.</p>
<p><a id="SWCLOSdefIndividual" name="SWCLOSdefIndividual"/>
<div class="titlebar">
<div class="defname">defIndividual <i>name (role1 filler1) ... </i></div>
<div class="deftype">[Macro]</div></div>
<div class="defdescribe"><i>name</i> is a QName symbol or unexported lisp symbol of this 
  individual, and <i>role</i> is a property name (symbol) including rdf:type 
  etc., and <i>filler</i> is a value of the property. This macro generates and 
  evaluates the form like &lsquo;(addForm (:name <i>name</i>) (<i>role1</i> 
  <i>filler1</i>) ... )&rsquo;. If an rdf:type value is not supplied, the most 
  specific concepts of domain restrictions are calculated and used. If there is 
  no rdf:type indication and no domain restrictions, the default value is 
  rdfs:Resource. A <i>filler</i> may be a sub form in <a 
  href="#SWCLOSaddForm"><b>addForm</b></a> 
  calling sequence. See <a 
  href="#SWCLOSaddForm"><b>addForm</b></a> 
  for the syntax detail. </div></p>
  <p><a id="SWCLOSdefConcept" name="SWCLOSdefConcept"/>
<div class="titlebar">
<div class="defname">defConcept <i>name (role1 filler1) ... </i></div>
<div class="deftype">[Macro]</div></div>
<div class="defdescribe">This macro works as same as <b>defIndividual</b> but the default 
  rdf:type value is rdfs:Class. </div></p>
<p><a id="SWCLOSdefProperty" name="SWCLOSdefProperty"/>
<div class="titlebar">
<div class="defname">defProperty <i>name (role1 filler1) ... </i></div>
<div class="deftype">[Macro]</div></div>
<div class="defdescribe">This macro works as same as <b>defIndividual</b> but the default 
  rdf:type value is rdf:Property. </div></p>
<h3 height="30">5.6 &nbsp;Adding Slots </h3>
<p>In class-based Object-Oriented Programming Language like CLOS, slot 
structures in an instance must be defined before making the instance. However, 
in RDF, a property as predicate and its value can be defined at any RDF graph 
node (subject) within the domain restriction on the property. Therefore, it is 
enabled to add any slot (pair of role and filler) to any resource object without 
the explicit slot definition in the class. SWCLOS automatically adds the new 
slot definition in the class on the demand of new slot addition to an 
individual.</p>
<p>There is no special function for users to add new slots into objects in 
SWCLOS. Instead you can add new slots using <b>defIndividual</b> or 
<b>defConcept</b> macro, piecewisely. SWCLOS accepts such piecewise and multiple 
definitions for multiple slots on a resource. After the above example, you can 
add a new slot (vin:hasColor vin:Red) to vin:ElyseZinfandel as 
follows.</p>
<code style="font-size:8pt">gx-user(9): (defIndividual 
vin:ElyseZinfandel (vin::hasColor vin::Red))<br/>Warning: Entail by rdf1: 
vin::hasColor rdf:type rdf:Property.<br/>#&lt;vin:Zinfandel 
vin:ElyseZinfandel&gt;<br/>gx-user(10): (get-form 
vin:ElyseZinfandel)<br/>(|rdfs:Resource| vin:ElyseZinfandel (rdf:type 
vin:Zinfandel)<br/>&nbsp;&nbsp;(vin:hasMaker vin:Elyse) (vin:hasColor 
vin:Red))</code><br/>
<h3 height="30">5.7 &nbsp;Adding Slot Values </h3>
<p>Setting a slot value <font color=red>must show</font> very different 
behaviors in SWCLOS. (setf slot-value) is available but it does 
<strike>not</strike> overwrite an old value. <font color=red>However, a new slot 
value must be added into slot in the semantics of RDF and the principle of 
monotonicity. So, <b>put-value</b> is provided for RDF semantics.</font> It just 
adds a new value into the slot value. Precisely, if both an old value and a new 
value are not a list and different from each other, the result of adding is a 
list of old and new value. If both are a list, the result is a union of both. If 
one of them is not a list, it is added (adjoin) to another value as a set 
element. This is from the monotonicity principle in Semantic Webs.</p>
<code style="font-size:8pt">gx-user(17): (defIndividual MyResource (myProp "original 
one"))<br/>Warning: Entail by rdf1: myProp rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| MyResource&gt;<br/>gx-user(18): (slot-value 
MyResource 'myProp)<br/>"original one"<br/>gx-user(19): (put-value MyResource 
myProp "added 1st")<br/>("added 1st" "original one")<br/>gx-user(20): (put-value 
MyResource myProp "added 2nd")<br/>("added 2nd" "added 1st" "original 
one")<br/>gx-user(21): (slot-value MyResource 'myProp)<br/>("added 2nd" "added 
1st" "original one")<br/></code>
<p>When you add same value that is already stored in the slot, nothing 
happens.</p>
<code face=monospace>gx-user(22): (put-value MyResource myProp 
"added 1st")<br/>("added 2nd" "added 1st" "original one")<br/>gx-user(23): 
(slot-value MyResource 'myProp)<br/>("added 2nd" "added 1st" "original 
one")<br/></code><br/>
<h3 height="30">5.8 &nbsp;Adding Multiple Types </h3>
<p>A CLOS object belongs to only one class. However, an instance in RDF may be a 
member of multiple classes. In order to solve this problem, we set up an 
invisible class that is an instance of metaclass <b>gx::shadowed-class</b>. For 
example, suppose SaucelitoCanyonZinfandel1998 in Wine Ontology is an instance of 
Zinfandel and Vintage, SWCLOS set a shadowed-class named Zinfandel.0 that has 
Zinfandel and Vintage as its superclass.</p>
<code style="font-size:8pt">gx-user(2): 
(defpackage vin)<br/>#&lt;The vin package&gt;<br/>gx-user(3): (defIndividual 
vin::SaucelitoCanyonZinfandel1998<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
vin::Zinfandel)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
vin::Vintage))<br/>Warning: Range entail by rdf:type: vin::Zinfandel rdf:type 
rdfs:Class.<br/>Warning: Range entailX2 by rdf:type: vin::Vintage rdf:type 
rdfs:Class.<br/>Warning: Multiple classing with 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#&lt;rdfs:Class 
vin:Zinfandel&gt; #&lt;rdfs:Class vin:Vintage&gt;) for 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;vin:Zinfandel 
vin:SaucelitoCanyonZinfandel1998&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;vin:Zinfandel.0 
vin:SaucelitoCanyonZinfandel1998&gt;<br/>gx-user(4): (typep 
vin:SaucelitoCanyonZinfandel1998 vin:Zinfandel)<br/>t<br/>t<br/>gx-user(5): (typep 
vin:SaucelitoCanyonZinfandel1998 vin:Vintage)<br/>t<br/>t<br/>gx-user(6): (type-of 
vin:SaucelitoCanyonZinfandel1998)<br/>(vin:Vintage 
vin:Zinfandel)</code><br/>
<h3 height="30">5.9 &nbsp;Extension of property and slot definition </h3>
<p>A set of all triples whose predicate is a specific property is called the <a 
href="http://www.w3.org/TR/rdf-mt#defexten"><i>extension</i> of the property in 
RDF</a>. A slot in an instance of CLOS is captured as one element of the 
extension of a property of slot name. In CLOS, we have the slot-definition 
objects that are allocated for a class metaobject and shared by its instances. A 
slot definition object in a class holds a slot-name and a type constraint for 
the slot value. SWCLOS also keeps the subject information on the property 
extension in the slot-definition objects. Furthermore, every slot definition 
object for a RDF entity is linked to by a property resource object. Function 
<b>collect-all-extensions-of</b> collects all elements in the extension of a 
property and lists up them.</p>
<code style="font-size:8pt">gx-user(53): 
rdfs:comment<br/>#&lt;rdf:Property rdfs:comment&gt;<br/>gx-user(54): (find 
'rdfs:comment (mop:class-slots 
rdfs:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:key 
#'name)<br/>#&lt;gx::Property-effective-slot-definition rdfs:comment @ 
#x20a9520a&gt;<br/>gx-user(55): 
(cl:typep<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(find 
'rdfs:comment (mop:class-slots 
rdfs:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;:key 
#'name)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'mop:slot-definition)<br/>t<br/>gx-user(56): 
(collect-all-extensions-of rdfs:comment)<br/>((#&lt;rdfsClass rdfs:Class&gt; "The 
class of classes.")<br/>&nbsp;(#&lt;rdfs:Class rdfs:Resource&gt; "The class 
resource, everything.")<br/>&nbsp;(#&lt;rdfs:Class rdf:Property&gt; "The class of 
RDF properties.")<br/>&nbsp;(#&lt;rdfs:Class rdf:Statement&gt; "The class of RDF 
statements.")<br/>&nbsp;(#&lt;rdfs:Class rdfs:Datatype&gt; "The class of RDF 
datatypes.")<br/>&nbsp;(#&lt;rdfs:Class rdf:List&gt; "The class of RDF 
Lists.")<br/>&nbsp;(#&lt;rdfs:Class rdfs:Container&gt; "The class of RDF 
containers.")<br/>&nbsp;(#&lt;rdfs:Class 
rdfs:ContainerMembershipProperty&gt;<br/>&nbsp;&nbsp;"The class of container 
membership properties, rdf:_1, rdf:_2, ...,<br/>&nbsp;&nbsp;all of which are 
sub-properties of 'member'.")<br/>&nbsp;(#&lt;rdfs:Class rdf:Bag&gt; "The class 
of unordered containers.")<br/>&nbsp;(#&lt;rdfs:Class rdf:Seq&gt; "The class of 
ordered containers.") ...)<br/></code>
<p><a id="SWCLOS(collect-all-extensions-of" name="SWCLOS(collect-all-extensions-of"/>
<div class="titlebar">
<div class="defname">collect-all-extensions-of <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">collects an element of the extension of <i>property</i> and 
  returns a list of role and filler pairs. </div></p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>6. &nbsp;String, Number, Datatype, and Lang<a id="SWCLOSdatatype" name="SWCLOSdatatype"/></h2>
<h3 height="30">6.1 &nbsp;Literal</h3>
<p>The string and number that appear in RDF are called <i>literal</i>. Every 
literal in RDF is an instance of rdfs:Literal. The class rdf:XMLLiteral is a 
subclass of rdfs:Literal and a class of all XML Schema data, which includes 
xsd:string and xsd:decimal and so on. It implies that every XML Schema data is 
also an instance of rdfs:Literal, and every literal is also an instance of 
rdfs:Resource, because rdfs:Literal is a subclass of rdfs:Resource. </p>
<code style="font-size:8pt">gx-user(11): (subtypep xsd:string 
rdfs:Literal)<br/>t<br/>t<br/>gx-user(12): (typep "this is a string." 
rdfs:Literal)<br/>t<br/>t<br/>gx-user(13): (typep "this is an XML string."@en 
rdf:XMLLiteral)<br/>t<br/>t<br/>gx-user(14): (typep 1.23 
rdfs:Literal)<br/>t<br/>t<br/>gx-user(15): (typep 1.23 
xsd:float)<br/>t<br/>t<br/>gx-user(16): (typep 1.23 
rdfs:Literal)<br/>t<br/>t<br/>gx-user(17): (typep "1.23"^^xsd:float 
xsd:float)<br/>t<br/>t<br/>gx-user(18): (typep "1.23"^^xsd:float 
rdfs:Literal)<br/>t<br/>t<br/>gx-user(19): (typep "this is a string." 
rdfs:Resource)<br/>t<br/>t<br/>gx-user(20): (typep 1.23 
rdfs:Resource)<br/>t<br/>t<br/></code>
<p>Note that <b>gx:typep</b> and <b>gx:subtypep</b> are used in the above 
demonstration. SWCLOS can accept language-taged string as shown in line number 
13, and xsd-typed data notation as shown in line number 17 and 18 through 
special reader macro rdf::read-string for succeeding character '@' and double 
characters '^^' after a string, respectively, instead of Common Lisp original 
reader macro for string. In read-eval-print loop (REPL) of lisp, a lexical token 
of string is read, the evaluation immediately returns the string object, if it 
is a plane string, then it is printed by lisp system as string so that the same 
character sequence as input is printed. As well as plane string, a 
language-taged string is read in SWCLOS's REPL. Then, the reader macro makes a 
form that creates an instance of <b>rdf:inLang</b> structure and hands it to the 
eval function in REPL. So, the lisp system returns an instance of 
<b>rdf:inLang</b> structure. Similarly, for a string with xsd-type,</p>
<blockquote><code style="font-size:8pt">gx-user(8): (quote "This is a 
  test."@en)<br/>(@ "This is a test." "en")<br/>gx-user(9): (eval '"This is a 
  test."@en)<br/>"This is a test."@en<br/>gx-user(10): "This is a 
  test."@en<br/>"This is a test."@en<br/>gx-user(11): (quote 
  "1.23"^^xsd:float)<br/>(^^ "1.23" xsd:float)<br/>gx-user(12): (eval 
  '"1.23"^^xsd:float)<br/>"1.23"^^xsd:float<br/>gx-user(13): 
  "1.23"^^xsd:float<br/>"1.23"^^xsd:float<br/></code></blockquote>
<p>Method <b>value-of</b> allows users to get mapped value in lisp.
</p>
<code style="font-size:8pt">gx-user(15): (value-of 
  "1.23"^^xsd:float)<br/>1.23<br/></code>
<p><a id="SWCLOS@" name="SWCLOS@"/>
<div class="titlebar">
<div class="defname">@ <i>content lang</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">makes an instance of <b>rdf:inLang</b> and returns it. 
  <i>content</i> must be a string. <i>lang</i> may be a string, or a symbol. 
</div></p>
<p><a id="SWCLOS^^" name="SWCLOS^^"/>
<div class="titlebar">
<div class="defname">^^ <i>value type</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">creates an instance of XML data type <i>type</i> with <i>value</i> 
  and returns it. <i>value</i> is a string or a lisp data that conforms to 
  <i>type</i>. <i>type</i> may be an CLOS object or a symbol. </div></p>
<p><a id="SWCLOSvalue-of" name="SWCLOSvalue-of"/>
<div class="titlebar">
<div class="defname">value-of <i>datum</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">When <i>datum</i> is an instance of rdf:XMLLiteral, this method 
  returns the value of <i>datum</i>. </div></p>
<h3 height="30">6.2 &nbsp;XSD Datatypes in SWCLOS</h3>
<p>In RDF semantics, <a href="http://www.w3.org/TR/rdf-mt/#XSDtable">specific 
ones out of built-in datatypes in XML Schema</a> are introduced in RDF. In 
SWCLOS, further limited numbers of datatypes out of datatypes in RDF are defined 
as lisp datatypes as follows. </p>
<table cellpadding="5" summary="This table lists xsd types in lisp." border="1" rules="all">
  <tbody>
  <tr>
    <th>Lisp Type</th>
    <th>Definition in Lisp</th>
    <th>Ex. in S-expression</th></tr>
  <tr>
    <td valign="middle">xsd:unsignedByte</td>
    <td valign="middle">(cl:unsigned-byte 8)</td>
    <td valign="middle">255</td></tr>
  <tr>
    <td valign="middle">xsd:unsignedShort</td>
    <td valign="middle">(cl:unsigned-byte 16)</td>
    <td valign="middle">65535</td></tr>
  <tr>
    <td valign="middle">xsd:unsignedInt</td>
    <td valign="middle">(cl:unsigned-byte 32)</td>
    <td valign="middle">4294967295</td></tr>
  <tr>
    <td valign="middle">xsd:unsignedLong</td>
    <td valign="middle">(cl:unsigned-byte 64)</td>
    <td valign="middle">18446744073709551615</td></tr>
  <tr>
    <td valign="middle">xsd:nonNegativeInteger</td>
    <td valign="middle">cl:unsigned-byte</td>
    <td valign="middle">0</td></tr>
  <tr>
    <td valign="middle">xsd:byte</td>
    <td valign="middle">(cl:signed-byte 8)</td>
    <td valign="middle">127</td></tr>
  <tr>
    <td valign="middle">xsd:short</td>
    <td valign="middle">(cl:signed-byte 16)</td>
    <td valign="middle">32767</td></tr>
  <tr>
    <td valign="middle">xsd:int</td>
    <td valign="middle">(cl:signed-byte 32)</td>
    <td valign="middle">2147483647</td></tr>
  <tr>
    <td valign="middle">xsd:long</td>
    <td valign="middle">(cl:signed-byte 64)</td>
    <td valign="middle">9223372036854775807</td></tr>
  <tr>
    <td valign="middle">xsd:integer</td>
    <td valign="middle">cl:integer</td>
    <td valign="middle">1234567890</td></tr>
  <tr>
    <td valign="middle">xsd:positiveInteger</td>
    <td valign="middle">(cl:integer 1 *)</td>
    <td valign="middle">1</td></tr>
  <tr>
    <td valign="middle">xsd:nonPositiveInteger</td>
    <td valign="middle">(cl:integer * 0)</td>
    <td valign="middle">0</td></tr>
  <tr>
    <td valign="middle">xsd:negativeInteger</td>
    <td valign="middle">(cl:integer cl:* -1)</td>
    <td valign="middle">-1</td></tr>
  <tr>
    <td valign="middle">xsd:float</td>
    <td valign="middle">cl:single-float</td>
    <td valign="middle">1.0</td></tr>
  <tr>
    <td valign="middle">xsd:double</td>
    <td valign="middle">cl:double-float</td>
    <td valign="middle">1.0d0</td></tr>
  <tr>
    <td valign="middle">xsd:decimal</td>
    <td valign="middle">cl:rational</td>
    <td valign="middle">(rational 1.0)</td></tr>
  <tr>
    <td valign="middle">xsd:string</td>
    <td valign="middle">cl:string</td>
    <td valign="middle">"string?"</td></tr>
  <tr>
    <td valign="middle">xsd:boolean</td>
    <td valign="middle">(cl:member xsd:true xsd:false)</td>
    <td valign="middle">xsd:false</td></tr>
  <tr>
    <td valign="middle">xsd:anyURI</td>
    <td valign="middle">net.uri:uri</td>
    <td valign="middle">(uri "http://somewhere/")</td></tr>
  <tr>
    <td valign="middle">xsd:anySimpleType</td>
    <td valign="middle">(or xsd:boolean xsd:anyURI xsd:string xsd:float 
      xsd:double xsd:decimal)</td>
    <td valign="middle">"simple-type?"</td></tr></tbody></table>
<p>Therefore, you may check a lisp datum in S-expression against the xsd types 
defined as lisp type as follows.</p>
<blockquote><code style="font-size:8pt">gx-user(7): (cl:typep 1 
  'xsd:positiveInteger)<br/>t<br/>gx-user(8): (cl:typep 1 
  'xsd:nonNegativeInteger)<br/>t<br/>gx-user(9): (cl:typep 1 
  'xsd:integer)<br/>t<br/>gx-user(10): (cl:typep 1 'xsd:int)<br/>t<br/>gx-user(11): 
  (cl:typep 1 'xsd:decimal)<br/>t<br/>gx-user(12): (cl:typep 1 
  'xsd:unsignedByte)<br/>t<br/>gx-user(13): (cl:typep 1 
  'xsd:anySimpleType)<br/>t<br/></code></blockquote>
<p>Moreover, each xsd type in lisp has an RDF datatype object as symbol value of 
the datatype, and <b>gx:typep</b> interprets a datum in lisp not only as lisp 
datatype but also as RDF datatype, if it is a plane literal (non-typed-literal) 
or a lisp datum. </p>
<blockquote><code style="font-size:8pt">gx-user(14): 
  xsd:positiveInteger<br/>#&lt;rdfs:Datatype 
  xsd:positiveInteger&gt;<br/>gx-user(15): xsd:integer<br/>#&lt;rdfs:Datatype 
  xsd:integer&gt;<br/>gx-user(16): (typep 1 
  xsd:positiveInteger)<br/>t<br/>t<br/>gx-user(17): (typep 1 
  xsd:nonNegativeInteger)<br/>t<br/>t<br/>gx-user(18): (typep 1 
  xsd:integer)<br/>t<br/>t<br/>gx-user(19): (typep 1 
  xsd:int)<br/>t<br/>t<br/>gx-user(20): (typep 1 
  xsd:decimal)<br/>t<br/>t<br/>gx-user(21): (typep 1 
  xsd:unsignedByte)<br/>t<br/>t<br/>gx-user(22): (typep 1 
  xsd:anySimpleType)<br/>t<br/></code></blockquote>
<p>On the other hand, a typed literal in RDF is mapped to an instance of RDF 
data type class in SWCLOS, and each typed-data instance is also interpreted by 
<b>gx:typep</b> as follows.</p>
<blockquote><code style="font-size:8pt">gx-user(8): (typep "1"^^xsd:integer 
  xsd:integer)<br/>t<br/>t<br/>gx-user(9): (typep "1"^^xsd:integer 
  xsd:positiveInteger)<br/>nil<br/>t<br/>gx-user(10): (typep 
  "1"^^xsd:positiveInteger xsd:integer)<br/>t<br/>t<br/>gx-user(11): (typep 
  "1"^^xsd:positiveInteger xsd:positiveInteger)<br/>t<br/>t<br/></code></blockquote>
<p>Note that xsd:integer subsumes xsd:positiveInteger, so that 
"1"^^positiveInteger is an instance of xsd:positiveInteger and xsd:integer, too, 
but "1"^^integer is not an instance of xsd:positiveInteger, although the values 
of both in the value space are equal.</p>
<p>Every datatype is an instance of rdfs:Datatype. Note that rdf:XMLLiteral and 
xsd:integer, etc. are a class. So, rdfs:Datatype is a metaclass. </p>
<blockquote><code style="font-size:8pt">gx-user(21): (typep xsd:integer 
  rdfs:Datatype)<br/>t<br/>t<br/>gx-user(22): (typep rdf:XMLLiteral 
  rdfs:Datatype)<br/>t<br/>t<br/>gx-user(23): (strict-class-p 
  xsd:integer)<br/>t<br/>gx-user(24): (rdf-metaclass-p 
  rdfs:Datatype)<br/>t<br/></code></blockquote>
<p>Function <b>datatype?</b> checks whether it is an XSD datatype or not for a 
symbol parameter, and <b>datatype-p</b> checks for a datatype object (an 
instance of rdfs:Datatype).</p>
<blockquote><code style="font-size:8pt">gx-user(31): (datatype? 
  'xsd:integer)<br/>t<br/>gx-user(32): (datatype-p 
xsd:integer)<br/>t<br/></code></blockquote>
<p><a id="SWCLOSdatatype?" name="SWCLOSdatatype?"/>
<div class="titlebar">
<div class="defname">datatype? <i>symbol</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This predicate returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a> 
  if <i>symbol</i> is bound, and the symbol-value is an instance of 
  rdfs:Datatype. </div></p>
<p><a id="SWCLOSdatatype-p" name="SWCLOSdatatype-p"/>
<div class="titlebar">
<div class="defname">datatype-p <i>x</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This predicate returns <a 
  href="http://www.franz.com/support/documentation/8.0/ansicl/glossary/t.htm#true">true</a> 
  if <i>x</i> an instance of rdfs:Datatype. </div></p>
<h3 height="30">6.3 &nbsp;xml:lang in SWCLOS</h3>
<p>The <a 
href="http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/#section-Syntax-languages">xml:lang</a> 
attribute in RDF syntax can be used on any node element or property element in 
RDF/XML syntax to indicate that the included content is in the given language. 
See the following example, which is taken from W3C <a 
href="http://www.w3.org/TR/rdf-syntax-grammar/#section-Syntax-languages">RDF/XML 
Syntax Specification (Revised)</a>. </p>
<p class="box"><code style="font-size:8pt">&lt;?xml version="1.0" 
encoding="utf-8"?&gt;<br/>&lt;rdf:RDF 
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;<br/>&nbsp;&nbsp;&lt;rdf:Description 
rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:title&gt;RDF/XML 
Syntax Specification 
(Revised)&lt;/dc:title&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:title 
xml:lang="en"&gt;RDF/XML Syntax Specification 
(Revised)&lt;/dc:title&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:title 
xml:lang="en-US"&gt;RDF/XML Syntax Specification 
(Revised)&lt;/dc:title&gt;<br/>&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/><br/>&nbsp;&nbsp;&lt;rdf:Description 
rdf:about="http://example.org/buecher/baum" 
xml:lang="de"&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:title&gt;Der 
Baum&lt;/dc:title&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:description&gt;Das Buch ist 
au&szlig;ergew&ouml;hnlich&lt;/dc:description&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;dc:title 
xml:lang="en"&gt;The 
Tree&lt;/dc:title&gt;<br/>&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/>&lt;/rdf:RDF&gt;<br/></code></p>
<p>In reading RDF/XML forms, the xml:lang attribute on node elements is parsed 
as it is an attribute. The xml:lang attribute on property element is transformed 
as if it envelopes the role value as sub-role. Therefore, the above RDF/XML 
forms are interpreted and transformed to the following S-expressions. </p>
<p class="box"><code style="font-size:8pt">(rdf:Description (rdf:about &lt;uri 
http://www.w3.org/TR/rdf-syntax-grammar&gt;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:title 
"RDF/XML Syntax Specification 
(Revised)")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:title 
(:en "RDF/XML Syntax Specification 
(Revised)"))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:title 
(:en-us "RDF/XML Syntax Specification (Revised)")))<br/>(rdf:Description 
(rdf:about &lt;uri 
http://example.org/buecher/baum&gt;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(xml:lang 
:de)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:title 
"Der 
Baum")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:description 
"Das Buch ist 
au&szlig;ergew&ouml;hnlich")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(dc:title 
(:en "The Tree")))<br/></code></p>
<p>SWCLOS keeps and maintains the language environment according to the order 
and the nest structure of RDF/XML language designation. Therefore, at the second 
rdf:Description form in the above example, the German environment is set up at 
the language tag ':de' at first, then the English environment is established in 
the German environment at the ':en' envelope. As a result, We obtain the 
followings. </p>
<code style="font-size:8pt">gx-user(9): (read-rdf-file #'addRdfXml 
"example08.rdf")<br/>Warning: Entail by rdf1: dc:title rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: dc:description rdf:type 
rdf:Property.<br/>:done<br/>gx-user(10): (slot-value 
&lt;&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt;&gt; 'dc:title)<br/>("RDF/XML 
Syntax Specification (Revised)"<br/>"RDF/XML Syntax Specification 
(Revised)"@en<br/>"RDF/XML Syntax Specification (Revised)"@en-US)<br/>gx-user(11): 
(slot-value &lt;&lt;http://example.org/buecher/baum&gt;&gt; 'dc:title)<br/>("Der 
Baum"@de "The Tree"@en)<br/>gx-user(12): (slot-value 
&lt;&lt;http://example.org/buecher/baum&gt;&gt; 'dc:description)<br/>"Das Buch 
ist au&szlig;ergew&ouml;hnlich"@de<br/></code>
<p>Where such an expression as <code style="font-size:8pt">"Der Baum"@de</code> and 
<code style="font-size:8pt">"The Tree"@en</code> is an instance of <b>rdf:inLang</b> structure, 
which is printed as it looks like a lexcal form of plain literal with language 
option. See <a 
href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO 639-1 alpha-2 
language code</a> about the optional lang code.</p>
<p><a id="SWCLOSinLang" name="SWCLOSinLang"/>
<div class="titlebar">
<div class="defname">rdf:inLang</div>
<div class="deftype">[Structure]</div></div>
<div class="defdescribe">A structure for plain literal with language option. The instance 
  has two values for lang slot and content slot. Lisp prints this object like 
  plain literal with option, <b><i>content</i>@<i>lang</i></b>. 
</div></p>
<p><a id="SWCLOSlang?" name="SWCLOSlang?"/>
<div class="titlebar">
<div class="defname">lang? <i>x</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>x</i> is the keyword symbol that matches one of 
  the <a href="http://www.loc.gov/standards/iso639-2/php/code_list.php">ISO 
  639-1 alpha-2 language code</a>. </div></p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>7. &nbsp;RDF Collection</h2>
<h3 height="30">7.1 &nbsp;RDF Container</h3>
<p>To represent collections of resources, RDF provides three ways as subclass of 
rdfs:Container. </p>
<ul>
  <li>rdf:Bag is a collection type without ordering elements. </li>
  <li>rdf:Alt is a collection type without ordering elements. The first of 
  elements is to be selected alternatively among them. </li>
  <li>rdf:Seq is a collection type with ordering elements. </li></ul>
<p>The first member of container is the value of the property rdf:_1, the second 
member is the value of the property rdf:_2, and so on. This kind of property, 
rdf:_<i>nnn</i>, is called an <i>ordinal property</i>.</p>
<p><b>Figure 7.1</b> is an example of a collection of rdf:Bag, which is taken 
from Jena tutorial.</p>
<p align="center"><a id="figure7.1" name="figure7.1"><img alt="An Example of rdfs:Bag" 
src="FIGURES/BagEx.PNG" border="0"/> </a></p>
<p align="center"><b>Figure 7.1 An Example of rdfs:Bag (from Jena 
Tutorial) </b></p>
<p>Then, the followings encode Figure 7.1.</p><code style="font-size:8pt">gx-user(3): (defpackage somewhere)<br/>#&lt;The somewhere 
package&gt;<br/>gx-user(4): (defpackage vCard)<br/>#&lt;The vCard 
package&gt;<br/>gx-user(5): (defIndividual 
somewhere::JohnSmith<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://somewhere/JohnSmith")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard::FN 
"John 
Smith")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard::N 
(rdfs:Resource (vCard::Given 
"John")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard::Family 
"Smith"))))<br/>Warning: Entail by rdf1: vCard::FN rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: vCard::N rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: vCard::Given rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: vCard::Family rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| somewhere:JohnSmith&gt;<br/>gx-user(6): 
(defIndividual 
somewhere::BeckySmith<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://somewhere/BeckySmith")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard:FN 
"Becky 
Smith")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard:N 
(rdfs:Resource (vCard:Given 
"Becky")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vCard:Family 
"Smith"))))<br/>#&lt;|rdfs:Resource| somewhere:BeckySmith&gt;<br/>gx-user(7): 
(defIndividual _:bag01 (rdf:type 
rdf:Bag)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf::_1 
somewhere:BeckySmith)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf::_2 
somewhere:JohnSmith))<br/>Warning: Entail by rdf1: rdf:_1 rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: rdf:_2 rdf:type 
rdf:Property.<br/>#&lt;rdf:Bag :anonymous&gt;<br/>gx-user(8): (get-form 
_:bag01)<br/>(rdf:Bag (rdf:type rdf:Bag)<br/>&nbsp;&nbsp;(rdf:_1 
somewhere:BeckySmith) (rdf:_2 somewhere:JohnSmith))<br/></code><br/>
<p>In SWCLOS, ordinal properties are initially not defined. However, if you put 
them in proper position, it is automatically defined as an instance of 
rdfs:ContainerMembershipProperty.</p>
<p>In Figure 7.1, the top node is a blank node, then we put it a blank node 
identifier _:bag01. Note that a blank node object is bound to a designated blank 
node ID. In SWCLOS, a node name is not mandatory even if in the top level node, 
but it is preferable to put a node identifier for convenience.</p>
<h3 height="30">7.2 &nbsp;List</h3>
<p>In RDF semantics, we can make an instance of rdf:List with rdf:first, 
rdf:rest and rdf:nil. <b>Figure 7.2</b> shows an example of list structure in 
RDF, which is from <a href="http://www.w3.org/TR/rdf-primer#figure16">RDF 
Primer</a>.</p>
<p align="center"><img alt="An RDF Collection (list structure)" 
src="FIGURES/ListStructure.png" border="0"/> </p>
<p align="center"><b>Figure 7.2 An RDF Collection (list structure) 
(from <a href="http://www.w3.org/TR/rdf-primer#figure16">RDF Primer</a>)</b></p>
<p>This RDF graph is encoded as follows straightforwardly.</p><code style="font-size:8pt">gx-user(2): (defpackage eg (:documentation 
"http://example.org/"))<br/>#&lt;The eg package&gt;<br/>gx-user(3): (defpackage 
vocab<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(:documentation 
"http://example.org/students/vocab/"))<br/>#&lt;The vocab 
package&gt;<br/>gx-user(4): (defIndividual 
eg::courses/6.001<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/courses/6.001")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vocab::students<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:List 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Amy")))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:rest<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:List 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Mohamed")))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:rest<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:List 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Johann")))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:rest 
rdf:nil))))))))<br/>Warning: Entail by rdf1: vocab::students rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| eg:courses/6.001&gt;<br/>gx-user(5): 
(pprint (get-form eg:courses/6.001))<br/><br/>(|rdfs:Resource| 
eg:courses/6.001<br/>&nbsp;(rdf:about 
&lt;http://example.org/courses/6.001&gt;)<br/>&nbsp;(vocab:students<br/>&nbsp;&nbsp;(rdf:List<br/>&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource 
(rdf:about 
&lt;http://example.org/students/Amy&gt;)))<br/>&nbsp;&nbsp;&nbsp;(rdf:rest<br/>&nbsp;&nbsp;&nbsp;&nbsp;(rdf:List<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource 
(rdf:about 
&lt;http://example.org/students/Mohamed&gt;)))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:rest<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:List<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:first<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource 
(rdf:about 
&lt;http://example.org/students/Johann&gt;)))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:rest 
rdf:nil))))))))<br/></code><br/>
<p>You can get any data in list using path traverse function '-&gt;' as 
follows.</p><code style="font-size:8pt">gx-user(6): (get-form (-&gt; 
eg:courses/6.001 vocab:students rdf:rest 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rdf:rest 
rdf:first))<br/>(rdfs:Resource (rdf:about 
&lt;http://example.org/students/Johann&gt;))<br/>gx-user(7): (-&gt; 
eg:courses/6.001 vocab:students rdf:rest rdf:rest rdf:rest)<br/>#&lt;rdf:List 
rdf:nil&gt;<br/></code><br/>
<p>However, using rdf:List is very tedious in SWCLOS. We can use the lisp list 
to represent a collection of resources in SWCLOS. You may represent the 
collection of students as follows, whereas the RDF graph is not equal to Figure 
7.2. </p><code style="font-size:8pt">gx-user(7): (defIndividual 
eg::courses/6.002<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/courses/6.002")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vocab::students<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Amy"))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Mohamed"))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:Resource<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:about 
"http://example.org/students/Johann"))))<br/>#&lt;|rdfs:Resource| 
eg:courses/6.002&gt;<br/>gx-user(8): (get-form 
eg:courses/6.002)<br/>(|rdfs:Resource| eg:courses/6.002<br/>&nbsp;(rdf:about 
&lt;http://example.org/courses/6.002&gt;)<br/>&nbsp;(vocab:students<br/>&nbsp;&nbsp;(rdfs:Resource 
(rdf:about 
&lt;http://example.org/students/Amy&gt;))<br/>&nbsp;&nbsp;(rdfs:Resource 
(rdf:about 
&lt;http://example.org/students/Mohamed&gt;))<br/>&nbsp;&nbsp;(rdfs:Resource 
(rdf:about &lt;http://example.org/students/Johann&gt;))))<br/>gx-user(9): (-&gt; 
eg:courses/6.002 vocab:students)<br/>(#&lt;rdfs:Resource :anonymous&gt; 
#&lt;rdfs:Resource :anonymous&gt; &nbsp;#&lt;rdfs:Resource 
:anonymous&gt;)<br/>gx-user(10): (mapcar #'get-form *)<br/>((rdfs:Resource 
(rdf:about &lt;http://example.org/students/Amy&gt;))<br/>&nbsp;(rdfs:Resource 
(rdf:about &lt;http://example.org/students/Mohamed&gt;))<br/>&nbsp;(rdfs:Resource 
(rdf:about &lt;http://example.org/students/Johann&gt;)))<br/></code><br/>
<p>Even though this input form does not contain rdf:first and rdf:rest, it is 
very easy for lisp programmers to imagine the above forms from the list 
structure in Figure 7.2. </p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>8. &nbsp;Domain and Range<a id="SWCLOSdomainrange" name="SWCLOSdomainrange"/></h2>
<h3 height="30">8.1 &nbsp;Adding Domain and Range Constraints</h3>
<p>Each property in RDF may have its own attributes about the domain and the 
range. The domain value restricts the class of subject in triple of the 
extension of the property and the range value restricts the range of the 
property value. See <a 
href="#Figure 5.2">Figure 
5.2</a>. </p>
<p>To define a domain and a range of a property, use <a 
href="#SWCLOSdefProperty"><b>defProperty</b></a> 
as follows.</p><code style="font-size:8pt">gx-user(3): (defpackage vin)<br/>#&lt;The 
vin package&gt;<br/>gx-user(4): (defProperty 
vin::hasMaker<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
vin::Wine)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
vin::Winery))<br/>Warning: Range entailX3 by rdfs:domain: vin::Wine rdf:type 
rdfs:Class.<br/>Warning: Range entailX3 by rdfs:range: vin::Winery rdf:type 
rdfs:Class.<br/>#&lt;rdf:Property vin:hasMaker&gt;<br/></code>
<p>The defined domain and range value of property is retrieved by the accessor 
<b>rdfs:domain</b> and <b>rdfs:range</b>. </p>
<blockquote><code style="font-size:8pt">gx-user(6): (rdfs:domain 
  vin:hasMaker)<br/>#&lt;rdfs:Class vin:Wine&gt;<br/>gx-user(7): (rdfs:range 
  vin:hasMaker)<br/>#&lt;rdfs:Class vin:Winery&gt;<br/>gx-user(8): (rdfs:domain 
  rdfs:comment)<br/>#&lt;rdfs:Class rdfs:Resource&gt;<br/>gx-user(9): (rdfs:range 
  rdfs:comment)<br/>#&lt;rdfs:Class rdfs:Literal&gt;<br/></code></blockquote>
<p>These accessor signals an error, if a property has no definition.</p><code style="font-size:8pt">gx-user(10): (defProperty 
vin::hasColor<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
vin::WineColor))<br/>Warning: Range entailX3 by rdfs:range: vin::WineColor 
rdf:type rdfs:Class.<br/>#&lt;rdf:Property vin:hasColor&gt;<br/>gx-user(11): 
(rdfs:range vin:hasColor)<br/>#&lt;rdfs:Class vin:WineColor&gt;<br/>gx-user(12): 
(rdfs:domain vin:hasColor)<br/>Error: The slot rdfs:domain is unbound in the 
object<br/>#&lt;rdf:Property vin:hasColor&gt; of class #&lt;rdfs:Class 
rdf:Property&gt;.<br/>[condition type: unbound-slot]<br/></code>
<p>You may use function <b>range-value</b> and <b>domain-value</b> without 
signaling an error, even if a property has no definition on domain or range 
value.</p>
<blockquote><code style="font-size:8pt">gx-user(13): (range-value 
  vin:hasColor)<br/>#&lt;rdfs:Class vin:WineColor&gt;<br/>gx-user(14): 
  (domain-value vin:hasColor)<br/>nil<br/></code></blockquote>
<p><a id="SWCLOSrdfs:domain" name="SWCLOSrdfs:domain"/>
<div class="titlebar">
<div class="defname">rdfs:domain <i>property</i></div>
<div class="deftype">[Accessor]</div></div>
<div class="defdescribe">provides an access method for the domain value of <i>property</i>. 
  This method signals an error, if the value is unbound. </div></p>
<p><a id="SWCLOSrdfs:range" name="SWCLOSrdfs:range"/>
<div class="titlebar">
<div class="defname">rdfs:range <i>property</i></div>
<div class="deftype">[Accessor]</div></div>
<div class="defdescribe">provides an access method for the range value of <i>property</i>. 
  This method signals an error, if the value is unbound. </div></p>
<p><a id="SWCLOSdomain-value" name="SWCLOSdomain-value"/>
<div class="titlebar">
<div class="defname">domain-value <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the domain value of <i>property</i>. This function returns 
  cl:nil, if the value is unbound. </div></p>
<p><a id="SWCLOSrange-value" name="SWCLOSrange-value"/>
<div class="titlebar">
<div class="defname">range-value <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the range value of <i>property</i>. This function returns 
  cl:nil, if the value is unbound. </div></p>
<p>The domain and range value is inherited from the super-properties defined 
through rdfs:subPropertyOf. In the following example, function <b>get-domain</b> 
accesses and retrieves the domain value of superproperties of vin:hasColor. 
</p><code style="font-size:8pt">gx-user(19): (defProperty 
vin::hasColor<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:subPropertyOf 
vin::hasWineDescriptor))<br/>Warning: Range entailX3 by rdfs:subPropertyOf: 
vin::hasWineDescriptor rdf:type rdf:Property.<br/>#&lt;rdf:Property 
vin:hasColor&gt;<br/>gx-user(20): (get-domain 
vin:hasColor)<br/>nil<br/>gx-user(21): (defProperty 
vin:hasWineDescriptor<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
vin:Wine))<br/>#&lt;rdf:Property vin:hasWineDescriptor&gt;<br/>gx-user(22): 
(get-domain vin:hasColor)<br/>#&lt;rdfs:Class vin:Wine&gt;<br/><br/></code>
<p><a id="SWCLOSget-domain" name="SWCLOSget-domain"/>
<div class="titlebar">
<div class="defname">get-domain <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function searches domains that are directly defined and 
  inherited from its super properties and returns the most specific domain 
  values. So, the return value may be a single value or a list of values. This 
  function returns cl:nil if any defined domain is not found after the 
  exhaustive search. However, note that cl:nil for domain value means 
  rdfs:Resource in fact by RDFS semantics. If a disjoint pair of values found, 
  <b>domain-condition-unsatiafiable</b> error is signaled. </div></p>
<p><a id="SWCLOScollect-domains" name="SWCLOScollect-domains"/>
<div class="titlebar">
<div class="defname">collect-domains <i>properties</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">collects domains from each of <i>properties</i> using 
  <b>get-domain</b>. A property must be a symbol. </div></p>
<p><a id="SWCLOSdomainp" name="SWCLOSdomainp"/>
<div class="titlebar">
<div class="defname">domainp <i>property</i> <i>domain</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>property</i>'s domain is a subclass of 
  <i>domain</i>, or if some of <i>property</i>'s super-properties has a subclass 
  of <i>domain</i>. </div></p>
<p><a id="SWCLOSget-range" name="SWCLOSget-range"/>
<div class="titlebar">
<div class="defname">get-range <i>property</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the range value from <i>property</i> and its 
  super-properties. The inheritance rule is same as <a 
  href="#SWCLOSget-domain">get-domain</a>. 
  This function may signal <b>range-condition-unsatiafiable</b> error. 
</div></p>
<p><a id="SWCLOScollect-ranges" name="SWCLOScollect-ranges"/>
<div class="titlebar">
<div class="defname">collect-ranges <i>properties</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">collects ranges from each of <i>properties</i> using 
  <b>get-range</b>. A property must be a symbol. </div></p>
<p><a id="SWCLOSrangep" name="SWCLOSrangep"/>
<div class="titlebar">
<div class="defname">rangep <i>property</i> <i>range</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if <i>property</i>'s range is a subclass of 
  <i>range</i>, or if some of <i>property</i>'s super-properties has a subclass 
  of <i>range</i>.</div></p>
<h3 height="30">8.2 &nbsp;Domain and Range Constraints Satisfaction</h3>
<p>As mentioned in the description of <b>get-domain</b> and <b>get-range</b> 
above, any disjoint pair of domains and ranges with respect to a specific 
property causes the <i>unsatisfiable condition</i> error. The satisfiability 
checking is very important especially in OWL, because OWL provides users the 
definition of owl:disjointWith relation on concepts (classes), while RDF 
provides only the intrinsic disjoitness with respect to XML Schema data. </p>
<p>In the following demonstration, <b>range-condition-unsatiafiable</b> error 
happens, since <b>xsd:float</b> and <b>xsd:integer</b> are disjoint and both are 
defined as domains with respect to hasInteger property. </p>
<code style="font-size:8pt">gx-user(2): (defProperty hasFloat (rdfs:range 
xsd:float))<br/>#&lt;rdf:Property hasFloat&gt;<br/>gx-user(3): (defProperty 
hasInteger (rdfs:range 
xsd:integer)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:subPropertyOf 
hasFloat))<br/>#&lt;rdf:Property hasInteger&gt;<br/>gx-user(4): (defResource foo 
(hasInteger 1))<br/>Error: range condition unsatisfiable: disjoint clash: 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;rdfs:Datatype xsd:integer&gt; 
#&lt;rdfs:Datatype xsd:float&gt;<br/>[condition type: 
range-condition-unsatisfiable]<br/></code>
<p>If domains and ranges involve some inclusiveness (<b>gx:subtypep</b> relation 
in RDF and <b>subsumed-p</b> relation in OWL) among them, the <i>most specific 
concepts</i> (<i>classes</i>) or MSCs are returned. Namely, the return value of 
<b>get-domain</b> and <b>get-range</b> is the most specific concept (if all 
concepts are related in the super-sub relation) or a list of the most specific 
concepts (if some concepts are independent in the super-sub relation). </p>
<p>After rebooting SWCLOS,</p><code style="font-size:8pt">gx-user(2): (defProperty 
hasInteger (rdfs:range xsd:integer))<br/>#&lt;rdf:Property 
hasInteger&gt;<br/>gx-user(3): (defProperty 
hasPositiveInteger<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
xsd:positiveInteger)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:subPropertyOf 
hasInteger))<br/>#&lt;rdf:Property hasPositiveInteger&gt;<br/>gx-user(4): 
(get-range hasPositiveInteger)<br/>#&lt;rdfs:Datatype 
xsd:positiveInteger&gt;<br/>gx-user(5): (subtypep xsd:positiveInteger 
xsd:integer)<br/>t<br/>t<br/></code>
<p>In this case, xsd:positiveInteger is chosen as range constraint of property 
subproperty hasPositiveInteger in two constraints, xsd:integer and 
xsd:positiveInteger, because xsd:positiveInteger is more specific than 
xsd:integer. </p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>9. &nbsp;RDFS Axioms and Entailments</h2>
<h3 height="30">9.1 &nbsp;RDF and RDFS Axioms</h3>
<p>In SWCLOS, <a href="http://www.w3.org/TR/rdf-mt/">all RDF and RDFS axioms</a> 
are implemented. For exmaple, the following example shows <a 
href="http://www.w3.org/TR/rdf-mt#RDF_axiomatic_triples">RDF axiomatic 
triples</a>.</p>
<blockquote><code style="font-size:8pt">gx-user(2): (typep rdf:type 
  rdf:Property)<br/>t<br/>t<br/>gx-user(3): (typep rdf:subject 
  rdf:Property)<br/>t<br/>t<br/>gx-user(4): (typep rdf:predicate 
  rdf:Property)<br/>t<br/>t<br/>gx-user(5): (typep rdf:object 
  rdf:Property)<br/>t<br/>t<br/>gx-user(6): (typep rdf:first 
  rdf:Property)<br/>t<br/>t<br/>gx-user(7): (typep rdf:rest 
  rdf:Property)<br/>t<br/>t<br/>gx-user(8): (typep rdf:value 
  rdf:Property)<br/>t<br/>t<br/>gx-user(9): (typep rdf:nil 
  rdf:List)<br/>t<br/>t<br/></code></blockquote>
<p>The following example shows a part of <a 
href="http://www.w3.org/TR/rdf-mt#RDFS_axiomatic_triples">RDFS axiomatic 
triples</a>.</p>
<blockquote><code style="font-size:8pt">gx-user(14): (rdfs:domain 
  rdf:type)<br/>#&lt;rdfs:Class rdfs:Resource&gt;<br/>gx-user(15): (rdfs:domain 
  rdfs:domain)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(16): (rdfs:domain 
  rdfs:range)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(17): (rdfs:domain 
  rdfs:subPropertyOf)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(18): 
  (rdfs:domain rdfs:subClassOf)<br/>#&lt;RDFSclass rdfs:Class&gt;<br/>gx-user(19): 
  (rdfs:domain rdf:subject)<br/>#&lt;rdfs:Class 
  rdf:Statement&gt;<br/><br/>gx-user(24): (rdfs:range rdf:type)<br/>#&lt;rdfsClass 
  rdfs:Class&gt;<br/>gx-user(25): (rdfs:range rdfs:domain)<br/>#&lt;rdfsClass 
  rdfs:Class&gt;<br/>gx-user(26): (rdfs:range rdfs:range)<br/>#&lt;rdfsClass 
  rdfs:Class&gt;<br/>gx-user(27): (rdfs:range 
  rdfs:subPropertyOf)<br/>#&lt;rdfs:Class rdf:Property&gt;<br/>gx-user(28): 
  (rdfs:range rdfs:subClassOf)<br/>#&lt;rdfsClass 
  rdfs:Class&gt;<br/><br/>gx-user(31): (rdfs:subClassOf 
  rdf:Alt)<br/>#&lt;rdfs:Class rdfs:Container&gt;<br/>gx-user(32): 
  (rdfs:subClassOf rdf:Bag)<br/>#&lt;rdfs:Class 
  rdfs:Container&gt;<br/>gx-user(33): (rdfs:subClassOf 
  rdf:Seq)<br/>#&lt;rdfs:Class rdfs:Container&gt;<br/>gx-user(34): 
  (rdfs:subClassOf rdfs:ContainerMembershipProperty)<br/>#&lt;rdfs:Class 
  rdf:Property&gt;<br/><br/>gx-user(35): (rdfs:subPropertyOf 
  rdfs:isDefinedBy)<br/>(#&lt;rdf:Property rdfs:seeAlso&gt;)<br/><br/>gx-user(36): 
  (typep rdf:XMLLiteral rdfs:Datatype)<br/>t<br/>t<br/>gx-user(37): 
  (rdfs:subClassOf rdf:XMLLiteral)<br/>#&lt;rdfs:Class 
  rdfs:Literal&gt;<br/>gx-user(38): (rdfs:subClassOf 
  rdfs:Datatype)<br/>#&lt;rdfsClass rdfs:Class&gt;<br/></code></blockquote>
<p>The followings also show important axiomatic triples on RDFS.</p>
<blockquote><code style="font-size:8pt">gx-user(39): (typep rdfs:Resource 
  rdfs:Class)<br/>t<br/>t<br/>gx-user(40): (typep rdfs:Class 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(41): (typep rdfs:Resource 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(42): (typep rdfs:Class 
  rdfs:Class)<br/>t<br/>t<br/>gx-user(43): (typep rdf:XMLLiteral 
  rdfs:Class)<br/>t<br/>t<br/>gx-user(44): (typep rdfs:Datatype 
  rdfs:Class)<br/>t<br/>t<br/></code></blockquote>
<p>The class-instance relation in RDF is directly defined with rdf:type 
property. The notion of RDF class is different from the class notion in CLOS, 
but the subsumption relation among objects is the same as that in CLOS. The 
straightforward mapping of rdf:type relation to CLOS class instance relation 
conveys gains and benefits such as the potential of CLOS is available. However, 
this straightforward mapping causes only one obstacle to implement RDF on top of 
CLOS, namely rdfs:Class that is an instance of rdfs:Class itself. Allegro Common 
Lisp rejects such membership loop among classes, whereas cl:standard-object is 
an instance of itself in CLOS. Therefore, to work around this obstacle, the 
internal proxy class, <b>rdfsClass</b>, is introduced as a class of rdfs:Class 
and simultaneously as a subclass of rdfs:Class. Note that this twisted relation 
of class/instance and superclass/subclass between rdfs:Class and rdfsClass in 
CLOS produces a membership loop of rdfs:Class as well as the relation between 
rdfs:Resource and rdfs:Class in CLOS. See the followings. </p>
<blockquote><code style="font-size:8pt">gx-user(2): (cl:typep rdfs:Resource 
  rdfs:Class)<br/>t<br/>gx-user(3): (cl:subtypep rdfs:Class 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(4): (cl:typep rdfs:Resource 
  rdfs:Resource)<br/>t<br/>gx-user(5): (cl:typep rdfs:Class 
  'rdfsClass)<br/>t<br/>gx-user(6): (cl:subtypep 'rdfsClass 
  rdfs:Class)<br/>t<br/>t<br/>gx-user(7): (cl:typep rdfs:Class 
  rdfs:Class)<br/>t<br/></code></blockquote>
<p>Note that the <i>membership loop</i> on rdfs:Class is really implemented in 
CLOS semantics by means of a trick called twisted relation between rdfs:Class 
and its direct class <b>rdfsClass</b>.</p>
<h3 height="30">9.2 &nbsp;RDFS Entailment</h3>
<p>The <a href="http://www.w3.org/TR/rdf-mt#rdfs_entailment">RDFS entailment</a> 
directs that every resource in RDF is typed to rdfs:Resource. The following 
shows some examples.</p>
<blockquote><code style="font-size:8pt">gx-user(13): (typep rdfs:Resource 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(14): (typep rdfs:Class 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(15): (typep rdf:nil 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(16): (typep rdfs:comment 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(17): (typep "This is a plain literal." 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(18): (typep 1 
  rdfs:Resource)<br/>t<br/>t<br/>gx-user(19): (typep &lt;http://www.somewhere&gt; 
  rdfs:Resource)<br/>t<br/>t<br/></code></blockquote>
<h3 height="30">9.3 &nbsp;RDF Entailment Rules</h3>
<p>There are two <a href="http://www.w3.org/TR/rdf-mt/#RDFRules">RDF entailment 
rules</a>, <b>rdf1</b> and <b>rdf2</b> as follows.</p>
<blockquote><code style="font-size:8pt">gx-user(9): (defIndividual uuu (aaa 
  yyy))<br/>Warning: Entail by rdfs1: aaa rdf:type 
  rdf:Property.<br/>#&lt;|rdfs:Resource| uuu&gt;<br/>gx-user(10): (typep aaa 
  rdf:Property)<br/>t<br/>t<br/>gx-user(11): (defIndividual vvv (aaa (xsd:integer 
  1)))<br/>#&lt;|rdfs:Resource| vvv&gt;<br/>gx-user(12): (get-form 
  vvv)<br/>(|rdfs:Resource| vvv (aaa "1"^^xsd:integer))<br/>gx-user(13): (typep 
  (slot-value vvv 'aaa) rdf:XMLLiteral)<br/>t<br/>t<br/></code></blockquote>
<p>In any input triple, a predicate is an instance of rdf:Property (entailment 
rule <b>rdf1</b>). When an object of an input triple is a well-typed XML 
literal, SWCLOS creates an data object that is an instance of rdf:XMLLiteral 
typed to the designated type (entailment rule <b>rdf2</b>).</p>
<h3 height="30">9.4 &nbsp;RDFS Entailment Rules</h3>
<p>There are 13 rules in RDFS as shown in <a 
href="http://www.w3.org/TR/rdf-mt/#RDFSRules">RDFS Entailment Rules in RDF 
Semantics</a>. </p>
<p>However a lisp string and number is interpreted as a plain literal in RDFS by 
SWCLOS. Therefore, <b>rdfs1</b> rule is implicitly realized for a plain literal. 
</p>
<p>Note that hereafter if line numbers are renewed some younger number, it means 
the system is newly booted and refleshed.</p>
<blockquote><code style="font-size:8pt">gx-user(2): (typep "This is a string in 
  lisp." rdfs:Literal)<br/>t<br/>t<br/>gx-user(3): (typep 1 
  rdfs:Literal)<br/>t<br/>t<br/></code></blockquote>
<p>For a plain literal with language tag, SWCLOS creates an instance object of 
<a 
href="#SWCLOSinLang"><b>rdf:inLang</b></a>, 
then the result for a literal with language tag also satisfies <b>rdfs1</b> 
rule.</p>
<p>Note that the system is rebooted, before each of the following examples, 
otherwise uuu or aaa in the example are collides.</p><code style="font-size:8pt">gx-user(4): (defIndividual uuu (aaa (:en "This is an English 
text.")))<br/>Warning: Entail by rdf1: aaa rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| uuu&gt;<br/>gx-user(5): (get-form 
uuu)<br/>(|rdfs:Resource| uuu (aaa (:en "This is an English 
text.")))<br/>gx-user(6): (slot-value uuu 'aaa)<br/>"This is an English 
text."@en<br/>gx-user(7): (typep (slot-value uuu 'aaa) 
rdfs:Literal)<br/>t<br/>t<br/></code>
<p><b>Rdfs2</b> is a domain entailment as follows. SWCLOS proactively performs 
this entailment rule. In other words, SWCLOS newly creates an instance or 
refines the existing instance according to this rule.</p><code style="font-size:8pt">gx-user(2): (defProperty aaa (rdfs:domain xxx))<br/>Warning: Range 
entailX3 by rdfs:domain: xxx rdf:type rdfs:Class.<br/>#&lt;rdf:Property 
aaa&gt;<br/>gx-user(3): (defIndividual uuu (aaa yyy))<br/>#&lt;xxx 
uuu&gt;<br/>gx-user(4): (typep uuu xxx)<br/>t<br/>t<br/></code>
<p><b>Rdfs3</b> is a range entailment same as domain rule 
<b>rdfs2</b>.</p><code style="font-size:8pt">gx-user(2): (defProperty aaa 
(rdfs:range xxx))<br/>Warning: Range entailX3 by rdfs:range: xxx rdf:type 
rdfs:Class.<br/>#&lt;rdf:Property aaa&gt;<br/>gx-user(3): (defIndividual uuu (aaa 
vvv))<br/>Warning: Range entailX3 by aaa: vvv rdf:type 
xxx.<br/>#&lt;|rdfs:Resource| uuu&gt;<br/>gx-user(4): (typep vvv 
xxx)<br/>t<br/>t<br/></code>
<p><b>Rdfs4a</b> rule entails a subject in any triple is an instance of 
rdfs:Resource. In a description of form for <b>addForm</b> input parameter, 
individual's type is designated by a <i>class</i>specifier in the form. If 
'rdf:Description' is indicated for <i>class</i> description, or cl:nil is passed 
for the resource object creation as no type indication, <b>rdfs4a</b> rule may 
be applicable. However, there is a sensitive question in SWCLOS. In RDF(S) 
semantics, rdfs:Resource is a type of every resource, despite that a resource is 
an instance of rdfs:Class or an instance of rdfs:Resource. On the other hand, in 
CLOS level at SWCLOS implementation, we have two possibilities for the instance 
of rdfs:Resource. It may be either as an instance of rdfs:Resource CLOS class 
(namely instance), or as an instance of rdfs:Class metaclass (namely class). As 
a default in SWCLOS, an instance of rdfs:Resource as CLOS instance of 
rdfs:Resource is created. Thus, SWCLOS changes the category of created object 
from instance to class later on, if a metaclass is indicated for the object at 
the proper definition.</p>
<p><b>Rdfs4b</b> has the same logic and the same problem as <b>rdfs4a</b> for 
the range entailment. See the following example.</p><code style="font-size:8pt">gx-user(2): (addForm '(cl:nil (:name uuu) (aaa xxx)))<br/>Warning: 
Entail by rdf1: aaa rdf:type rdf:Property.<br/>#&lt;|rdfs:Resource| 
uuu&gt;<br/>gx-user(3): (typep uuu rdfs:Resource)<br/>t<br/>t<br/>gx-user(4): (typep 
xxx rdfs:Resource)<br/>t<br/>t<br/></code>
<p><b>Rdfs5</b> is a transitivity rule on rdfs:subPropertyOf. We implemented it 
on properties.</p><code style="font-size:8pt">gx-user(2): (defProperty uuu 
(rdfs:subPropertyOf vvv))<br/>Warning: Range entailX3 by rdfs:subPropertyOf: vvv 
rdf:type rdf:Property.<br/>#&lt;rdf:Property uuu&gt;<br/>gx-user(3): (defProperty 
vvv (rdfs:subPropertyOf xxx))<br/>Warning: Range entailX3 by rdfs:subPropertyOf: 
xxx rdf:type rdf:Property.<br/>#&lt;rdf:Property vvv&gt;<br/>gx-user(4): 
(subproperty-p uuu xxx)<br/>t<br/></code>
<p><b>Rdfs6</b> is very natural rule on rdfs:subPropertyOf as well as 
<b>rdfs10</b> on rdfs:subClassOf.</p>
<blockquote><code style="font-size:8pt">gx-user(9): (subproperty-p uuu 
  uuu)<br/>t<br/></code></blockquote>
<p><b>Rdfs7</b> may be a little bit confusing.</p><code style="font-size:8pt">gx-user(2): (defProperty aaa (rdfs:subPropertyOf 
bbb))<br/>Warning: Range entailX3 by rdfs:subPropertyOf: bbb rdf:type 
rdf:Property.<br/>#&lt;rdf:Property aaa&gt;<br/>gx-user(3): (defIndividual uuu 
(aaa yyy))<br/>#&lt;|rdfs:Resource| uuu&gt;<br/>gx-user(4): (slot-value uuu 
'bbb)<br/>Error: The slot bbb is missing from the object #&lt;|rdfs:Resource| 
uuu&gt;<br/>&nbsp;&nbsp;of class #&lt;rdfs:Class |rdfs:Resource|&gt; during 
operation slot-value.<br/>[condition type: program-error]<br/>gx-user(5): (-&gt; 
uuu bbb)<br/>#&lt;|rdfs:Resource| yyy&gt;<br/></code><br/>
<p>In the form, (slot-value uuu 'bbb), although getting a slot value of bbb that 
is attached to uuu object was attempted, the value yyy is attached by slot named 
aaa, then CLOS signaled an slot missing alarm. The function &ldquo;<b>-&gt;</b>&rdquo; is 
for RDF graph traversing and getting the value at the final place arrived. It 
takes account of not only designated properties as travel path but also their 
super-properties. </p>
<p><b>Rdfs8</b> means that the default superclass of instance of rdfs:CLass 
metaclass is rdfs:Resource.</p>
<blockquote><code style="font-size:8pt">gx-user(2): (defResource uuu (rdf:type 
  rdfs:Class))<br/>#&lt;rdfs:Class uuu&gt;<br/>gx-user(3): (subtypep uuu 
  rdfs:Resource)<br/>t<br/>t<br/></code></blockquote>
<p><b>Rdfs9</b> subsumption rule and <b>rdfs10</b> are natively equipped with in 
CLOS.</p><code style="font-size:8pt">gx-user(2): (defResource uuu (rdfs:subClassOf 
xxx))<br/>Warning: Range entailX1 by rdfs:subClassOf: xxx rdf:type 
rdfs:Class.<br/>#&lt;rdfs:Class uuu&gt;<br/>gx-user(3): (defIndividual vvv 
(rdf:type uuu))<br/>#&lt;uuu vvv&gt;<br/>gx-user(4): (typep vvv 
xxx)<br/>t<br/>t<br/>gx-user(5): (cl:typep vvv xxx)<br/>t<br/>gx-user(6): (subtypep 
uuu uuu)<br/>t<br/>t<br/>gx-user(7): (cl:subtypep uuu 
uuu)<br/>t<br/>t<br/></code><br/>
<p><b>Rdfs11</b> transitivity rule of rdfs:subClassOf is also natively equipped 
with in CLOS.</p><code style="font-size:8pt">gx-user(2): (defResource uuu 
(rdfs:subClassOf vvv))<br/>Warning: Range entailX1 by rdfs:subClassOf: vvv 
rdf:type rdfs:Class.<br/>#&lt;rdfs:Class uuu&gt;<br/>gx-user(3): (defResource vvv 
(rdfs:subClassOf xxx))<br/>Warning: Range entailX1 by rdfs:subClassOf: xxx 
rdf:type rdfs:Class.<br/>#&lt;rdfs:Class vvv&gt;<br/>gx-user(4): (subtypep uuu 
xxx)<br/>t<br/>t<br/>gx-user(5): (cl:subtypep uuu xxx)<br/>t<br/>t<br/></code><br/>
<p><b>Rdfs12</b> is a special rule for rdfs:ContainerMembershipProperty. SWCLOS 
proactively adds the entailment that an instance of 
rdfs:ContainerMembershipProperty is a subproperty of rdfs:member.</p><code style="font-size:8pt">gx-user(2): (defIndividual uuu (rdf:type 
rdfs:ContainerMembershipProperty))<br/>#&lt;rdfs:ContainerMembershipProperty 
uuu&gt;<br/>gx-user(3): (subproperty-p uuu rdfs:member)<br/>t<br/></code><br/>
<p>The last rule <b>rdfs13</b> is for data type definition.</p><code style="font-size:8pt">gx-user(2): (defResource uuu (rdf:type 
rdfs:Datatype))<br/>Warning: Datatype uuu is defined. Please define lisp type 
with same name.<br/>#&lt;rdfs:Datatype uuu&gt;<br/>gx-user(3): (subtypep uuu 
rdfs:Literal)<br/>t<br/>t<br/></code><br/>
<p>SWCLOS satisfies <b>rdfs13</b> by creating an instance of rdfs:Datatype. 
However, the lisp system cannot interpret this type until the same name lisp 
type is defined.</p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>10. &nbsp;RDF/XML Parser and Writer </h2>
<p>So far, only S-expression is used to represent RDF ontology. It is convenient 
for lisp programmers to handle pieces of knowledge in RDF. However, SWCLOS, of 
course, allows users to read RDF/XML format files and print out SWCLOS contents 
in RDF/XML format. </p>
<h3 height="30">10.1 &nbsp;RDF/XML Parser</h3>
<p><b>parse-rdf</b> is a parser for RDF/XML format files. It is useful to check 
RDF/XML syntax, but it does not interpret anything in semantics. In the 
following example, you might misunderstand that <b>parse-rdf</b> just prints out 
an RDF/XML format file, but it is not a reality. <b>parse-rdf</b> produces a 
list of XML element of lisp structure from RDF/XML file, namely <a 
href="http://www.w3.org/TR/2004/REC-xml11-20040204/#NT-XMLDecl">XMLDecl</a>, <a 
href="http://www.w3.org/TR/2004/REC-xml11-20040204/#dt-doctype">doctypedecl</a>, 
<a 
href="http://www.w3.org/TR/2004/REC-xml11-20040204/#sec-comments">Comment</a>, 
and <a href="http://www.w3.org/TR/rdf-syntax-grammar/#RDF">RDFdecl</a> element 
as lisp structure. In Common Lisp, the print form of lisp structure is 
programmable. So, the structure print function of XMLDecl is programmed so as to 
print out a XMLDecl form in XML, the print function of doctypedecl structure is 
to &ldquo;:doctypedecl ...&rdquo;, a Comment structure to a Comment form, and an RDFdecl 
structure to an RDFdecl form. In short, <b>parse-rdf</b> reads RDF/XML format 
file, parses RDF/XML format, makes structures, and returns them in a list. Then, 
you see RDF/XML-like forms of such structures in the list. </p>
<p>If you want to handle just RDF data without the interpretation of RDFS and 
OWL from RDF/XML format files, <b>parse-rdf</b> is available to do so. However, 
in order to interpret contents in RDF/XML files, you may use 
<b>read-rdf-file</b> with an accepter function, which is usually 
<b>addRdfXml</b>. See the followings. </p>
<code style="font-size:8pt">gx-user(2): 
(with-open-file (p "RDFS/JenaEx.rdf") (parse-rdf p))<br/>(&lt;?xml version="1.0" 
?&gt; #&lt;doctypedecl ... &gt; <br/>&lt;rdf:RDF 
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:vCard="http://www.w3.org/2001/vcard-rdf/3.0#"<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:somewhere="http://somewhere/"&gt;<br/>&nbsp;&nbsp;&lt;rdf:Description 
rdf:about="http://somewhere/JohnSmith"&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:FN&gt;John 
Smith&lt;/vCard:FN&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:N&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Description&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:Family&gt;Smith&lt;/vCard:Family&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:Given&gt;John&lt;/vCard:Given&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/vCard:N&gt;<br/>&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/>&lt;/rdf:RDF&gt;)<br/>gx-user(3): 
(read-rdf-file #'addRdfXml "RDFS/JenaEx.rdf")<br/>Warning: Entail by rdf1: 
vCard:FN rdf:type rdf:Property.<br/>Warning: Entail by rdf1: vCard:N rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: vCard:Family rdf:type 
rdf:Property.<br/>Warning: Entail by rdf1: vCard:Given rdf:type 
rdf:Property.<br/>:done<br/>gx-user(4): 
somewhere:JohnSmith<br/>#&lt;|rdfs:Resource| 
somewhere:JohnSmith&gt;<br/></code>
<p><a id="SWCLOSparse-rdf" name="SWCLOSparse-rdf"/>
<div class="titlebar">
<div class="defname">parse-rdf <i>stream</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">parses RDF/XML from <i>stream</i> and makes the internal 
  representation of RDF. This function returns a list of several XML structures. 
  Note that <b>*base-uri*</b> and <b>*default-namespace*</b> in the environment 
  are updated through content from <i>stream</i>. </div></p>
<p><a id="SWCLOSread-rdf-file" name="SWCLOSread-rdf-file"/>
<div class="titlebar">
<div class="defname">read-rdf-file <i>accepter-fun</i> [ <i>file</i> [ <i>code</i> 
]]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function reads and parses a <i>file</i> that contains RDF/XML 
  format data, then passes attributes in RDFdecl, parsed XMLDecl, parsed 
  doctypedecl, parsed Comments, and parsed Descriptions to <i>accepter-fun</i>. 
  The <i>code</i> is a character code of <i>file</i>, of which the default is 
  utf-8. If file has its encoding description in XMLDecl, the direction in file 
  supersedes the <i>code</i>. </div></p>
<p><a id="SWCLOSaddRdfXml" name="SWCLOSaddRdfXml"/>
<div class="titlebar">
<div class="defname">addRdfXml <i>description</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function accepts an instance of lisp structure Description, 
  which may be generated from the RDF parser, and transform it to S-expression 
  form, then interprets the form by <b>addForm</b>. This function returns the 
  result of <b>addForm</b>. </div></p>
<h3 height="30">10.2 &nbsp;RDF/XML Writer</h3>
<p>To print out RDF data in RDF/XML format, the function <b>write-xml</b> is 
available. See the following example.</p><code style="font-size:8pt">gx-user(5): 
(write-xml somewhere:JohnSmith)<br/>&lt;rdf:RDF 
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:somewhere="http://somewhere/"<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns:vCard="http://www.w3.org/2001/vcard-rdf/3.0#" 
&gt;<br/>&nbsp;&nbsp;&lt;rdf:Description rdf:about="http://somewhere/JohnSmith" 
&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:FN&gt;John 
Smith&lt;/vCard:FN&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:N&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;rdf:Description&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:Family&gt;Smith&lt;/vCard:Family&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;vCard:Given&gt;John&lt;/vCard:Given&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/vCard:N&gt;<br/>&nbsp;&nbsp;&lt;/rdf:Description&gt;<br/>&lt;/rdf:RDF&gt;<br/></code>
<p><a id="SWCLOSwrite-xml" name="SWCLOSwrite-xml"/>
<div class="titlebar">
<div class="defname">write-xml <i>x</i> [ <i>stream</i> ]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function accepts a resource object or a list of resource 
  objects, and print out them in RDF/XML format. Note that this function returns 
  no value. If <i>stream</i> is not supplied, *standard-output* is used as 
  default. </div></p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>11. &nbsp;N-Triples </h2>
<p>Note also that N-Triples module is separated from RDFS system. You must load 
it to use it.</p>
<h3 height="30">11.1 &nbsp;N-Triple Parser</h3>
<p>The <a href="http://www.w3.org/TR/rdf-testcases/#ntriples">N-Triples</a> is a 
textual expression of RDF graph. A line in N-Triples represents one triple of 
<i>subject/predicate/object</i>. The proper <a 
href="http://www.w3.org/TR/rdf-testcases/#ntriples">syntax of N-Triple</a> 
requires URI references and does not allow QNames. However, we relaxed the 
syntax to allow non-ASCII character sets and QNames instead of URI references. 
</p>
<p>The graph at <a 
href="#figure4.1">Figure4.1</a> 
is expressed in N-Triples as follows. To represent a blank node, you need to use 
a nodeID in N-Triples. Note that there is one period at the end of each line, 
where the tilde, locally in the followings, means the line continuation. </p>
<p class="box"><code style="font-size:8pt">&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt; 
&lt;http://www.example.org/terms/editor&gt; _:a01 .<br/>_:a01 
&lt;http://www.example.org/terms/homePage&gt; 
&lt;http://purl.org/net/dajobe/&gt; .<br/>_:a01 
&lt;http://www.example.org/terms/fullName&gt; "Dave Becket" 
.<br/>&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt; 
&lt;http://purl.org/dc/elements/1.1./title&gt; ~<br/>&nbsp;&nbsp;"RDF/XML Syntax 
Specification (Revised)" .</code></p>
<p>As you see, the strict syntax of N-Triple is tedious for using URIs. So, we 
have relaxed it so as to accept the corresponding QNames instead of the URIs. 
</p>
<p class=box><code style="font-size:8pt">&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt; ex:editor _:a01 
.<br/>_:a01 ex:homePage &lt;http://purl.org/net/dajobe/&gt; .<br/>_:a01 
ex:fullName "Dave Becket" .<br/>&lt;http://www.w3.org/TR/rdf-syntax-grammar&gt; 
dc:title ~<br/>&nbsp;&nbsp;"RDF/XML Syntax Specification (Revised)" .</code></p>
<p>The function <b>read-NTriple-file</b> reads the relaxed N-Triple format file, 
and parses each line to three strings of <i>subject/predicate/object</i>. This 
function is usually used with <b>addTriple-from-file</b>, then 
<b>addTriple-from-file</b> accepts and interprets 
<i>subject/predicate/object</i> strings, including strings that stands for 
QNames. URIs for resources <em>do not cause</em> to invoke <a 
href="#SWCLOSuri2symbol"><b>uri2symbol</b></a> 
in reading, so the generated CLOS objects are bound only to <b>iri</b> values. 
QNames for resources cause to invoke a query for users in case that the 
namespace is unknown. In the example below, this shows a right and bottom corner 
part of <a 
href="#figure7.1"><b>Figure7.1</b></a>. 
</p><code style="font-size:8pt">gx-user(2): (read-NTriple-file #'addTriple-from-file 
"RDFS/JenaEx.nt")<br/>Warning: Entail in _:a001 vCard:Family "Smith":<br/>..... 
vCard:Family rdf:type rdf:Property.<br/>Warning: Entail in _:a001 vCard:Family 
"Smith":<br/>..... _:a001 rdf:type rdfs:Resource<br/>Warning: Entail in _:a001 
vCard:Given "John":<br/>..... vCard:Given rdf:type rdf:Property.<br/>Warning: 
Entail in &lt;http://somewhere/JohnSmith&gt; vCard:N _:a001:<br/>..... vCard:N 
rdf:type rdf:Property.<br/>Warning: Entail in &lt;http://somewhere/JohnSmith&gt; 
vCard:N _:a001:<br/>..... &lt;http://somewhere/JohnSmith&gt; rdf:type 
rdfs:Resource.<br/>Warning: Entail in &lt;http://somewhere/JohnSmith&gt; vCard:FN 
"John Smith":<br/>..... vCard:FN rdf:type rdf:Property.<br/>:done<br/>gx-user(3): 
(get-form _:a001)<br/>(|rdfs:Resource| (vCard:Family "Smith") (vCard:Given 
"John"))<br/>gx-user(4): (get-form 
&lt;&lt;http://somewhere/JohnSmith&gt;&gt;)<br/>(|rdfs:Resource| (rdf:about 
&lt;http://somewhere/JohnSmith&gt;)<br/>(vCard:N (|rdfs:Resource| (vCard:Family 
"Smith") (vCard:Given "John")))<br/>(vCard:FN "John Smith"))<br/></code>
<p><a id="SWCLOSread-NTriple-file" name="SWCLOSread-NTriple-file"/>
<div class="titlebar">
<div class="defname">read-NTriple-file <i>accepter-fun</i> [ <i>file</i> [ 
<i>code</i> ]]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function reads and parses a <i>file</i> that contains 
  N-Triple format data, then passes three strings of 
  <i>subject/predicate/object</i> to <i>accepter-fun</i>. The <i>code</i> is a 
  character code of <i>file</i>. The default value of <i>code</i> is ':utf-8'. 
</div></p>
<p><a id="SWCLOSaddTriple-from-file" name="SWCLOSaddTriple-from-file"/>
<div class="titlebar">
<div class="defname">addTriple-from-file <i>subject predicate object</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe"><i>subject</i>, <i>predicate</i>, and <i>object</i> are strings. 
  This function interprets three parameters, and adds the triple data into 
  memory. Actually, this function interns three symbols or interns three uris of 
  parameters, and invokes <b>addTriple</b>. </div></p>
<h3 height="30">11.2 &nbsp;Adding N-Triples</h3>
<p>The method <b>addTriple</b> adds an N-Triple, i.e., one 
<i>subject/predicate/object</i>, into memory. In fact, there are many methods of 
<b>addTriple</b>. One method is a piece of building blocks, and each method 
burdens with a part of a whole work parted into pieces. In the followings, 
<b>addTriple</b> methods are categorized by combination patterns of parameter, 
but note that one category is also a collection of several methods. </p>
<p><a id="SWCLOSaddTriplefortype" name="SWCLOSaddTriplefortype"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> (eql rdf:type)) 
<i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">If <i>subject</i> and/or <i>object</i> is a URI, it is changed to 
  an <b>iri</b>. If <i>object</i> is a symbol or <b>iri</b>, it is changed to an 
  instance of rdfs:Class. Finally, <i>subject</i> is defined as an instance of 
  <i>object</i> using <b>addClass</b> if <i>object</i> is a metaclass, or 
  <b>addInstance</b> if <i>object</i> is a class. When <i>subject</i> is already 
  an instance of the <i>object</i>, nothing happens. This method involves the 
  range entailment on rdf:type for an undefined <i>object</i>. </div></p>
<p><a id="SWCLOSaddTripleforsubtype" name="SWCLOSaddTripleforsubtype"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> (eql 
rdfs:subClassOf)) <i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">If <i>subject</i> and/or <i>object</i> is a URI, it is changed to 
  an <b>iri</b>. If <i>subject</i> and/or <i>object</i> is an <b>iri</b>, it is 
  changed to an instance of rdfs:Class. If <i>subject</i> and/or <i>object</i> 
  is a resource but not a class, it is changed to an instance of rdfs:Class. In 
  the case that <i>subject</i> and <i>object</i> are classes, if <i>subject</i> 
  is already a subclass of <i>object</i>, then nothing is done, else this method 
  redefines superclasses of <i>subject</i> with <b>addClass</b> with the most 
  specific concepts of previous superclasses and <i>object</i>. 
</div></p>
<p><a id="SWCLOSaddTripleforsubproperty" name="SWCLOSaddTripleforsubproperty"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> (eql 
rdfs:subPropertyOf)) <i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">If <i>subject</i> and/or <i>object</i> is a URI, it is changed to 
  an <b>iri</b>. If <i>subject</i> and/or <i>object</i> is an <b>iri</b>, it is 
  changed to an instance of rdf:Property. If <i>subject</i> and/or <i>object</i> 
  is a resource but not a property, it is changed to an instance of 
  rdf:Property. In the case that <i>subject</i> and <i>object</i> are 
  properties, if <i>subject</i> is already a subproperty of <i>object</i>, then 
  nothing is done, else this method redefines <i>subject</i> as an subproperty 
  of <i>object</i> using <b>addInstance</b> with the most specific properties of 
  previous superproperties and <i>object</i>. </div></p>
<p><a id="SWCLOSaddTriplestandard" name="SWCLOSaddTriplestandard"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> rdf:Property) 
<i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">If <i>subject</i> is a URI, it is changed to an <b>iri</b>. If 
  <i>subject</i> is a symbol or an <b>iri</b>, and <i>object</i> is a symbol or 
  an <b>iri</b>, then <i>object</i> is defined with the range constraint from 
  <i>predicate</i>, if it is not defined, otherwise it is redefined with the 
  range constraint. If <i>subject</i> is a symbol or an <b>iri</b>, and 
  <i>object</i> is a number or string or a resource, then <i>subject</i> is 
  defined using the domain restriction from <i>predicate</i>. If <i>subject</i> 
  is a resource, it is checked using the domain restriction from 
  <i>predicate</i> and this triple is installed using <b>addInstance</b> or 
  <b>addClass</b> with the most specific domain class. </div></p>
<p><a id="SWCLOSaddTripleforsymbol" name="SWCLOSaddTripleforsymbol"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> symbol) 
<i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">When <i>predicate</i> is undefined, then defines it as instance of 
  rdf:Property. This function recursive-calls with getting the value of 
  <i>predicate</i>. </div></p>
<p><a id="SWCLOSaddTripleforURI" name="SWCLOSaddTripleforURI"/>
<div class="titlebar">
<div class="defname">addTriple <i>subject</i> (<i>predicate</i> net.uri:uri) 
<i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">This function translates <i>predicate</i> URI to a QName, then 
  recursively calls with the <i>predicate</i> QName. This function also adds 
  <i>predicate</i> URI to rdf:about slot of <i>predicate</i> object. 
</div></p>
<p><a id="SWCLOSaddTripleforURIsubject" name="SWCLOSaddTripleforURIsubject"/>
<div class="titlebar">
<div class="defname">addTriple (<i>subject</i> net.uri:uri) <i>predicate</i> 
<i>object</i></div>
<div class="deftype">[Method]</div></div>
<div class="defdescribe">This method changes <i>subject</i> to <b>iri</b>, then recursively 
  calls with the <i>subject</i> of <b>iri</b>. </div></p>
<p>For convenience to programmers, three define macros are prepared in 
S-expression. <b>defTriple</b> and <b>/.</b> and <b>./</b> are completely the 
same for N-Triple definition. After the example above of 
<b>read-NTriple-file</b>, the followings demonstrate the example of 
<b>defTriple</b>. </p><code style="font-size:8pt">gx-user(2): (defpackage 
vCard)<br/>#&lt;The vCard package&gt;<br/>gx-user(3): (defTriple 
&lt;http://somewhere/JohnSmith&gt; vCard::FN "John Smith") <br/>Warning: Entail 
in &lt;http://somewhere/JohnSmith&gt; vCard:FN "John Smith":<br/>..... vCard:FN 
rdf:type rdf:Property.<br/>Warning: Entail in &lt;http://somewhere/JohnSmith&gt; 
vCard:FN "John Smith":<br/>..... &lt;http://somewhere/JohnSmith&gt; rdf:type 
rdfs:Resource<br/>#&lt;|rdfs:Resource| :anonymous&gt;<br/>gx-user(4): (defTriple 
&lt;http://somewhere/JohnSmith&gt; vCard::N _:a001)<br/>Warning: Entail in 
&lt;http://somewhere/JohnSmith&gt; vCard:N _:a001:<br/>..... vCard:N rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| :anonymous&gt;<br/>gx-user(5): (defTriple 
_:a001 vCard::Family "Smith")<br/>Warning: Entail in _:a001 vCard:Family 
"Smith":<br/>..... vCard:Family rdf:type rdf:Property.<br/>#&lt;|rdfs:Resource| 
:anonymous&gt;<br/>gx-user(6): (defTriple _:a001 vCard::Given "John")<br/>Warning: 
Entail in _:a001 vCard:Given "John":<br/>..... vCard:Given rdf:type 
rdf:Property.<br/>#&lt;|rdfs:Resource| :anonymous&gt;<br/>gx-user(7): (get-form 
&lt;&lt;http://somewhere/JohnSmith&gt;&gt;)<br/>(|rdfs:Resource| (rdf:about 
&lt;http://somewhere/JohnSmith&gt;) (vCard:FN "John Smith")<br/>(vCard:N 
(|rdfs:Resource| (vCard:Family "Smith") (vCard:Given 
"John"))))<br/></code>
<p><a id="SWCLOSdefTripleforURIsubject" name="SWCLOSdefTripleforURIsubject"/>
<div class="titlebar">
<div class="defname">defTriple <i>subject</i> <i>predicate</i> <i>object</i></div>
<div class="deftype">[Macro]</div></div>
<div class="titlebar">
<div class="defname">/. <i>subject</i> <i>predicate</i> <i>object</i></div>
<div class="deftype">[Macro]</div></div>
<div class="titlebar">
<div class="defname">./ <i>subject</i> <i>predicate</i> <i>object</i></div>
<div class="deftype">[Macro]</div></div>
<div class="defdescribe">This macro makes the form '(addTriple <i>subject</i> 
  <i>predicate</i> <i>object</i>)'.</div></p>
<h3 height="30">11.3 &nbsp;N-Triple Writer</h3>
<p>The resource forms are also obtained as list of triples and also printed out 
in N-Triple format as well as the <i>object-centered form</i> by <b>get-form</b> 
and <b>write-xml</b>. The function <b>get-triple</b> returns a list of relaxed 
N-Triples in S-expression that are composed QNames rather than URIs, and 
<b>write-nt</b> prints them in exact N-Triples format. See the followings. 
</p><code style="font-size:8pt">gx-user(12): (get-triple 
&lt;&lt;http://somewhere/JohnSmith&gt;&gt;)<br/>((<HTTP: JohnSmith somewhere> 
rdf:type |rdfs:Resource|)<br/>&nbsp;(<HTTP: JohnSmith somewhere> vCard:FN "John 
Smith")<br/>&nbsp;(<HTTP: JohnSmith somewhere> vCard:N _:gx5)<br/>&nbsp;(_:gx2 
rdf:type |rdfs:Resource|)<br/>&nbsp;(_:gx2 vCard:Family "Smith")<br/>&nbsp;(_:gx2 
vCard:Given "John"))<br/>gx-user(13): (setf (documentation (find-package :vCard) 
t)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"http://www.w3.org/2001/vcard-rdf/3.0")<br/>"http://www.w3.org/2001/vcard-rdf/3.0"<br/>gx-user(14): 
(set-uri-namedspace-from-pkg (find-package :vCard))<br/>#&lt;The vCard 
package&gt;<br/>gx-user(15): (write-nt 
&lt;&lt;http://somewhere/JohnSmith&gt;&gt;)<br/>&lt;http://somewhere/JohnSmith&gt; 
&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; 
~<br/>&nbsp;&nbsp;&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt; 
.<br/>&lt;http://somewhere/JohnSmith&gt; 
&lt;http://www.w3.org/2001/vcard-rdf/3.0#FN&gt; ~<br/>&nbsp;&nbsp;"John Smith" 
.<br/>&lt;http://somewhere/JohnSmith&gt; 
&lt;http://www.w3.org/2001/vcard-rdf/3.0#N&gt; _:gx10 .<br/>_:gx3 
&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; 
~<br/>&lt;http://www.w3.org/2000/01/rdf-schema#Resource&gt; .<br/>_:gx3 
&lt;http://www.w3.org/2001/vcard-rdf/3.0#Family&gt; "Smith" .<br/>_:gx3 
&lt;http://www.w3.org/2001/vcard-rdf/3.0#Given&gt; "John" .<br/></code><br/>
<p>Note that at the line number 12 and 15 in the above example, a nodeID symbol 
is automatically newly generated by <b>get-triple</b>, and given to 
<b>write-nt</b> rather than nodeID given by users.</p>
<p><a id="SWCLOSget-triple" name="SWCLOSget-triple"/>
<div class="titlebar">
<div class="defname">get-triple <i>resource</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the definition of <i>resource</i> in S-expression of 
  triples. Some nodeIDs are named as 'gx<i>nnn</i>' for anonymous nodes in 
  triple. </div></p>
<p><a id="SWCLOSwrite-triple" name="SWCLOSwrite-triple"/>
<div class="titlebar">
<div class="defname">write-triple <i>triple</i> [ <i>stream</i> ]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function prints out <i>triple</i>, which is a list of three 
  element <i>subject/predicate/object</i>. </div></p>
<p><a id="SWCLOSwrite-nt" name="SWCLOSwrite-n"/t>
<div class="titlebar">
<div class="defname">write-nt <i>resource</i> [ <i>stream</i> ]</div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This function gets triples of <i>resource</i> with 
  <b>get-triple</b> and prints out them using <b>write-triple</b>. For anonymous 
  <i>resource</i>, a nodeID to which a resource object is bound must be given. 
  This functions returns no value. </div></p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>12. &nbsp;OWL in SWCLOS </h2>
<p>The OWL Web Ontology Languages, which are the extension of RDF and RDFS, are 
the W3C Recommendation for Web Ontology description. There are three 
sub-languages of OWL, that is, OWL Light, OWL DL, and OWL Full. The OWL Light 
specification is prepared for an easy realization by implementers. However, the 
capability of ontology description is lower than other OWL languages. The 
capability of ontology description of OWL DL is underpinned by Description Logic 
(DL). The satisfiability checking and the entailment rules by DL is very 
powerful and useful to describe a consistent ontology, but the inference on 
datatype is out of scope of DL, and ones cannot treat classes as an instance of 
some class in the same way of RDFS. OWL Full provides full power for ontology 
description, where the class is not discriminated to the instance, and ones can 
treat classes as instance in the same way as RDFS. In the framework of logics, 
it is difficult to implement the OWL Full metamodeling capability, because it 
requires second order logic or higher.</p>
<p>SWCLOS is a language for Object-Oriented Programming (OOP) that is built on 
top of CLOS. CLOS allows ones metamodeling, namely, programmers can treat 
classes as instance of some class. Thus, if you are familiar with 
meta-programming of CLOS, you can encode metamodeling of ontology in SWCLOS. 
With SWCLOS you will obtain the performance of OWL Full. </p>
<h3 height="30">12.1 &nbsp;OWL Extension of RDF and RDFS</h3>
<p>In theory, OWL is an extension of RDF and RDFS. Therefore, any OWL file, 
including the OWL specification file that is described in RDF/XML, must be 
readable as RDF rather than OWL. In practice, we can obtain, with the OWL 
specification file <a href="http://www.w3.org/2002/07/owl.rdf">owl.rdf</a> from 
W3C, OWL entities as RDF resource objects in the RDF universe. See the following 
demonstration, in which only RDFS module of SWCLOS has been loaded initially. 
</p>
<code style="font-size:8pt">cg-user(1): (in-package gx-user)<br/>#&lt;The gx-user 
package&gt;<br/>gx-user(2): (read-rdf-file #'addRdfXml "OWL/OWL.RDF")<br/>Warning: 
Entail by rdf1: owl:imports rdf:type rdf:Property.<br/>Warning: Entail by rdf1: 
owl:versionInfo rdf:type rdf:Property.<br/>Warning: Entail by rdf1: 
owl:priorVersion rdf:type rdf:Property.<br/>Warning: Implicit range entailment: 
owl:Ontology rdf:type rdfs:Class.<br/>Warning: Entail by rdf1: owl:unionOf 
rdf:type rdf:Property.<br/>Warning: Entail by rdf1: owl:complementOf rdf:type 
rdf:Property.<br/>:done<br/>gx-user(3): (pprint (get-form owl:Thing))<br/>(owl:Class 
owl:Thing (rdfs:label "Thing")<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:unionOf owl:Nothing<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Class 
(owl:complementOf owl:Nothing))))<br/>gx-user(4): (pprint (get-form 
owl:Nothing))<br/>
(owl:Class owl:Nothing (rdf:about #&lt;uri 
http://www.w3.org/2002/07/owl#Nothing&gt;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:label "Nothing") <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:complementOf owl:Thing))<br/>gx-user(5): (typep owl:Class 
rdfs:Class)<br/>t<br/>t<br/>gx-user(6): (subtypep owl:Class 
rdfs:Class)<br/>t<br/>t<br/>gx-user(7): (subtypep owl:Class 
rdfs:Resource)<br/>t<br/>t<br/>gx-user(8): (subtypep owl:Thing 
rdfs:Resource)<br/>t<br/>t<br/>gx-user(9): (subtypep owl:Class owl:Thing) ; note 
that this is incorrect.<br/>nil<br/>t<br/></code><br/>
<p>In this demonstration, after boot up SWCLOS without OWL modules, invoking 
<b>read-rdf-file</b> caused to load owl.rdf file. Some results by reading 
owl.rdf were demonstrated with <b>get-form</b> on owl:Thing and owl:Nothing. 
</p>
<p>However, this ontology does not result any capability upon OWL entailments 
and includes some ambiguities of inclusiveness between the RDF universe and the 
OWL universe. An OWL reasoner must be equipped with OWL semantics so as to 
realize many OWL entailments as well as clear-cut relation between the RDF 
universe and the OWL universe. OWL module of SWCLOS provides OWL functionalities 
with the owl.rdf file. After this section, OWL realization on SWCLOS is 
explained.</p>
<h3 height="30">12.2 &nbsp;Description Logic and OWL in SWCLOS</h3>
<p>The syntax and semantics of Description Logic (DL) is compactly described at 
Appendix of <i>The Description Logic Handbook</i> from Cambridge Press. In this 
section, OWL DL semantics is explained partly using DL terminologies and partly 
using OWL terminologies. Note that the following remarks.</p>
<table align="center" border="1">
  <tbody>
  <tr align="center" bgcolor="#ccffff">
    <td>Terminologies in DL</td>
    <td>Description in S-expression of SWCLOS</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>concept</td>
    <td><i>class</i></td></tr>
  <tr bgcolor="#ffffff">
    <td>role</td>
    <td><i>property</i></td></tr>
  <tr bgcolor="#e5e5e5">
    <td>top concept</td>
    <td>owl:Thing</td></tr>
  <tr bgcolor="#ffffff">
    <td>bottom concept</td>
    <td>owl:Nothing</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>concept inclusion</td>
    <td>(owl:Class <i>C</i> (rdfs:subClassOf <i>D</i>))</td></tr>
  <tr bgcolor="#ffffff">
    <td>concept equality</td>
    <td>(owl:Class <i>C</i> (owl:equivalentClass <i>D</i>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>role inclusion</td>
    <td>(rdf:Property <i>R</i> (rdfs:subPropertyOf <i>S</i>))</td></tr>
  <tr bgcolor="#ffffff">
    <td>role equality</td>
    <td>(rdf:Property <i>R</i> (owl:equivalentProperty <i>S</i>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>intersection of concepts</td>
    <td>(owl:intersectionOf <i>C</i><sub>1</sub> ... <i>C</i><sub><i>n</i></sub>)</td></tr>
  <tr bgcolor="#ffffff">
    <td>union of concepts</td>
    <td>(owl:unionOf <i>C</i><sub>1</sub> ... <i>C</i><sub><i>n</i></sub>)</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>negation of concepts</td>
    <td>(owl:complementOf <i>C</i>)</td></tr>
  <tr bgcolor="#ffffff">
    <td>value restriction</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:allValuesFrom 
      <i>C</i>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>limited existential quantification</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:someValuesFrom 
      owl:Thing))</td></tr>
  <tr bgcolor="#ffffff">
    <td>full existential quantification</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:someValuesFrom 
      <i>C</i>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>at-least number restriction</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:minCardinality 
      <i>n</i>))</td></tr>
  <tr bgcolor="#ffffff">
    <td>at-most number restriction</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:maxCardinality 
      <i>n</i>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>exact number restriction</td>
    <td>(owl:Restriction (owl:onPropertyOf <i>R</i>) (owl:cardinality 
      <i>n</i>))</td></tr>
  <tr bgcolor="#ffffff">
    <td>same-as agreement</td>
    <td>(owl:Thing <i>u</i><sub>1</sub> (owl:sameAs <i>u</i><sub>2</sub>))</td></tr>
  <tr bgcolor="#e5e5e5">
    <td>one-of</td>
    <td>(owl:Thing (owl:oneOf <i>I</i><sub>1</sub> ... <i>I</i><sub><i>n</i></sub>))</td></tr></tbody></table>
<p><a id="SWCLOSdefResource" name="SWCLOSdefResource"/>
To define a concept in OWL, <b>defConcept</b> is used instead of 
<b>defResource</b> in RDFS. However, both macros generate completely same forms. 
The purpose of &lsquo;<b>defConcept</b>&rsquo; macro is just syntax sugar for OWL. See the 
following example after loading OWL module, where the concept Woman and Man are 
defined. In addition, an anonymous class that stands for the concept of negation 
of Woman, is defined. Since the negation of Woman represents a set of all 
individuals of Man, the concept Man is defined as the intersection of Person and 
the negation of Woman. The following demonstration also shows the entailment of 
intersection of concepts. </p>
<code style="font-size:8pt">gx-user(7): (defConcept 
Woman (owl:intersectionOf Person Female))<br/>Warning: Range entailX3 by 
owl:intersectionOf: Person rdf:type owl:Class.<br/>Warning: Range entailX3 by 
owl:intersectionOf: Female rdf:type owl:Class.<br/>#&lt;owl:Class 
Woman&gt;<br/>gx-user(8): (defConcept 
Man<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Class 
(owl:complementOf Woman))))<br/>#&lt;owl:Class Man&gt;<br/>gx-user(9): 
(defIndividual John_Doe (rdf:type Man))<br/>#&lt;Man John_Doe&gt;<br/>gx-user(10): 
(defIndividual Jane_Doe (rdf:type Woman))<br/>#&lt;Woman 
Jane_Doe&gt;<br/>gx-user(11): (typep John_Doe Female)<br/>nil<br/>t<br/>gx-user(12): 
(typep Jane_Doe Female)<br/>t<br/>t<br/></code><br/>
<p>The concept that is not defined but referred is called <i>atomic concept</i>, 
e.g., Person and Female in the above demonstration, while a <i>complex 
concept</i> is defined using other concepts (complex or atomic), e.g., Woman and 
Man. The atomic concept in SWCLOS exists as object but does not have slot values 
except rdfs:subClassOf and owl:equivalentClass. </p>
<h3 height="30">12.3 &nbsp;OWL Property Restrictions</h3>
<p>A complex concept is often composed of concepts and restrictions. A 
restriction, which is an instance of owl:Restriction, works as constraint for a 
specific property and a specific concept. A property restriction is anonymous 
and has only two slots of owl:onPropertyOf and restriction types, i.e., 
owl:allValuesFrom, owl:someValuesFrom, owl:hasValue, owl:maxCardinality, 
owl:minCardinality, and owl:cardinality.</p>
<p>In the following example, the concept Mother is defined as the intersection 
of Woman and the restriction such that the property hasChild must exist in Woman 
individuals and one value of the property hasChild must be an instance of Person 
at least.</p>
<code style="font-size:8pt">gx-user(13): (defConcept 
Mother<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Woman<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction 
(owl:onProperty hasChild)<br/>(owl:someValuesFrom Person))))<br/>Warning: Range 
entailX3 by owl:onProperty: hasChild rdf:type rdf:Property.<br/>#&lt;owl:Class 
Mother&gt;<br/>gx-user(14): (defConcept Father 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Man<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction 
(owl:onProperty 
hasChild)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:someValuesFrom 
Person))))<br/>#&lt;owl:Class Father&gt;<br/></code><br/>
<p>The property restriction in the intersection is useful to make a sub concept 
that is specialized by the property restriction. In the above case, the concept 
Mother is defined as Woman who has the slot hasChild, in which one slot value at 
least must be an instance of a Person. Exactly speaking on the above 
demonstration, it is possible to have something but Person in the hasChild slot 
in the above definition. Note that it is needed to add the value restriction 
(owl:allValuesFrom) on hasChild for Person, if you want to restrict that all of 
children must be a Person, exactly in OWL semantics.</p>
<p>Note that owl:Restriction in OWL is specialized to subclass restrictions in 
SWCLOS, i.e., owl:hasValueRestriction, owl:someValuesFromRestriction, 
owl:allValuesFromRestriction, or owl:cardinalityRestriction. The reason is 
mainly for human readability of an anonymous object of owl:Restriction. Using 
this subclassing of owl:Restriction, SWCLOS provides the customization of 
printing restrictions. See the followings.</p>
<blockquote><code style="font-size:8pt">gx-user(15): (-&gt; Father 
  owl:intersectionOf)<br/>(#&lt;owl:Class Man&gt; 
  #&lt;ÅŒhasChild.Person&gt;)<br/></code></blockquote><br/>
<p>In CLOS, we have the type option in the slot definition. Therefore, we have 
implemented the allValuesFrom functionality and the someValuesFrom functionality 
through this type option in the slot definition as well as the range value 
constraint in RDFS. Furthermore, in order to implement the cardinality 
constraint, we set two new slot option, <b>maxcardinality</b> and 
<b>mincardinality</b> in the slot definition as 
<b>OwlProperty-slot-definition</b>. </p>
<h3 height="30">12.4 &nbsp;Substantial and non-Substantial Relationship</h3>
<p>Whereas the subsumption relationship is decided with only rdfs:subClassOf in 
RDFS, the subsumption decidability is very complicated in OWL. There are many 
properties that rule subsumption, such as rdfs:subClassOf, owl:intersectionOf, 
owl:unionOf, owl:equivalentClass, owl:equivalentProperty on rdf:type, 
rdfs:subPropertyOf on rdf:type, etc. From the viewpoint of DL, they have same 
strength for subsumption decidability. However, from the viewpoint of Ontology 
Engineering, generally we have to discriminate substantial ones and 
non-substantial ones for subsumption. For instance, the wife and husband 
relation is weaker than man-person or woman-person relation. The former is not 
substantial but the latter is substantial.</p>
<p>On the other hand, from the viewpoint of CLOS, rdfs:subClassOf relation is 
mapped onto class-subclass relation, and a CLOS object as rdfs:subClassOf 
property value is also placed in the direct-superclasses list slot in the class 
metaobject. Then, in case that a property <i>prop1</i> is a subproperty of 
rdfs:subClassOf, or a equivalent property of rdfs:subClassOf, whether or not 
should we place the property value into the direct-superclasses list in the 
class to which the property <i>prop1</i> is attached? In other words, what 
property should cause the structural variation in CLOS superclass-subclass 
relation, and what property should not cause the structural variation? For 
instance, food:Wine is equivalent to vin:Wine, and food:Wine in Food Ontology 
does not have any slots, and vin:Wine in Wine Ontology has many slots. If we add 
vin:Wine into the direct-superclasses list of food:Wine, then food:Wine inherits 
all slot definitions in the superclasses of vin:Wine. So, should we put the same 
slots as vin:Wine to food:Wine or not? In SWCLOS, we specified that 
rdfs:subClassOf, owl:intersectionOf, and owl:unionOf should cause the structural 
variation of CLOS, but other properties such as owl:equivalentClass, 
owl:equivalentProperty, including subproperties and equivalent properties of 
rdfs:subClass, owl:intersectionOf, and owl:unionOf, should not cause the 
structural variation. The predicate <b>gx:subtypep</b> supports the subsumption 
by class-subclass relation in RDFS semantics, and <b>subsumed-p</b> reasons the 
subsumption using other subsumption-related properties in OWL.</p>
<p>From the standpoint of ontology engineering, the effects of substantial 
properties may propagate to other entities, but the result of non-substantial 
properties should not cause any side effects in ontology. Thus, such 
discrimination rule of substantial and non-substantial subsumption allows ones 
to add and delete the relation of rdfs:subPropertyOf, owl:equivalentClass, etc., 
and keeps easy to maintain ontologies.</p>
<h3 height="30">12.5 &nbsp;Axiomatic Complete Relations</h3>
<p>Among many properties in OWL, only four properties, i.e., owl:intersectionOf, 
owl:unionOf, owl:complementOf, and owl:oneOf make axiomatic complete relations 
as <i>if and only if</i> condition. In other words, these properties define 
complete equivalency upon the binary relation of concepts. For example, the 
following states the definition of WhiteBordeaux, and if something is a Bordeaux 
and WhiteWine, it should be concluded to be a WhiteBordeaux.</p>
<code style="font-size:8pt">gx-user(2): (defpackage vin) <br/>#&lt;The vin package&gt; <br/>gx-user(3): 
(defConcept vin::WhiteBordeaux <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type owl:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf 
vin::Bordeaux vin::WhiteWine))<br/>Warning: Range entailX3 by owl:intersectionOf: 
vin::Bordeaux rdf:type owl:Class.<br/>Warning: Range entailX3 by 
owl:intersectionOf: vin::WhiteWine rdf:type owl:Class.<br/>#&lt;owl:Class 
vin:WhiteBordeaux&gt;<br/>gx-user(4): (defIndividual aWine (rdf:type vin:Bordeaux 
vin:WhiteWine))<br/>Warning: Multiple classing 
with<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#&lt;owl:Class 
vin:Bordeaux&gt; #&lt;owl:Class 
vin:WhiteWine&gt;)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for 
#&lt;vin:Bordeaux aWine&gt;<br/>#&lt;vin:WhiteBordeaux 
aWine&gt;<br/></code><br/>
<p>Similarly, the following assertion defines WineColor, which has the 
enumerative membership of White, Rose, and Red of complete relation, so that it 
states that the instance of WineColor is exactly one of the three, and not to be 
the others.</p>
<code style="font-size:8pt">gx-user(5): (defConcept vin::WineColor 
(rdf:type 
owl:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:oneOf 
vin::White vin::Rose vin::Red))<br/>#&lt;owl:Class 
vin:WineColor&gt;<br/>gx-user(6): vin:White<br/>#&lt;vin:WineColor 
vin:White&gt;<br/></code><br/>
<p>Therefore, it is not necessary to mind Open World Assumption upon such 
axiomatic complete relation properties. If we find the contents of the 
definition body matches the database, then we may conclude the definition is 
applicable to the database without a worry about other statements.</p>
<p>See the following example. SWCLOS concludes that QueenElizabethII should be a 
woman, because there is a terminology that a person who has gender female is a 
woman, and it is asserted that QueenElizabethII is an instance of Person and 
hasGender Female. Here, note that SWCLOS proactively made the entailment without 
demand or query from users.</p>
<code style="font-size:8pt">gx-user(2): (defConcept 
Person (rdf:type 
owl:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Human<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction 
(owl:onProperty 
hasGender)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:cardinality 
1))))<br/>Warning: Range entailX3 by owl:intersectionOf: Human rdf:type 
owl:Class.<br/>Warning: Range entailX3 by owl:onProperty: hasGender rdf:type 
rdf:Property.<br/>#&lt;owl:Class Person&gt;<br/>gx-user(3): (defConcept Woman 
(rdf:type 
owl:Class)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:intersectionOf<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Person<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction 
(owl:onProperty 
hasGender)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValue 
Female))))<br/>#&lt;owl:Class Woman&gt;<br/>gx-user(4): (defIndividual 
QueenElizabethII (rdf:type 
Person)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(hasGender 
Female))<br/>Warning: Entailed in refining: #&lt;Person QueenElizabethII&gt; to 
Woman.<br/>#&lt;Woman QueenElizabethII&gt;<br/></code><br/>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>13. &nbsp;OWL Axioms and Entailment Rules </h2>
<h3 height="30">13.1 &nbsp;OWL Axioms </h3>
<p>The OWL vocabulary is defined in the <a 
href="http://www.w3.org/2002/07/owl.rdf">OWL definition file</a>. The 
contents are listed in the table below. In the table, the namespace &lsquo;owl&rsquo; at 
QNames is omitted. &lsquo;Resource&rsquo; stands for rdfs:Resource, and &lsquo;Property&rsquo; stands 
for rdf:Property. &lsquo;type&rsquo; stands for rdf:type. &lsquo;subPropertyOf&rsquo; stands for 
rdfs:subPropertyOf. &lsquo;domain&rsquo; and &lsquo;range&rsquo; stand for rdfs:domain and rdfs:range. 
&lsquo;List&rsquo; stands for rdf:List.</p>
<table align="center">
  <tbody>
  <tr>
    <td><b>Table 13.1 &nbsp;The OWL Axioms </b></td></tr></tbody></table>
<table align="center" border="1">
  <tbody>
  <tr bgcolor="#ccffff">
    <th>OWL Axioms in http://www.w3.org/2002/07/owl.rdf</th></tr>
  <tr>
    <td>(rdfs:Class Class (subClassOf rdfs:Class)) </td></tr>
  <tr>
    <td>(Class Thing (unionOf Nothing (complementOf Nothing))) </td></tr>
  <tr>
    <td>(Class Nothing (complementOf Thing)) </td></tr>
  <tr>
    <td>(Property equivalentClass (subPropertyOf subClassOf) (domain Class) 
      (range Class)) </td></tr>
  <tr>
    <td>(Property disjointWith (domain Class) (range Class)) </td></tr>
  <tr>
    <td>(Property equivalentProperty (subPropertyOf subPropertyOf)) </td></tr>
  <tr>
    <td>(Property sameAs (domain Thing) (range Thing)) </td></tr>
  <tr>
    <td>(Property differentFrom (domain Thing) (range Thing)) </td></tr>
  <tr>
    <td>(rdfs:Class AllDifferent) </td></tr>
  <tr>
    <td>(Property distinctMembers (domain AllDifferent) (range List)) </td></tr>
  <tr>
    <td>(Property unionOf (domain Class) (range List)) </td></tr>
  <tr>
    <td>(Property intersectionOf (domain Class) (range List)) </td></tr>
  <tr>
    <td>(Property complementOf (domain Class) (range Class)) </td></tr>
  <tr>
    <td>(Property oneOf (domain Class) (range List)) </td></tr>
  <tr>
    <td>(rdfs:Class Restriction (subClassOf Class)) </td></tr>
  <tr>
    <td>(Property onProperty (domain Restriction) (range Property)) </td></tr>
  <tr>
    <td>(Property allValuesFrom (domain Restriction) (range Class)) </td></tr>
  <tr>
    <td>(Property hasValue (domain Restriction)) </td></tr>
  <tr>
    <td>(Property someValuesFrom (domain Restriction) (range Class)) </td></tr>
  <tr>
    <td>(Property minCardinality (domain Restriction) (range 
      xsd:nonNegativeInteger)) </td></tr>
  <tr>
    <td>(Property maxCardinality (domain Restriction) (range 
      xsd:nonNegativeInteger)) </td></tr>
  <tr>
    <td>(Property cardinality (domain Restriction) (range 
      xsd:nonNegativeInteger)) </td></tr>
  <tr>
    <td>(rdfs:Class ObjectProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(rdfs:Class DatatypeProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(Property inverseOf (domain ObjectProperty) (range ObjectProperty)) 
  </td></tr>
  <tr>
    <td>(rdfs:Class TransitiveProperty (subClassOf ObjectProperty)) </td></tr>
  <tr>
    <td>(rdfs:Class SymmetricProperty (subClassOf ObjectProperty)) </td></tr>
  <tr>
    <td>(rdfs:Class FunctionalProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(rdfs:Class InverseFunctionalProperty (subClassOf ObjectProperty)) 
  </td></tr>
  <tr>
    <td>(rdfs:Class AnnotationProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(AnnotationProperty rdfs:label) </td></tr>
  <tr>
    <td>(AnnotationProperty rdfs:comment) </td></tr>
  <tr>
    <td>(AnnotationProperty rdfs:seeAlso) </td></tr>
  <tr>
    <td>(AnnotationProperty rdfs:isDefinedBy) </td></tr>
  <tr>
    <td>(rdfs:Class Ontology) </td></tr>
  <tr>
    <td>(rdfs:Class OntologyProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(Property imports (type OntologyProperty) (domain Ontology) (range 
      Ontology)) </td></tr>
  <tr>
    <td>(Property versionInfo (type AnnotationProperty)) </td></tr>
  <tr>
    <td>(Property priorVersion (type OntologyProperty) (domain Ontology) 
      (range Ontology)) </td></tr>
  <tr>
    <td>(Property backwardCompatibleWith 
      <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(type 
      OntologyProperty) (domain Ontology) (range Ontology)) </td></tr>
  <tr>
    <td>(Property incompatibleWith (type OntologyProperty) (domain Ontology) 
      (range Ontology)) </td></tr>
  <tr>
    <td>(rdfs:Class DeprecatedClass (subClassOf rdfs:Class)) </td></tr>
  <tr>
    <td>(rdfs:Class DeprecatedProperty (subClassOf Property)) </td></tr>
  <tr>
    <td>(rdfs:Class DataRange) </td></tr></tbody></table>
<p>However, this is not enough to reason OWL semantics. We have added two axioms 
to the above definitions in SWCLOS, as follows.</p>
<table align="center">
  <tbody>
  <tr>
    <td><b>Table 13.2 &nbsp;Additional Axioms </b></td></tr></tbody></table>
<table align="center" border=1>
  <tbody>
  <tr bgcolor="#ccffff">
    <th>name</th>
    <th>Additional OWL Axioms</th></tr>
  <tr>
    <td><b>axiom1</b></td>
    <td>(Class Thing (subClassOf Resource))</td></tr>
  <tr>
    <td><b>axiom2</b></td>
    <td>(rdfs:Class Class (subClassOf Thing))</td></tr></tbody></table>
<p><b>Axiom1</b> enables owl:Thing to inherit slot definitions from 
rdfs:Resource instances, i.e., rdfs:label, rdfs:comment, etc. <b>Axiom2</b> is 
crucial to treat OWL classes as individual. Namely, it enables OWL classes to 
have slots for instances of owl:Thing, i.e., owl:sameAs, owl:differentFrom, 
etc.</p>
<h3 height="30">13.2 &nbsp;OWL Semantics and Entailment Rules </h3>
<p>To realize OWL semantics as an extension of RDFS, we developed the OWL module 
that is loaded after RDFS modules in SWCLOS. The OWL module reads up the <a 
href="http://www.w3.org/2002/07/owl.rdf">the OWL definition file</a>, and 
defines many functions that implement the OWL entailment rules on top of 
RDFS/RDF semantics. In this section, such entailment rules are explained.</p>
<p>The complete set of entailment rules in OWL is unknown. Table 13.3 shows 
entailment rules in OWL which is disclosed by ter Horst <a 
href="http://www.springerlink.com/content/366474250nl35412/">[Horst]</a>. These 
rules are realized in OWL module. In addition, we have implemented some extra 
entailment rules shown in Table 13.4</p>
<table align="center">
  <tbody>
  <tr>
    <td><b>Table 13.3 &nbsp;Entailment Rules by ter Horst <a 
      href="http://www.springerlink.com/content/366474250nl35412/">[Horst]</a></b></td></tr></tbody></table>
<table align="center" border=1>
  <tbody>
  <tr bgcolor="#ccffff">
    <td><b>name</b></td>
    <td><b>If</b></td>
    <td><b>Then</b></td>
    <td><b>note</b></td></tr>
  <tr>
    <td><b>rdfp1</b></td>
    <td><i>p</i> type FunctionalProperty .<br/><i>u p v .</i><br/><i>u p w 
    .</i></td>
    <td><i>v</i> sameAs <i>w</i> .</td>
    <td>functional property</td></tr>
  <tr>
    <td><b>rdfp2</b></td>
    <td><i>p</i> type InverseFunctionalProperty .<br/><i>u p w .</i><br/><i>v p w 
      .</i></td>
    <td><i>u</i> sameAs <i>v</i> .
    <td>inverse functional property</td></td></tr>
  <tr>
    <td><b>rdfp3</b></td>
    <td><i>p</i> type SymmetricProperty .<br/><i>v p w .</i></td>
    <td><i>w p v .</i></td>
    <td>symmetric property</td></tr>
  <tr>
    <td><b>rdfp4</b></td>
    <td><i>p</i> type TransitiveProperty .<br/><i>u p v .</i><br/><i>v p w 
    .</i></td>
    <td><i>u p w .</i></td>
    <td>transitive property</td></tr>
  <tr>
    <td><b>rdfp5a</b></td>
    <td><i>v p w .</i></td>
    <td><i>v</i> sameAs <i>v</i> .</td>
    <td rowspan="2">self-evident sameAs</td></tr>
  <tr>
    <td><b>rdfp5b</b></td>
    <td><i>v p w .</i></td>
    <td><i>w</i> sameAs <i>w</i> .</td></tr>
  <tr>
    <td><b>rdfp6</b></td>
    <td><i>v</i> sameAs <i>w</i> .</td>
    <td><i>w</i> sameAs <i>v</i> .</td>
    <td>reflexive sameAs</td></tr>
  <tr>
    <td><b>rdfp7</b></td>
    <td><i>u</i> sameAs <i>v</i> .<br/><i>v</i> sameAs <i>w</i> .</td>
    <td><i>u</i> sameAs <i>w</i> .</td>
    <td>transitive sameAs</td></tr>
  <tr>
    <td><b>rdfp8ax</b></td>
    <td><i>p</i> inverseOf <i>q</i> .<br/><i>v p w .</i></td>
    <td><i>w q v .</i> </td>
    <td rowspan="2">inverse of property</td></tr>
  <tr>
    <td><b>rdfp8bx</b></td>
    <td><i>p</i> inverseOf <i>q</i> .<br/><i>v q w .</i></td>
    <td><i>w p v .</i> </td></tr>
  <tr>
    <td><b>rdfp9</b></td>
    <td><i>v</i> type Class .<br/><i>v</i> sameAs <i>w</i> . </td>
    <td><i>v</i> subClassOf <i>w</i> .</td>
    <td>subsumption on <br/>same classes</td></tr>
  <tr>
    <td><b>rdfp10</b></td>
    <td><i>p</i> type Property .<br/><i>p</i> sameAs <i>q</i> .</td>
    <td><i>p</i> subPropertyOf <i>q</i> .</td>
    <td>subsumption <br/>on same properties</td></tr>
  <tr>
    <td><b>rdfp11</b></td>
    <td><i>u p v .</i><br/><i>u</i> sameAs <i>u'</i> .<br/><i>v</i> sameAs 
      <i>v'</i> .</td>
    <td><i>u' p v' .</i></td>
    <td>property extension <br/>through sameAs</td></tr>
  <tr>
    <td><b>rdfp12a</b></td>
    <td><i>v</i> equivalentClass <i>w</i> .</td>
    <td><i>v</i> subClassOf <i>w</i> .</td>
    <td rowspan="2">subsumption on <br/>equivalentClass</td></tr>
  <tr>
    <td><b>rdfp12b</b></td>
    <td><i>v</i> equivalentClass <i>w</i> .</td>
    <td><i>w</i> subClassOf <i>v</i> .</td></tr>
  <tr>
    <td><b>rdfp12c</b></td>
    <td><i>v</i> subClassOf <i>w</i> .<br/><i>w</i> subClassOf <i>v</i> .</td>
    <td><i>v</i> equivalentClass <i>w</i> .</td>
    <td>equivalency from <br/>subsumption classes</td></tr>
  <tr>
    <td><b>rdfp13a</b></td>
    <td><i>v</i> equivalentPropety <i>w</i> .</td>
    <td><i>v</i> subPropertyOf <i>w</i> .</td>
    <td rowspan="2">subsumption on <br/>equivalent property</td></tr>
  <tr>
    <td><b>rdfp13b</b></td>
    <td><i>v</i> equivalentPropety <i>w</i> .</td>
    <td><i>w</i> subPropertyOf <i>v</i> .</td></tr>
  <tr>
    <td><b>rdfp13c</b></td>
    <td><i>v</i> subPropertyOf <i>w</i> .<br/><i>w</i> subPropertyOf <i>v</i> 
    .</td>
    <td><i>v</i> equivalentProperty <i>w</i> .</td>
    <td>equivalency from <br/>subsumption properties</td></tr>
  <tr>
    <td><b>rdfp14a</b></td>
    <td><i>v</i> hasValue <i>w</i> .<br/><i>v</i> onProperty <i>p</i> .<br/><i>u 
      p w</i> .</td>
    <td><i>u</i> type <i>v</i> .</td>
    <td>filler restriction entailment</td></tr>
  <tr>
    <td><b>rdfp14bx</b></td>
    <td><i>v</i> hasValue <i>w</i> .<br/><i>v</i> onProperty <i>p</i> 
      .<br/><i>u</i> type <i>v</i> .</td>
    <td><i>u p w</i> .</td>
    <td>hasValue definition</td></tr>
  <tr>
    <td><b>rdfp15</b></td>
    <td><i>v</i> someValuesFrom <i>w</i> .<br/><i>v</i> onProperty <i>p</i> 
      .<br/><i>u p x</i> .<br/><i>x</i> type <i>w</i> .</td>
    <td><i>u</i> type <i>v</i> .</td>
    <td>full existential <br/>restriction entailment</td></tr>
  <tr>
    <td><b>rdfp16</b></td>
    <td><i>v</i> allValuesFrom <i>w</i> .<br/><i>v</i> onProperty <i>p</i> 
      .<br/><i>u</i> type <i>v</i> .<br/><i>u p x</i> .</td>
    <td><i>x</i> type <i>w</i> .</td>
    <td>allvaluesfrom definition</td></tr></tbody></table>
<p>The <b>rule1a</b> and <b>rule1b</b> is an alternative of <a 
href="http://www.w3.org/TR/rdf-mt/#rulerdfs4"><b>rdfs4a</b> and 
<b>rdfs4b</b></a> in the W3C RDF Semantics document. The other rules are 
explained in the next succeeding sub-subsections.</p>
<table align="center">
  <tbody>
  <tr>
    <td><b>Table 13.4 &nbsp;Additional Entailment Rules </b></td></tr></tbody></table>
<table align="center" border="1">
  <tbody>
  <tr bgcolor="#ccffff">
    <td><b>name </b></td>
    <td><b>If</b></td>
    <td><b>Then</b></td>
    <td><b>note</b></td></tr>
  <tr>
    <td><b>rule1a</b></td>
    <td><i>v p w</i> .</td>
    <td>v type Thing .</td>
    <td rowspan="2">default top in OWL</td></tr>
  <tr>
    <td><b>rule1b</b></td>
    <td><i>v p w</i> .</td>
    <td>w type Thing .</td></tr>
  <tr>
    <td><b>rule2a</b></td>
    <td><i>u</i> intersectionOf { <i>v</i> ... } .</td>
    <td><i>v</i> type Class .</td>
    <td rowspan="2">default metaclass for <br/>intersection and union list</td></tr>
  <tr>
    <td><b>rule2b</b></td>
    <td><i>u</i> unionOf { <i>v</i> ... } .</td>
    <td><i>v</i> type Class .</td></tr>
  <tr>
    <td><b>rule3</b></td>
    <td><i>u</i> distinctMembers {<i>v</i> ... } .</td>
    <td><i>v</i> type Thing .</td>
    <td>default class for distincts</td></tr>
  <tr>
    <td><b>rule4</b></td>
    <td><i>u</i> disjointWith <i>v</i> .<br/><i>u'</i> subClassOf <i>u</i> 
      .<br/><i>v'</i> subClassOf <i>v</i> .</td>
    <td><i>u'</i> disjointWith <i>v'</i> .</td>
    <td>permeation of disjointness</td></tr>
  <tr>
    <td><b>rule5</b></td>
    <td><i>u</i> complementOf <i>v</i> .</td>
    <td><i>v</i> complementOf <i>u</i> .</td>
    <td>reflexive complementOf .</td></tr>
  <tr>
    <td><b>rule6</b></td>
    <td><i>u</i> complementOf <i>v</i> .</td>
    <td><i>u</i> disjointWith <i>v</i> .</td>
    <td>disjoint complementOf .</td></tr>
  <tr>
    <td><b>rule7</b></td>
    <td><i>u</i> oneOf { <i>x</i> ... } .</td>
    <td><i>x</i> type <i>u</i> .</td>
    <td>oneOf entailment</td></tr>
  <tr>
    <td><b>rule8</b></td>
    <td><i>p</i> type SymmetricProperty .<br/><i>p</i> domain <i>C</i> 
      .<br/><i>p</i> range <i>D</i> .</td>
    <td><i>C</i> equivalentClass <i>D</i> .</td>
    <td>domain/range equivalency <br/>by SymmetricProperty</td></tr>
  <tr>
    <td><b>rule9</b></td>
    <td><i>p</i> equivalentProperty <i>q</i> .</td>
    <td><i>q</i> equivalentProperty <i>p</i> .</td>
    <td>reflexive equivalentProperty</td></tr>
  <tr>
    <td><b>rule10</b></td>
    <td><i>p</i> equivalentProperty <i>q</i> .<br/><i>q</i> equivalentProperty 
      <i>r</i> .</td>
    <td><i>p</i> equivalentProperty <i>r</i> .</td>
    <td>transitive equivalentProperty</td></tr>
  <tr>
    <td><b>rule11a</b></td>
    <td><i>p</i> equivalentProperty <i>q</i> .<br/><i>p</i> domain <i>u</i> 
.</td>
    <td><i>q</i> domain <i>u</i> .</td>
    <td>domain by equivalentProperty</td></tr>
  <tr>
    <td><b>rule11b</b></td>
    <td><i>p</i> equivalentProperty <i>q</i> .<br/><i>p</i> range <i>u</i> .</td>
    <td><i>q</i> range <i>u</i> .</td>
    <td>range by equivalentProperty</td></tr>
  <tr>
    <td><b>rule12a</b></td>
    <td><i>p</i> inverseOf <i>q</i> .<br/><i>p</i> domain <i>u</i> .</td>
    <td><i>q</i> domain <i>u</i> .</td>
    <td>domain by inverseOf</td></tr>
  <tr>
    <td><b>rule12b</b></td>
    <td><i>p</i> inverseOf <i>q</i> .<br/><i>p</i> range <i>u</i> .</td>
    <td><i>q</i> range <i>u</i> .</td>
    <td>range by inverseOf</td></tr>
  <tr>
    <td><b>rule13</b></td>
    <td><i>x</i> differentFrom <i>y</i> .</td>
    <td><i>y</i> differentFrom <i>x</i> .</td>
    <td>reflexive differentFrom</td></tr>
  <tr>
    <td><b>rule14</b></td>
    <td><i>u</i> intersectionOf { <i>v</i> <i>w</i> } .<br/><i>x</i> type 
      <i>v</i> .<br/><i>x</i> type <i>w</i> .</td>
    <td><i>x</i> type <i>u</i> .</td>
    <td>intersection entailment</td></tr></tbody></table>
<p>In the case of no interpretation for a set of input assertions, it is called 
clash or unsatisfiable. We summarized unsatisfiability conditions in <b>Table 
13.5</b>.</p>
<table align="center">
  <tbody>
  <tr>
    <td><b>Table 13.5 &nbsp;Unsatisfiability Rules </b></td></tr></tbody></table>
<table align="center" border=1>
  <tbody>
  <tr bgcolor="#ccffff">
    <th>name </th>
    <th>Unsatisfiable Conditions</th></tr>
  <tr>
    <td><b>oneof-condition-unsatisfiable</b></td>
    <td><i>u</i> oneOf { <i>x</i><sub>i</sub> ... } .<br/><i>y</i> type <i>u</i> 
      .<br/><i>y</i> differentFrom <i>x</i><sub>i</sub> . ( 1 &le; <i>i</i> &le; <i></i>n )</td></tr>
  <tr>
    <td><b>sameas-condition-unsatisfiable</b> 
      or<br/><b>differentfrom-condition-unsatisfiable</b></td>
    <td><i>x</i> sameAs <i>y</i> .<br/><i>x</i> differentFrom <i>y</i> .</td></tr>
  <tr>
    <td><b>disjointwith-condition-unsatisfiable</b> 
      or<br/><b>equivalentclass-condition-unsatisfiable</b></td>
    <td><i>u</i> disjointWith <i>v</i> .<br/><i>u</i> equivalentOf <i>v</i> 
  .</td></tr>
  <tr>
    <td><b>disjoint-instances-condition-unsatisfiable</b></td>
    <td><i>u</i> disjointWith <i>v</i> .<br/><i>x</i> type <i>u</i> 
      .<br/><i>x</i> type <i>v</i> .</td></tr>
  <tr>
    <td><b>domain-condition-unsatisfiable</b></td>
    <td><i>u</i> disjointWith <i>v</i> .<br/><i>x</i> domain <i>u</i> 
      .<br/><i>x</i> domain <i>v</i> .</td></tr>
  <tr>
    <td><b>range-condition-unsatisfiable</b></td>
    <td><i>u</i> disjointWith <i>v</i> .<br/><i>x</i> range <i>u</i> 
      .<br/><i>x</i> range <i>v</i> .</td></tr>
  <tr>
    <td><b>complementof-condition-unsatiafiable</b></td>
    <td><i>u</i> complementOf <i>v</i> .<br/><i>x</i> type <i>u</i> 
      .<br/><i>x</i> type <i>v</i> .</td></tr></tbody></table>
<h4>13.2.1 &nbsp;Intersection of Concepts (owl:intersectionOf) </h4>
<p>The intersection of concepts is represented by owl:intersectionOf property in 
OWL. In Wine Ontology, DryRedWine is defined as an intersection of DryWine and 
RedWine. Figure 13.1 shows the concept intersection of DryWine and RedWine. The 
class DryWine stands for a set of DryWine individuals and the class RedWine 
stands for a set of RedWine individuals. So, the class DryRedWine represents an 
intersection of the two sets of individuals. Therefore, the class DryRedWine 
turns a subclass of DryWine class and RedWine class. </p>
<code style="font-size:8pt">gx-user(11): (get-form vin:DryRedWine)<br/>(owl:Class 
vin:DryRedWine (owl:intersectionOf vin:DryWine vin:RedWine))<br/>gx-user(12): 
(subtypep vin:DryRedWine vin:DryWine)<br/>t<br/>t<br/>gx-user(13): (subtypep 
vin:DryRedWine vin:RedWine)<br/>t<br/>t<br/></code><br/>
<p align="center"><img alt="Intersection of DryWine and RedWine" 
src="FIGURES/intersectionOf.bmp" border="0"/> </p>
<p align="center"><a id="figure13.1" name="figure13.1"><b>Figure 13.1 
Intersection of DryWine and RedWine </b></a></p>
<p>In SWCLOS, the values of owl:intersectionOf slot are automatically placed 
into the class-direct-superclasses list of subjective class metaobject. In the 
above example, vin:DryWine and vin:RedWine are placed into the 
class-direct-superclasses list of vin:DryRedWine.</p>
<p>The range of owl:intersectionOf is defined as rdf:List in the axioms. Then, 
we added <b>rule2a</b> for the member element of collection on 
owl:intersectionOf.</p>
<p>As described at Section 12.5, owl:intersectionOf is complete in definition. 
Therefore, if something is known as an individual of DryWine and RedWine, then 
it is concluded that the thing is an individual of DryRedWine. See <b>rule14</b> 
and the following demonstration.</p>
<blockquote><code style="font-size:8pt">gx(14): (defIndividual MyWine (rdf:type 
  vin:DryWine))<br/>#&lt;vin:DryWine MyWine&gt;<br/>gx(15): (defIndividual MyWine 
  (rdf:type vin:RedWine))<br/>#&lt;vin:DryRedWine 
MyWine&gt;<br/></code></blockquote><br/>
<h4>13.2.2 &nbsp;Union of Concepts (owl:unionOf) </h4>
<p>Contrary to the intersection, the union of concepts makes subclasses of union 
members. See <b>Fig. 13.2</b>, where Fruit is defined as union of SweetFruit and 
NonSweetFruit in Food Ontology. Note that if food:SweetFruit is disjoint with 
food:NonSweetFruit, there is no overlapping portion. So, <b>Fig. 13.2</b> should 
be redrawn.</p>&lt;
<code style="font-size:8pt">gx-user(15): (get-form 
food:Fruit)<br/>(owl:Class food:Fruit (owl:unionOf food:SweetFruit 
food:NonSweetFruit))<br/>gx-user(16): (subtypep food:SweetFruit 
food:Fruit)<br/>t<br/>t<br/>gx-user(17): (subtypep food:NonSweetFruit 
food:Fruit)<br/>t<br/>t<br/></code><br/>
<p align="center"><img alt="Union of SweetFruit and NonSweetFruit" 
src="FIGURES/unionOf.bmp" border="0"/> </p>
<p align="center"><a id="figure13.2" name="figure13.2"><b>Figure 13.2 
Union of SweetFruit and NonSweetFruit </b><br/>There is no overlap exactly, when 
SweetFruit and NonSweetFruit are disjoint. </a></p>
<p>In SWCLOS, the subjective class metaobject is automatically placed into the 
class-direct-superclasses of each class in the values of property owl:unionOf. 
In the example above, food:Fruit is placed into the class-direct-superclasses 
list of food:SweetFruit and food:NonSweetFruit.</p>
<p>As well as owl:intersectionOf, we added <b>rule2b</b> for the element of the 
collection on owl:unionOf.</p>
<h4>13.2.3 &nbsp;Negation of Concept(owl:complementOf) </h4>
<p>The negation of a concept stands for all individuals in the universe with the 
exception of the individuals of the concept. The owl:complementOf is a reflexive 
relation. Namely, if a concept <i>C</i> is a negation of concept <i>D</i>, then 
<i>D</i> is also a negation of <i>C</i>. See <b>rule5</b> in Table 13.4. In 
SWCLOS, the inverse relation of negation is also registered into the negated 
class object.</p>
<p>Furthermore, a concept is disjoint with its negation. See <b>rule6</b>. In 
SWCLOS, the negation results to register the disjoint relation each other in 
both concept objects.</p>
<code style="font-size:8pt">gx-user(4): (get-form 
food:NonConsumableThing)<br/>(owl:Class food:NonConsumableThing (owl:complementOf 
food:ConsumableThing))<br/>gx-user(5): (defConcept 
food::PlasticSample<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:subClassOf 
food:NonConsumableThing))<br/>#&lt;rdfs:Class 
food:PlasticSample&gt;<br/>gx-user(6): (defIndividual 
food::PlasticChineseNoodle<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
food::PlasticSample))<br/>#&lt;food:PlasticSample 
food:PlasticChineseNoodle&gt;<br/>gx-user(7): (typep food::PlasticChineseNoodle 
food:ConsumableThing)<br/>nil<br/>t<br/>gx-user(8): (typep 
food::PlasticChineseNoodle food:EdibleThing)<br/>nil<br/>t<br/>gx-user(9): 
(disjoint-p food::PlasticSample food:EdibleThing)<br/>t<br/>t<br/></code><br/>
<h4>13.2.4 &nbsp;Instance Enumeration for Concept(owl:oneOf) </h4>
<p>Using owl:oneOf, a concept may be defined as the enumeration of individuals. 
For example, WineColor is defined as a subclass of WineDescriptor and a concept 
whose individuals are only Red, White, and Rose. See <b>rule7</b> in Table 13.4. 
</p><code style="font-size:8pt">gx-user(2): (defpackage vin)<br/>#&lt;The vin 
package&gt;<br/>gx-user(3): (defConcept 
vin::WineColor<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:subClassOf 
vin::WineDescriptor)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:oneOf 
vin::Red vin::Rose vin::White))<br/>Warning: Range entailX1 by 
rdfs:subClassOf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vin::WineDescriptor 
rdf:type rdfs:Class.<br/>#&lt;rdfs:Class vin:WineColor&gt;<br/>gx-user(4): 
vin:Red<br/>#&lt;vin:WineColor vin:Red&gt;<br/>gx-user(5): 
vin:Rose<br/>#&lt;vin:WineColor vin:Rose&gt;<br/>gx-user(6): 
vin:White<br/>#&lt;vin:WineColor vin:White&gt;<br/>gx-user(7): (typep vin:Red 
vin:WineDescriptor)<br/>t<br/>t<br/></code><br/>
<p>The definition of owl:oneOf is also the complete definition. So, typically 
the subject of owl:oneOf should be defined just once and not be multiply 
defined. However, in this version the multiple definition of owl:oneOf can be 
accepted with warning. See the followings. </p><code style="font-size:8pt">gx-user(8): (defConcept vin:WineColor 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:oneOf 
vin:Red vin:Rose Green))<br/>Warning: (#&lt;vin:WineColor Green&gt;) is added to 
owl:oneOf value 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#&lt;vin:WineColor 
vin:Red&gt; #&lt;vin:WineColor vin:Rose&gt; 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;vin:WineColor 
vin:White&gt;) of #&lt;rdfs:Class vin:WineColor&gt;.<br/>#&lt;rdfs:Class 
vin:WineColor&gt;<br/></code><br/>
<p>If the same members are enumerated in multiple definitions, it is accepted 
and does not cause any effect. If the disjoint members are enumerated, SWCLOS 
signals an alarm. See <b>oneof-condition-unsatisfiable</b> in Table 13.5.</p>
<h4>13.2.5 &nbsp;Functional Property(owl:FunctionalProperty) </h4>
<p>An instance of owl:FunctionalProperty entails that objects in triples are the 
same, if the subjects in triples are the same. See the rule <b>rdfp1</b> in 
Table 13.3 that is by ter Horst.</p><code style="font-size:8pt">gx-user(5): 
(defProperty hasband (rdf:type 
owl:ObjectProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
owl:FunctionalProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
Woman)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
Man))<br/>Warning: Range entailX3 by rdfs:domain: Woman rdf:type 
rdfs:Class.<br/>Warning: Range entailX3 by rdfs:range: Man rdf:type 
rdfs:Class.<br/>Warning: Multiple classing 
with<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#&lt;rdfs:Class 
owl:ObjectProperty&gt;<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;rdfs:Class 
owl:FunctionalProperty&gt;) 
for<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;owl:ObjectProperty 
hasband&gt;<br/>#&lt;owl:ObjectProperty.0 hasband&gt;<br/>gx-user(6): 
(defIndividual MarieTherese (hasband LouisXIVdeFrance))<br/>Warning: Range 
entailX3 by hasband: LouisXIVdeFrance rdf:type Man.<br/>#&lt;Woman 
MarieTherese&gt;<br/>gx-user(7): (defIndividual MarieTherese (hasband 
Roi-Soleil))<br/>Warning: Range entailX3 by hasband: Roi-Soleil rdf:type 
Man.<br/>#&lt;Woman MarieTherese&gt;<br/>gx-user(8): (-&gt; MarieTherese 
hasband)<br/>(#&lt;Man Roi-Soleil&gt; #&lt;Man 
LouisXIVdeFrance&gt;)<br/>gx-user(9): (owl-same-p LouisXIVdeFrance 
Roi-Soleil)<br/>t<br/></code><br/>
<p>In SWCLOS, the inverse of owl:FunctionalProperty is registered to the object, 
and the predicate <b>owl-same-p</b> and <b>equivalent-property-p</b> use the 
registered information.</p>
<h4>13.2.6 &nbsp;Inverse Functional Property(owl:InverseFunctionalProperty) 
</h4>
<p>An instance of owl:InverseFunctionalProperty entails that subjects in triples 
are the same, if the objects in triples are the same. See the rule <b>rdfp2</b> 
in Table 13.3. </p>
<p>As well as owl:FunctionalProperty, the inverse of 
owl:InverseFunctionalProperty is registered to the object, and the predicate 
<b>owl-same-p</b> and <b>equivalent-property-p</b> use the registered 
information.</p><code style="font-size:8pt">gx-user(2): (defProperty hasWife 
(rdf:type 
owl:ObjectProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
owl:InverseFunctionalProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
Man)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
Woman))<br/>Warning: Range entailX3 by rdfs:domain: Man rdf:type 
rdfs:Class.<br/>Warning: Range entailX3 by rdfs:range: Woman rdf:type 
rdfs:Class.<br/>#&lt;owl:InverseFunctionalProperty hasWife&gt;<br/>gx-user(3): 
(defIndividual Bill (hasWife Hillary))<br/>Warning: Range entailX3 by hasWife: 
Hillary rdf:type Woman.<br/>#&lt;Man Bill&gt;<br/>gx-user(4): (defIndividual 
42ndPresident (hasWife Hillary))<br/>#&lt;Man 42ndPresident&gt;<br/>gx-user(5): 
(owl-same-p Bill 42ndPresident)<br/>t<br/></code><br/>
<h4>13.2.7 &nbsp;Symmetric Property(owl:SymmetricProperty) </h4>
<p>An instance of owl:SymmetricProperty entails the reflexive relation of 
subject and object in triple. See the rule <b>rdfp3</b> in Table 13.3. </p>
<p>In SWCLOS, the reflexive relation of symmetric property is automatically 
added into memory. Namely, the subject in triple is added to the role value of 
the object's predicate.</p><code style="font-size:8pt">gx-user(2): (defpackage 
vin)<br/>#&lt;The vin package&gt;<br/>gx-user(3): (defProperty vin::adjacentRegion 
(rdf:type 
owl:ObjectProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
owl:SymmetricProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
vin::Region)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
vin::Region))<br/>Warning: Range entailX3 by rdfs:domain: vin::Region rdf:type 
rdfs:Class.<br/>Warning: #&lt;rdfs:Class vin:Region&gt; rdf:type 
owl:Class<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;by 
owl:SymmetricProperty entailment.<br/>#&lt;owl:SymmetricProperty 
vin:adjacentRegion&gt;<br/>gx-user(4): (defIndividual vin::MendocinRegion 
(rdf:type 
vin:Region)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin::locatedIn 
vin::CaliforniaRegion)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin:adjacentRegion 
vin::SonomaRegion))<br/>Warning: Entail by rdf1: vin::locatedIn rdf:type 
rdf:Property.<br/>Warning: Range entailX3 by vin:adjacentRegion: 
<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vin::SonomaRegion 
rdf:type vin:Region.<br/>#&lt;vin:Region vin:MendocinRegion&gt;<br/>gx-user(5): 
(slot-value vin:MendocinRegion 'vin:adjacentRegion)<br/>#&lt;vin:Region 
vin:SonomaRegion&gt;<br/>gx-user(6): (slot-value vin:SonomaRegion 
'vin:adjacentRegion)<br/>#&lt;vin:Region 
vin:MendocinRegion&gt;<br/></code><br/>
<h4>13.2.8 &nbsp;Transitive Property(owl:TransitiveProperty) </h4>
<p>An instance of owl:TransitiveProperty entails the transitivity upon the 
property. For example, vin:SonomaRegion is located in vin:CaliforniaRegion and 
vin:CaliforniaRegion is located in vin:USRegion, then vin:SonomaRegion is 
located in vin:USRegion. See the rule <b>rdfp4</b> in Table 13.3. </p>
<p>In SWCLOS, the transitivity is unified to the subsumption notion. The 
predicate <b>subsumed-p</b> is also effect to the transitivity relation. See the 
following demonstration, after loading Wine Ontology.</p>
<code style="font-size:8pt">gx-user(7): (defProperty vin:locatedIn (rdf:type 
owl:ObjectProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdf:type 
owl:TransitiveProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:domain 
owl:Thing)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(rdfs:range 
vin:Region))<br/>#&lt;owl:TransitiveProperty vin:locatedIn&gt;<br/>gx-user(8): 
(defIndividual 
vin::SantaCruzMountainsRegion<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin:locatedIn 
vin::CaliforniaRegion))<br/>Warning: Range entailX4 by 
vin:locatedIn:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&lt;|rdfs:Resource| 
vin:CaliforniaRegion&gt; rdf:type vin:Region.<br/>#&lt;owl:Thing 
vin:SantaCruzMountainsRegion&gt;<br/>gx-user(9): (defIndividual 
vin:CaliforniaRegion (rdf:type 
vin:Region)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin:locatedIn 
vin::USRegion))<br/>Warning: Range entailX3 by vin:locatedIn: vin::USRegion 
rdf:type vin:Region.<br/>#&lt;vin:Region vin:CaliforniaRegion&gt;<br/>gx-user(10): 
(subsumed-p vin::SantaCruzMountainsRegion 
vin:USRegion)<br/>t<br/>t<br/></code><br/>
<h4>13.2.9 &nbsp;Equivalency for Individuals(owl:sameAs) </h4>
<p>The property owl:sameAs is used to represent the equivalency of two 
individuals. In OWL Full, the class can be also captured as individual. 
Therefore, it is applicable to classes. See the rule <b>rdfp5</b>, <b>rdfp6</b>, 
<b>rdfp7</b>, and <b>rdfp9</b>, <b>rdfp10</b>, <b>rdfp11</b> in Table 13.3. In 
Semantic Webs, we do not stand on Unique Name Assumption, which is usually taken 
in computer languages. Namely, two different URIs may denote the same thing or 
may not. The statement of owl:sameAs means the two URIs can be captured as the 
same thing.</p>
<p>The relation of owl:sameAs is reflexive and transitive. It implies that 
owl:sameAs makes groups among related entities. In SWCLOS, all members of a 
group are registered to each member object. The predicate <b>owl-same-p</b> uses 
this registered information to check whether two objects are the same or not. 
See the following demonstration, after loading Wine Ontology.</p>
<blockquote><code style="font-size:8pt">gx-user(4): (owl-same-p food:Red 
  vin:Red)<br/>t<br/>gx-user(5): (owl-same-p vin:Red 
food:Red)<br/>t<br/></code></blockquote><br/>
<h4>13.2.10 &nbsp;Difference for Individuals(owl:differentFrom) </h4>
<p>The property owl:differentFrom is used to denote the difference of two 
individuals. In OWL Full, the class is also captured as individual. Therefore, 
it is applicable to classes. In non-Unique Name Assumption of Semantic Webs, two 
different URIs may be the same through owl:sameAs statements. Contrary, 
owl:differentFrom states that two URIs are different and cannot be captured as 
the same thing.</p>
<p>The relation of owl:differentFrom is pairwise and reflexive. See <b>rule7</b> 
in Table 13.4. In SWCLOS, each object has the information of difference on the 
object. The owl:differentFrom property and owl:AllDifferent statements create 
this information. The predicate <b>owl-different-p</b> uses this information. 
See the following demonstration for Wine Ontology.</p>
<blockquote><code style="font-size:8pt">gx-user(17): (owl-different-p vin:Dry 
  vin:OffDry)<br/>t<br/>t<br/>gx-user(18): (owl-different-p vin:OffDry 
  vin:Dry)<br/>t<br/>t<br/>gx-user(19): (owl-different-p vin:DAnjou 
  vin:Cotturi)<br/>t<br/>t<br/>gx-user(20): (owl-different-p vin:Cotturi 
  vin:DAnjou)<br/>t<br/>t<br/></code></blockquote><br/>
<h4>13.2.11 &nbsp;Inverse Relation of Property(owl:inverseOf) </h4>
<p>owl:inverseOf takes two object properties as subject and object in triple, 
and defines the two is in the inverse relation. See <b>rdfp8ax</b> and 
<b>rdfp8bx</b> in Table 13.3.</p>
<p>SWCLOS provides two slot value accessors, '<b>-&gt;</b>' and <b>get-value</b> 
that facilitate getting slot value(s) through owl:inverseOf 
functionality.</p><code style="font-size:8pt">gx-user(8): (defProperty hasChild 
(rdf:type 
owl:ObjectProperty)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:inverseOf 
hasParent))<br/>Warning: Range entailX3 by 
owl:inverseOf:<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hasParent 
rdf:type owl:ObjectProperty.<br/>#&lt;owl:ObjectProperty 
hasChild&gt;<br/>gx-user(9): (defIndividual LeopoldMozart (rdf:type 
Musician)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(hasChild 
AmadeusMozart))<br/>Warning: Range entail by rdf:type: Musician rdf:type 
rdfs:Class.<br/>#&lt;Musician LeopoldMozart&gt;<br/>gx-user(10): (-&gt; 
AmadeusMozart hasParent)<br/>#&lt;Musician LeopoldMozart&gt;<br/></code><br/>
<h4>13.2.12 &nbsp;Equivalency for Classes(owl:equivalentClass) </h4>
<p>The property owl:equivalentClass is used to represent the equivalency of two 
classes as class. Namely, the equivalent classes share exactly the same set of 
individuals. See the rule <b>rdfp12</b>.</p><code style="font-size:8pt">gx-user(14): 
(get-form food:Wine)<br/>(owl:Class food:Wine (owl:equivalentClass 
vin:Wine))<br/>gx-user(15): (owl-equivalent-p food:Wine 
vin:Wine)<br/>t<br/></code><br/>
<h4>13.2.13 &nbsp;Difference for Classes(owl:disjointWith) </h4>
<p>The property owl:disjointWith is used to represent the difference of two 
classes as class. Namely two classes never share any individual as a member of 
class. If two classes are disjoint, then each subclasses of the classes also 
disjoint. See <b>rule7</b> in Table 13.4. </p>
<code style="font-size:8pt">gx-user(18): (get-form food:NonSweetFruit)<br/>(owl:Class 
food:NonSweetFruit<br/>&nbsp;&nbsp;(rdf:about<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/TR/2003/PR-owl-guide-20031209/food#NonSweetFruit&gt;)<br/>&nbsp;&nbsp;(rdfs:subClassOf 
food:EdibleThing) (owl:disjointWith food:SweetFruit))<br/>gx-user(19): 
(disjoint-p food:SweetFruit food:NonSweetFruit)<br/>t<br/>t<br/></code><br/>
<h4>13.2.14 &nbsp;Value Restriction(owl:allValuesFrom) </h4>
<p>The value restriction plays a role of constraint for the instance slot value. 
See <b>rdfp16</b> in Table 13.3. SWCLOS entails that a filler that is restricted 
by owl:allValuesFrom should be an instance of the constraint.</p>
<code style="font-size:8pt">gx-user(2): (get-form vin:Wine)<br/>(owl:Class 
vin:Wine<br/>&nbsp;&nbsp;(rdf:about<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/TR/2003/PR-owl-guide-20031209/wine#Wine&gt;)<br/>&nbsp;&nbsp;(rdfs:label 
(:en "wine") (:fr "vin"))<br/>&nbsp;&nbsp;(rdfs:subClassOf 
food:PotableLiquid<br/>&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction (owl:onProperty 
vin:hasMaker)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:cardinality 
"1"^^xsd:nonNegativeInteger))<br/>&nbsp;&nbsp;(owl:Restriction (owl:onProperty 
vin:hasMaker)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:allValuesFrom 
vin:Winery))<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:Restriction 
(owl:onProperty 
vin:locatedIn)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:someValuesFrom 
vin:Region))))<br/>gx-user(3): (defIndividual MyHomeMadeWine (rdf:type 
vin:Wine)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(vin:hasMaker 
MyHome))<br/>#&lt;vin:Wine MyHomeMadeWine&gt;<br/>gx-user(4): 
MyHome<br/>#&lt;vin:Winery MyHome&gt;<br/></code><br/>
<h4>13.2.15 &nbsp;Full Existential Restriction(owl:someValuesFrom) </h4>
<p>On the other hand, the full existential restriction, <b>rdfp15</b> in Table 
13.3, does not entail anything useful results about the filler type in rigorous 
Open Word Assumption. We cannot conclude unsatisfiability even if an individual 
does not have the restricted filler on the role of the full existential 
quantification, because there may be a piece of such knowledge anywhere in the 
Web World. Moreover, the filler whose type is different from one that is 
directed for the filler is acceptable. However, we set a frag to switch between 
Open World Assumption and Closed World Assumption, and then it is set to Closed 
World Assumption as default. This advanced topic is described in one of Japanese 
papers and Phd. thesis.</p>
<p>Note that we can conclude unsatisfiability for the value restriction 
(owl:allValuesFrom), if an individual has a role of the value restriction and 
one of the values does not satisfy the restriction, even in the open world. 
However, you should note on owl:allValuesFrom that an individual that has no 
slots on the value restriction property is also satisfiable for the directed 
class. </p>
<h4>13.2.16 &nbsp;Filler Restriction(owl:hasValue) </h4>
<p>The hasValue restriction directs for individuals to have at least one 
designated value (not class restriction) as slot value. It is rephrased that if 
a concept has a filler restriction on a role, the individuals must have the same 
filler on the role at least one. However, this involves the same problem for 
rigorous Open World Assumption as the full existential restriction mentioned 
above. Moreover, this implies the same entailment for the subject entity as the 
full existential restriction mentioned above, for the constraint of filler 
itself instead of filler class. See <b>rdfp14bx</b> and <b>rdfp14a</b> in Table 
13.3.</p>
<code style="font-size:8pt">gx-user(2): (get-form 
vin:TableWine)<br/>(owl:Class 
vin:TableWine<br/>&nbsp;&nbsp;(rdf:about<br/>&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.w3.org/TR/2003/PR-owl-guide-20031209/wine#TableWine&gt;)<br/>&nbsp;&nbsp;(owl:intersectionOf 
vin:Wine<br/>&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValueRestriction (owl:onProperty 
vin:hasSugar)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValue 
vin:Dry))))<br/>gx-user(3): (get-form vin:DryWine)<br/>(owl:Class 
vin:DryWine<br/>&nbsp;&nbsp;(owl:intersectionOf 
vin:Wine<br/>&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValueRestriction (owl:onProperty 
vin:hasSugar)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValue 
vin:Dry))))<br/>gx-user(4): (get-form 
vin:MariettaOldVinesRed)<br/>(vin:RedTableWine 
vin:MariettaOldVinesRed<br/>&nbsp;&nbsp;(vin:hasMaker 
vin:Marietta)<br/>&nbsp;&nbsp;(vin:hasFlavor 
vin:Moderate)<br/>&nbsp;&nbsp;(vin:hasBody 
vin:Medium)<br/>&nbsp;&nbsp;(vin:locatedIn 
vin:SonomaRegion)<br/>&nbsp;&nbsp;(vin:hasColor 
vin:Red)<br/>&nbsp;&nbsp;(vin:hasSugar vin:Dry))<br/>gx-user(5): (typep 
vin:MariettaOldVinesRed vin:TableWine)<br/>t<br/>t<br/>gx-user(6): (typep 
vin:MariettaOldVinesRed vin:DryWine)<br/>t<br/>t<br/></code><br/>
<p>In this demonstration, DryWine and TableWine is defined to have the filler 
restriction of Dry, and MariettaOldVinesRed has a filler Dry for role hasSugar, 
then SWCLOS can conclude it is a TableWine and a DryWine, too. </p>
<p>We would like to claim that correct but harsh treatment often tends to 
produce no results. Rigorous Open Word Assumption will often not produce useful 
results. You may make your owl rule for the full existential quantification and 
make a balance between Open World Assumption vs. Closed World Assumption. For 
example, you might want to close the world around you when you felt making an 
ontology completed, and you might want to check the unsatisfiability of the full 
existential quantification. We say that it is a sort of auto-epistemic logic. 
The latest SWCLOS provides such pedantic function, but it should be discussed 
later as a more advanced topic.</p>
<p align="center"><img alt="chapter end" src="FIGURES/ornament.gif" border="0" /></p>
<mbp:pagebreak/>

<h2>14. &nbsp;OWL APIs </h2>
<h3 height="30">14.1 &nbsp;Subsumption in OWL </h3>
<p>We discriminate the substantial inclusiveness on concepts that is decided 
through rdfs:subClassOf, owl:intersectionOf, and owl:unionOf, against the 
non-substantial inclusiveness, that can be reasoned out by entailment rules and 
a subsumption inference engine. The former is calculated through the CLOS 
class-subclass relationship, and the latter is deduced by the subsumption 
algorithm described below in SWCLOS. The top concept in the OWL universe, 
owl:Thing, substantially subsumes every concept of OWL vocabulary in the CLOS 
class-subclass relation or OWL reasoning, but the bottom concept, owl:Nothing, 
is virtually subsumed by other concepts only through this algorithm. We extended 
and modified the basic structural subsumption algorithm, that is described in 
&ldquo;The Description Logic Handbook&rdquo; [DLH], to one that contains disjunction 
(owl:unionOf), negation (owl:complementOf), equivalency (owl:sameAs and 
owl:equivalentOf), functional and inverse-functional relation 
(owl:FunctionalProperty and owl:InverseFunctionalProperty), symetric relation 
(owl:SymmetricProperty), the value restriction (owl:allValuesFrom), the full 
existential restriction (owl:someValuesFrom), the filler restriction 
(owl:hasValue), and the number restriction (owl:maxCardinality, 
owl:minCardinality, and owl:cardinality).</p>
<p>The algorithm is summarized as follows, for two concepts <i>C</i> and 
<i>D</i>; </p>
<ol type="1">
  <li>If <i>C</i> is the bottom, then it returns true. </li>
  <li>If <i>D</i> is the top, then it returns true. </li>
  <li>If <i>D</i> is the bottom, then it returns false. </li>
  <li>If <i>C</i> is a subclass of <i>D</i> in CLOS, then it returns true.</i> </li>
  <li>If <i>D</i> is a subclass of <i>C</i> in CLOS, then it returns false.</i> </li>
  <li>If <i>C</i> and <i>D</i> is the same as individual, then it returns true. </li>
  <li>If <i>C</i> and <i>D</i> have oneOf slots and <i>C</i>Åfs members are 
  subset of <i>D</i>Åfs members, then it returns true, otherwise false. </li>
  <li>For some (<i>cc</i>) of equivalent classes of <i>C</i> and some 
  (<i>dd</i>) of equivalent classes of <i>D</i>; 
  <ul>
    <li>If <i>cc</i> is a subclass of <i>dd</i> in CLOS, then it returns true. </li>
    <li>If <i>dd</i> is a subclass of <i>cc</i> in CLOS, then it returns false. </li>
    <li>If <i>cc</i> has unionOf slot values and every member is subsumed by 
    <i>dd</i>, then it returns true. </li>
    <li>If <i>dd</i> has unionOf slot values and <i>cc</i> is subsumed by some 
    of union members of <i>dd</i>, then it returns true. This process is called 
    <i>union branching</i>. </li>
    <li>If <i>dd</i> has intersectionOf slot values, then the algorithm for 
    intersection is performed. See the below. </li>
    <li>If <i>cc</i> and <i>dd</i> is equal through owl:equivalentClass, 
    owl:FunctionalProperty, or owl:InversefunctionalProperty, then it returns 
    true. </li>
    <li>If <i>cc</i> and <i>dd</i> are complement, then it returns false. </li>
    <li>If <i>cc</i> and <i>dd</i> are disjoint, then it returns false. </li>
    <li>Otherwise go to the next step below for transtivity checking as 
    individuals. </li></ul></li>
  <li>For some (<i>cc</i>) of same individuals of <i>C</i> and some (<i>dd</i>) 
  of same individuals of <i>D</i>; 
  <ul>
    <li>If <i>cc</i> and <i>dd</i> shares a transitive property and <i>cc</i> is 
    inferior to <i>dd</i> on the property, then return true. </li></ul></li></ol>
<p>The algorithm for intersections is summarized as follows.</p>
<ol type="1">
  <li>Firstly, <i>D</i> is unfolded on the intersection of concepts. Namely, if 
  an element of intersections is also the concept of intersections, all members 
  of the intersection are retrieved and the flattened list of all intersection 
  elements is made. </li>
  <li>Secondly, <i>C</i>&rsquo;s class precedence list (cpl), that is, a list of all 
  super concepts of <i>C</i> including itself is computed. </li>
  <li>If every concept member (except property restrictions) of intersections of 
  unfolded <i>D</i> subsumes some concept member of <i>C</i>&rsquo;s cpl, then go to 
  the next step, otherwise false. </li>
  <li>If no restrictions of unfolded <i>D</i>, then returns true. Otherwise, go 
  to the next step, namely model generation and testing process. </li>
  <li>Generate possible models of <i>C</i> and every models are checked if some 
  of them satisfy the <i>D</i>&rsquo;s restrictions. 
  <ul>
    <li>Firstly, all slot definitions of <i>C</i> for RDF and OWL properties are 
    retrieved. </li>
    <li>For each of restrictions of unfolded <i>D</i>, the following steps are 
    performed, and every step must be true, otherwise imediately returns with 
    false. 
    <ul>
      <li type="circle">In case of no slot definition of <i>C</i> and no 
      cardinality restriction of <i>D</i>, if <i>D</i>&rsquo;s restriction is 
      allValuesFrom, then true, else if someValuesFrom or hasValue, then returns 
      false in <b>auto-epistemic-closed-world</b> or true in open world. </li>
      <li type="circle">In case that there is no slot definition of <i>C</i> and 
      cardinality restriction of <i>D</i> exists, </li>
      <li type="circle">In case that both <i>C</i>&rsquo;s slot and <i>D</i>&rsquo;s 
      restriction exists, possible models of <i>C</i> are created from 
      <i>C</i>&rsquo;s slot definition of the current property under the cardinality 
      restriction from <i>D</i>, and possible models of <i>D</i> are also 
      created. Then, some of <i>C</i>&rsquo;s models satisfy every <i>D</i>&rsquo;s models, 
      then true, otherwise returns false. </li></ul></li></ul></li></ol>
<p>The algorithm of generation models and typed unification theory, which is 
used in model matching, is more complicated and difficult for beginers of 
SWCLOS. This advanced topic is shown in Phd theses.</p>
<p>The following demonstrates the function of this algorithm. </p>
<code style="font-size:8pt">gx-user(7): (subsumed-p vin:DryWhiteWine 
vin:WhiteNonSweetWine)<br/>t<br/>t<br/>gx-user(8): (get-form 
vin:WhiteNonSweetWine)<br/>(owl:Class 
vin:WhiteNonSweetWine<br/>&nbsp;&nbsp;(owl:intersectionOf 
vin:WhiteWine<br/>&nbsp;&nbsp;&nbsp;&nbsp;(owl:allValuesFromRestriction 
(owl:onProperty 
vin:hasSugar)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:allValuesFrom (OneOf 
(owl:oneOf vin:Dry vin:OffDry))))))<br/>gx-user(9): (get-form 
vin:DryWhiteWine)<br/>(owl:Class 
vin:DryWhiteWine<br/>&nbsp;&nbsp;(owl:intersectionOf vin:DryWine 
vin:WhiteWine))<br/>gx-user(10): (get-form vin:DryWine)<br/>(owl:Class 
vin:DryWine<br/>&nbsp;&nbsp;(owl:intersectionOf 
vin:Wine<br/>&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValueRestriction (owl:onProperty 
vin:hasSugar)<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(owl:hasValue 
vin:Dry))))<br/></code>
<p>
<div class="titlebar">
<div class="defname">subsumed-p <i>C</i> <i>D</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns true if concept <i>C</i>&nbsp; is subsumed by <i>D</i>. 
</div></p>
<h3 height="30">14.2 &nbsp;Membership in OWL </h3>
<p>We extended the membership checking algorithm in OWL and it is implemented to 
<b>gx:typep</b>. The followings demonstrate some membership relations among 
classes and things in OWL after loading Wine Ontology.</p>
<blockquote><code style="font-size:8pt">gx-user(15): (typep vin:ElyseZinfandel 
  vin:Zinfandel)<br/>t<br/>t<br/>gx-user(16): (typep vin:ElyseZinfandel 
  owl:Thing)<br/>t<br/>t<br/>gx-user(17): (owl-thing-p 
  vin:ElyseZinfandel)<br/>t<br/>gx-user(18): (typep vin:Zinfandel 
  owl:Class)<br/>t<br/>t<br/>gx-user(19): (typep vin:Zinfandel 
  owl:Thing)<br/>t<br/>t<br/>gx-user(20): (owl-class-p 
  vin:Zinfandel)<br/>t<br/>gx-user(21): (owl-class-p 
  owl:Class)<br/>nil<br/>gx-user(22): (owl-class-p 
  owl:Restriction)<br/>nil<br/>gx-user(23): (owl-thing-p 
  owl:Class)<br/>nil<br/>gx-user(24): (owl-thing-p 
  owl:Restriction)<br/>nil<br/>gx-user(25): (owl-class-p 
  owl:Thing)<br/>t<br/>gx-user(26): (owl-thing-p owl:Thing)<br/>t<br/>gx-user(27): 
  (owl-class-p owl:Nothing)<br/>t<br/>gx-user(28): (owl-thing-p 
  owl:Nothing)<br/>nil<br/></code></blockquote><br/>
<p>An individual (instance) that is typed to owl:Thing and a concept (class) 
that is typed to owl:Class belong to the OWL universe. However, note that 
owl:Class and owl:Restriction are not members in OWL universe. Also note that 
owl:Thing itself belongs to OWL universe but owl:Nothing does not, even though 
the class of owl:Nothing is owl:Class as well as owl:Thing, because owl:Nothing 
is complement of owl:Thing.</p>
<p>
<div class="titlebar">
<div class="defname">owl-class-p <i>obj</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This is almost same as &lsquo;(cl:typep <i>obj</i> owl:Class)&rsquo; but a 
  little bit faster and concise expression. </div></p>
<p>
<div class="titlebar">
<div class="defname">owl-thing-p <i>obj</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">This is almost same as &lsquo;(cl:typep <i>obj</i> owl:Thing)&rsquo; but a 
  little bit faster and concise expression. </div></p>
<p>
<div class="titlebar">
<div class="defname">typep <i>object</i> <i>type</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">tests the membership of object to type in the semantics of OWL. 
</div></p>
<h3 height="30">14.3 &nbsp;The Most Specific Concepts </h3>
<p>Computing the most specific concepts in a set of concepts is basic operation 
in DL and SWCLOS. We use this routine very often in SWCLOS. </p>
<p>
<div class="titlebar">
<div class="defname">most-specific-concepts <i>classes</i></div>
<div class="deftype">[Function]</div></div>
<div class="defdescribe">returns the most specific concepts in RDF(S) and OWL semantics, or 
  classes minus duplicates and superclasses of other classes in <i>classes</i>. 
  This function internally uses <b>subsumed-p</b> and <b>owl-equivalent-p</b>. 
  Note that this function does not check disjointness of classes. 
</div></p>
<h2>References</h2><a id="ReferenceHorst" 
name="ReferenceHorst"/><span class="refhead">[DLH]</span> <span class="refbody">Baader, F., et al. (eds.): 
The Description Logic Handbook, Cambridge, (2003). 
</span><br/><span class="refhead">[Horst]</span> <span class="refbody">ter Horst, H. J.: Combining 
RDF and Part of OWL with Rules: Semantics, Decidability, Complexity. The 
Semantic Web - ISWC2005, pp.668-684, Springer (2005). 
</span><br/><span class="refhead">[Koide04]</span> <span class="refbody">Koide, S., Kawamura, M.: 
SWCLOS: A semantic web processor on common lisp object system. In: 3rd 
International Semantic Web Conference (ISWC2004), Demos. (2004), 
http://iswc2004.semanticweb.org/demos/32/. 
</span><br/><span class="refhead">[Koide05]</span> <span class="refbody">Koide, S., Aasman, J., 
Haflich, S.: OWL vs. object oriented programming. In: Workshop on SemanticWeb 
Enabled Software Engineering (SWESE) at the 4th International Semantic Web 
Conference (ISWC 2005), Galway, Ireland (November 2005), 
http://www.mel.nist.gov/msid/conferences/SWESE/propository/8owl-vs-OOP.rdf. 
</span><br/><span class="refhead">[Koide06]</span> <span class="refbody">Koide, S., Takeda, H.: 
OWL-Full reasoning from an object oriented perspective. In: Asian Semantic Web 
Conf., ASWC2006, Springer (2006) 263?277, 
http://wwwkasm.nii.ac.jp/papers/takeda/06/koide06aswc.pdf. 
</span><br/><span class="refhead">[Koide09]</span> <span class="refbody">Koide, S., Takeda, H.: 
Meta-circularity and mop in common lisp for OWL Full. In: ELW Åf09: Proceedings 
of the 6th European Lisp Workshop, New York, NY, USA, ACM (2009) 28?34. 
</span>