<HTML>
<HEAD>
<TITLE>RDFS System</TITLE> 
<META http-equiv="Content-Type" content="text/html">
<META http-equiv="Content-Style-Type" content="text/css">
<link href="overview.css" rel="stylesheet" type="text/css">
<style type="text/css">
p {
	text-indent: 0;
}
p.justify {
	TEXT-ALIGN: justify
}
body {
	FONT-SIZE: 10pt; BACKGROUND: white; MARGIN-LEFT: 3%; COLOR: black; MARGIN-RIGHT: 3%; FONT-FAMILY: Verdana, Arial, Helvetica, sans-serif; TEXT-ALIGN: justify
}
table {
	BORDER-RIGHT: 0px; FONT-SIZE: 10pt; BORDER-LEFT: 0px; BORDER-BOTTOM: 1px; FONT-FAMILY: Verdana, Arial, sans-serif; BORDER-COLLAPSE: collapse; cellspacing: 0; cellpadding: 0
}
td {
	BORDER-TOP-WIDTH: 0px; PADDING-RIGHT: 5px; PADDING-LEFT: 5px; BORDER-LEFT-WIDTH: 0px; BORDER-LEFT-COLOR: #808080; BORDER-BOTTOM-WIDTH: 1px; BORDER-BOTTOM-COLOR: #808080; PADDING-BOTTOM: 5px; VERTICAL-ALIGN: middle; BORDER-TOP-COLOR: #808080; PADDING-TOP: 5px; BORDER-COLLAPSE: collapse; BORDER-RIGHT-WIDTH: 0px; BORDER-RIGHT-COLOR: #808080; empty-cells: show
}
th {
	BORDER-TOP-WIDTH: 0px; PADDING-RIGHT: 5px; PADDING-LEFT: 5px; BORDER-LEFT-WIDTH: 0px; BORDER-LEFT-COLOR: #808080; BORDER-BOTTOM-WIDTH: 1px; BORDER-BOTTOM-COLOR: #808080; PADDING-BOTTOM: 5px; VERTICAL-ALIGN: middle; BORDER-TOP-COLOR: #808080; PADDING-TOP: 5px; BORDER-COLLAPSE: collapse; BORDER-RIGHT-WIDTH: 0px; BORDER-RIGHT-COLOR: #808080; empty-cells: show
}
.noindent {
	MARGIN-LEFT: -3%; MARGIN-RIGHT: -3%
}
.moreindent {
	MARGIN-LEFT: 3%; MARGIN-RIGHT: 3%
}
.box {
	BORDER-RIGHT: 1px solid; PADDING-RIGHT: 10px; BORDER-TOP: 1px solid; PADDING-LEFT: 10px; PADDING-BOTTOM: 10px; BORDER-LEFT: 1px solid; PADDING-TOP: 10px; BORDER-BOTTOM: 1px solid; BACKGROUND-COLOR: #f0f0f0; page-break-inside: avoid
}
h1.title {
	FONT-WEIGHT: bold; FONT-SIZE: 160%
}
h1 {
	FONT-WEIGHT: bold; FONT-SIZE: 130%
}
h2 {
	FONT-WEIGHT: bold; FONT-SIZE: 105%
}
h3 {
	FONT-WEIGHT: bold; FONT-SIZE: 100%
}
h4 {
	FONT-SIZE: 100%; FONT-STYLE: italic
}
h5 {
	
}
ul {
	LIST-STYLE-TYPE: disc
}
dt {
	FONT-WEIGHT: bold
}
a:link {
	COLOR: rgb(0,0,255)
}
a:hover {
	COLOR: rgb(255,0,0)
}
pre {
	MARGIN-TOP: 1px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 1px; FONT-FAMILY: monospace
}
div.defname {
	FONT-WEIGHT: bold; FLOAT: left; TEXT-ALIGN: left
}
div.deftype {
	TEXT-ALIGN: right
}
div.titlebar {
	PADDING-RIGHT: 0.1em; PADDING-LEFT: 0.1em; PADDING-BOTTOM: 0.1em; PADDING-TOP: 0.1em; BACKGROUND-COLOR: #f0f0f0
}
div.defdescribe {
	MARGIN: 1px 0px 10px 80px; TEXT-ALIGN: justify
}
/* Reference style by Seiji */
.refhead { FONT-WEIGHT: bold }
.refbody { MARGIN-LEFT: 10px }
</style>
</HEAD> 
<BODY bgcolor="#ffffff"> 

<H1>SWCLOS: A Semantic Web Reasoner on CLOS</H1>
<H2>RDFS Subsystem</H2>
<P>
This subsystem provides the tools for the inference in RDFS.
If you want to use NTriple and OWL, load NTriple subsystem and OWL subsystem, respectively.

<P><HR size=3>
<UL>
<LI><A HREF="#RDFS/SlotDef.cl"><B>SlotDef.cl</B></A>  Slot Definition Module
<LI><A HREF="#RDFS/RDFboot.cl"><B>RDFboot.cl</B></A>  Rdf Boot module
<LI><A HREF="#RDFS/GxType.cl"><B>GxType.cl</B></A>  GX Type module
<LI><A HREF="#RDFS/DomainRange.cl"><B>DomainRange.cl</B></A>  Domain and Range module
<LI><A HREF="#RDFS/RdfsObjects.cl"><B>RdfsObjects.cl</B></A>  RDFS Objects module
<LI><A HREF="#RDFS/RdfsKernel.cl"><B>RdfsKernel.cl</B></A>  Rdfs Kernel module
<LI><A HREF="#RDFS/GxForwardRef.cl"><B>GxForwardRef.cl</B></A> 
<LI><A HREF="#RDFS/RdfsCore.cl"><B>RdfsCore.cl</B></A>  Rdfs Core module
<LI><A HREF="#RDFS/gxutils.cl"><B>gxutils.cl</B></A>  GXUtils module
<LI><A HREF="#RDFS/rdfwriter.cl"><B>rdfwriter.cl</B></A>  RDFWriter module
</UL>

<A NAME="RDFS/SlotDef.cl"><HR>
<H2>File <A HREF="../RDFS\SlotDef.cl">RDFS\SlotDef.cl</A></H2></A>
<P>
<H2> Slot Definition Module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright (c) 2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007, 2009 Seiji Koide
<P>
<P><HR WIDTH=80% ALIGN=left><P>
<H2> Slot definitions for SWCLOS</H2>
<P>
 The standard slot definition in CLOS (mop:standard-slot-definition) is also a CLOS object 
 and includes the information for slot creation of instances, i.e., initargs, type, 
 documentation and so on. Hereafter, we call a slot in slot definition object an option of 
 slot. So, we say, for example, the standard slot definition has an initargs option, a type 
 option, and documentation option, and so on. 
<P>
 The slot with respect to rdf property is an instance of <I>Property-direct-slot-definition</I>, 
 which is a specialized class of <I>mop:standard-direct-slot-definition</I>. In addition to CLOS 
 native options, <I>Property-direct-slot-definition</I> has a <I>subject-type</I> option, and the slot 
 with respect to owl specific property is an instance of <I>OwlProperty-direct-slot-definition</I>, 
 which is a specialized class of <I>Property-direct-slot-definition</I>. It has a <I>maxcardinality</I> 
 and a <I>mincardinality</I> option. 
<P>
 The <I>type</I> option of CLOS native options is used as the constraint for the slot value type, 
 and <I>maxcardinality</I> and <I>mincardinality</I> options are used as cardinality constraints for a 
 number of slot values. 
<P>
 The <I>subject-type</I> option in <I>Property-direct-slot-definition</I> is used as a inverse link to a 
 subject class to which the slot definition itself is attached. Note that a 
 <I>subject/predicate/object</I> triple in RDF is realized as instance-object/slot-name/slot-value 
 in CLOS. Thus, the specialized slot-definition <I>Property-effective-slot-definition</I> and 
 <I>OwlProperty-effective-slot-definition</I> in SWCLOS represents a set of triples such that the 
 <I>subject</I> is typed to <I>subject-type</I> and <I>predicate</I> is the same as <I>slot-name</I>. Therefore, 
 all triples <I>subject/predicate/object</I> can be retrieved by collecting all slot values through 
 this inverse link from these slot-definitions using slot-value function. Note that all slot 
 definitions on a property is booked into the property resource objects.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*default-slot-definition-class*"><A HREF="../RDFS\SlotDef.cl"><B>*default-slot-definition-class*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Symbol 'Property-direct-slot-definition' is set to this parameter in RDF. This value is overwritten 
by OWL module. This value directs the default class for slot definition. See 
<I>mop:direct-slot-definition-class</I> method in RDFboot module.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property-direct-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>Property-direct-slot-definition</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines a subject-type option.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property-effective-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>Property-effective-slot-definition</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>An instance of this class has a subject-type option in which a class of 
subject in triple is stored.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owlproperty-direct-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>OwlProperty-direct-slot-definition</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines a max and min cardinality options.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owlproperty-effective-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>OwlProperty-effective-slot-definition</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>An instance of this class has a max and min cardinality options, 
which work as the constraint for settable number of values.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Slot Predicates</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property-direct-slotd-p"><A HREF="../RDFS\SlotDef.cl"><B>property-direct-slotd-p</B></A></A> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>slotd</I> is an instance of Property-direct-slot-definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property-effective-slotd-p"><A HREF="../RDFS\SlotDef.cl"><B>property-effective-slotd-p</B></A></A> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>slotd</I> is an instance of Property-effective-slot-definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-property-direct-slotd-p"><A HREF="../RDFS\SlotDef.cl"><B>owl-property-direct-slotd-p</B></A></A> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>slotd</I> is an instance of OwlProperty-direct-slot-definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-property-effective-slotd-p"><A HREF="../RDFS\SlotDef.cl"><B>owl-property-effective-slotd-p</B></A></A> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>slotd</I> is an instance of OwlProperty-effective-slot-definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-prop-names-from"><A HREF="../RDFS\SlotDef.cl"><B>collect-prop-names-from</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collect direct and inherited property (slot) names on this class and returns a list of them.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> How a Type Value is set in Direct Slot Definition</H2>
<P>
 There are four ways in RDF and two in OWL to suppy the type option in initargs parameter for 
 shared-initialize method of <I>Property-direct-slot-definition</I>, i.e., 
<BR>
<OL>
<LI>When a property is defined with domain constraint, <B>add-direct-slots-to-domain</B> function adds
   a direct slot definition into the domain class. In this case, the range constraint of property 
   is retrieved from the property object and supplied for type option in the slot definition.
   See <B>add-direct-slots-to-domain</B>.
<LI>When an RDF instance or class is newly made or reinitialized, <B>ensure-class-slotds</B> is invoked
   for the class of the object to ensure class slot definitions. In this case, the range constraint 
   of property is retrieved from the property object and supplied for type option in the slot 
   definition. See <B>ensure-class-slotds</B>.
<LI>When change-class is invoked, if the instance to be changed has a slot value and the new class
   has no definition on the slot, the old slot definition is copied into the new class. 
   See <B>change-class</B>:before(rdfs:Resource rdfs:Class). 
<LI>When <B>put-value</B>(rdfs:Resource rdf:Property) is invoked but the subject inherits no slot definition,
   the slot definition is added to the class of subject. See <B>put-value</B>.
<LI>When an instance of owl:allValuesFromRestriction is made or redefined, the constraint is transfered
   into the type option in the slot definition that is attached to the restriction with slot name 
   from onProperty value. See <B>shared-initialize</B>:after(owl:allValuesFromRestriction).
<LI>When an instance of owl:someValuesFromRestriction is made or redefined, the constraint is transfered
   into the type option in the slot definition that is attached to the restriction with slot name 
   from onProperty value. See <B>shared-initialize</B>:after(owl:someValuesFromRestriction).
</OL>
<BR>
<P>
<P>
<H2> How to Compute a Type Value in Effective Slot Definition</H2>
<P>
 See the same comment as above in RDFboot module.
<P>
 Note that rdf property name is also slot definition name, and every property object in CLOS keeps effective 
 slot definition objects for housekeeping. 
 When an effective-slot-definition object is created, the name of slotd is a property name, and this slotd 
 is stored into slotd slot of the property. The following method do it.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:property-effective-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>shared-initialize</B></A></A> <I>(slotd
                                                                                                                                                      Property-effective-slot-definition)</I> <I>slot-names</I> <I>&key</I> <I>(name
                                                                                                                                                                                                                                nil)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When the first definition of <I>slotd</I>, updates the value of slotds slot in the property. Namely, 
   the old relevant slotd in slotds of the property is removed, and this <I>slotd</I> is added into 
   the slotds of the property.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Property Predicates</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property-p"><A HREF="../RDFS\SlotDef.cl"><B>property-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an instance of rdf property.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property?"><A HREF="../RDFS\SlotDef.cl"><B>property?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>name</I> is an rdf property name</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="name:standard-effective-slot-definition"><A HREF="../RDFS\SlotDef.cl"><B>name</B></A></A> <I>(object
                                                                                                                            standard-effective-slot-definition)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns a name of <I>object</I>, if it is named, otherwise nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Slot Definition for owl:oneOf </H2>
<P>
 Note that the slot definition for owl:oneOf is an instance of <I>gx::Property-effective-slot-definition</I>
 rather than <I>OwlProperty-direct-slot-definition</I>. It depends on method <I>mop:direct-slot-definition-class</I> 
 and rdfs:Class.
<P>
 Seiji Koide Sep-04-2009
<P>
<A NAME="RDFS/RDFboot.cl"><HR>
<H2>File <A HREF="../RDFS\RDFboot.cl">RDFS\RDFboot.cl</A></H2></A>
<P>
<H2> Rdf Boot module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright (c) 2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007-2010 Seiji Koide
<P>
<P><HR WIDTH=80% ALIGN=left><P>
 The aim of this file is to establish the complex relation of meta-circularity in RDF 
 incrementally step by step. Loading this file yealds the following hierachical structure 
 at the end.
<PRE><CODE>
                                         ........................
                                         :                      :
                                         :                    rdfsClass
                                         :              ...../..:
                                         :              :   /  ..........
 cl:standard-class -- rdf-node ----------:--------rdfs:Class---:---shadowed-class
                           : :...........:       /      : ::...:
                           :               ...../.......: :
                           :               :   /          :
  cl:standard-object -- gnode --- rdfs:Resource --- rdf:Property

  ---, /  super/sub class relation, the direction of super is right to left.
  ..., :  class/instance relation, the direction of class is upward and left to right.
</CODE></PRE><P>
<P>
 The twisted relation between rdfs:Class and rdfsClass, that is, rdfs:Class is a super 
 class and an instance of rdfsClass produces a trick of (cl:typep rdfs:Class rdfs:Class).
 Note that every method defined at rdfs:Class affects rdfs:Class itself. Therefore, the 
 world is closed by the membership loop of rdfs:Class just like cl:standard-class in CLOS.
<P>
 The twisted relation between rdfs:Resource and rdfs:Class yields semantics of RDFS, that is, 
 (cl:typep rdfs:Resource rdfs:Class) and (cl:typep rdfs:Resource rdfs:Resource).
<P>
 The method <B>class-direct-instances</B>, which maintains direct instances of a class, is 
 inherited to rdfs:Class and rdfsClass. So, subclasses of rdfs:Resource and rdfs:Class, 
 including rdfs:Class itself can hold their instances.
<P>
<H2> First of all, </H2>
 We make skeltons that provide subtyping and metaclassing. 
<P>
<H2> rdfsClass & rdfs:Class</H2>
 rdfsClass is invented in order to realize the rdfs:Class membership loop. Namely, the class of 
 rdfs:Class is rdfs:Class itself in RDF(S) semantics. In SWCLOS rdfs:Class is actually the 
 class of rdfs:Class, because rdfs:Class is a superclass of rdfsClass and rdfsClass is a class of 
 rdfs:Class. Thus, all methods are for instances of rdfs:Class is effective for rdfs:Class itself. 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdfsclass"><A HREF="../RDFS\RDFboot.cl"><B>rdfsClass</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="class"><A HREF="../RDFS\RDFboot.cl"><B>Class</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdfsclass"><A HREF="../RDFS\RDFboot.cl"><B>rdfsClass</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is the proxy of rdfs:Class in order to make the membership loop.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> rdfs:Resource</H2>
 At initial stage of booting, kernel classes are defined without slots to let class-changing easy.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="resource"><A HREF="../RDFS\RDFboot.cl"><B>Resource</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Every resource in RDF(S) universe including classes is an instance of 
rdfs:Resource.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="class"><A HREF="../RDFS\RDFboot.cl"><B>Class</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is rdfs:Class, and it is a class of all classes in RDF(S) universe.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="class"><A HREF="../RDFS\RDFboot.cl"><B>Class</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is rdfs:Class and it is a class of all classes in RDF(S) universe.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="resource"><A HREF="../RDFS\RDFboot.cl"><B>Resource</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdfs:Resource is the top class in the RDF universe, but subclass of gnode actually.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:resource"><A HREF="../RDFS\RDFboot.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                                  Resource)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> OK. The minimal skelton is completed.</H2>
<P>
<P>
<H2> Pseudo class of rdfs:Resource is defined.</H2>
 In order to work around wasteful slot definitions during forward-referencing, we invented a trick 
 of setting pseudo class of rdfs:Resource. If there would be no information on a forward-referenced 
 object, the  object is defined as an instance of |rdfs:Resource| rather than rdfs:Resource. 
 Or else, when a slot would be demanded to a tentatively created object in forward-referencing, 
 it would causes the slot definitions at rdfs:Resource. Then, when a proper definition comes up, 
 the slot definitions would be created at the proper class. As a result, rdfs:Resource would 
 become to have wasteful slot definitions for many objects in the universe. To work around this 
 phenomenum, |rdfs:Resource| is used instead of rdfs:Resource in forward-referencing. 
 |rdfs:Resource| prevents to create wasteful slots at rdfs:Resource instances. 
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdfs:resource"><A HREF="../RDFS\RDFboot.cl"><B>rdfs:Resource</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>|rdfs:Resource| is a pseudo rdfs:Resource in order to work around the slot inheritance of temporal definition.
The rule of rdf4 entails a subject and an object as an instance of rdfs:Resource. However the proactive application of
this rule causes the slot definition inheritance to the instances of rdfs:Class and rdfs:Datatype and amounts to 
wasteful slots in every objects. To cope with this problem, rdf4 treats |rdfs:Resource| metaobject instead of 
rdfs:Resource.</TD>
</TR></TBODY></TABLE></DIV> 
<BR>
<H2> Then, we proceed slot definitions.</H2>
<P>
<P>
 <I>mop:direct-slot-definition-class</I> returns a direct slot definition class for target class. 
 This method is customized to return an appropriate slot definition class in SWCLOS, i.e., 
 <I>Property-direct-slot-definition</I> or <I>OwlProperty-direct-slot-definition</I>. Namely, if an 
 indicator in initargs is not a keyword, it must be a property name. The name of rdf, rdfs, 
 and owl propertes are embeded in this routine. In other case, if the domain includes 'owl:Restriction', 
 then Property-direct-slot-definition is returned. If the property is an instance of 'owl:ObjectProperty', 
 then OwlProperty-direct-slot-definition is returned, else if the defalut value is returned.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="direct-slot-definition-class:class"><A HREF="../RDFS\RDFboot.cl"><B>direct-slot-definition-class</B></A></A> <I>(class
                                                                                                                                               Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>If <I>initargs</I> include non-keyword indicators for slot initarg or include a property name as slot name, 
    then returns Property-direct-slot-definition or OwlProperty-direct-slot-definition metaobject.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> How to Compute a Type Value in Effective Slot Definition</H2>
<P>
 Since the function of gx:subtypep in RDF is the same as that of cl:subtypep, the 
 computation of type option in <I>compute-effective-slot-definition-initargs</I> for excl::std-class is 
 also useful for the effective slot definition for rdf properties. Note that the ACL original 
 algorithm for type value collection collects the type value in direct-slot-definitions at every 
 superclass of the target class, and makes the conjunction of them. See the following example.
<PRE><CODE>
 (defclass C1 () ((s :type cl:number)))
 (defclass C2 (C1) ((s :type cl:float)))
 (defclass C3 (C1) ((s :type cl:integer)))
 (defclass C4 (C3) ((s :type cl:fixnum)))
 (defclass C5 (C4 C2) ())
 (mop:slot-definition-type (first (mop:compute-slots (find-class 'C5))))
  -&gt; (and float fixnum)
</CODE></PRE><P>
 This computational result by native routine of ACL is sound, if members of conjunct are not 
 disjoint each other, whereas it might be not minimal expression as conjunction, since ACL does 
 not reduce the result such as conjunctive normal form (CNF). However, if you take care of the 
 disjointness between cl:float and cl:fixnum, then such result will make no sense. In SWCLOS, the 
 notion of disjointness is taken care for not only OWL universe but also RDF universe. In 
 SWCLOS, the clash by disjointness is directed as follows.
<PRE><CODE>
 (defConcept C1 (rdfs:subClassOf (owl:Restriction (owl:onProperty s)
                                    (owl:allValuesFrom xsd:decimal))))
 (defConcept C2 (rdfs:subClassOf (owl:Restriction (owl:onProperty s)
                                    (owl:allValuesFrom xsd:float))))
 (defConcept C3 (rdfs:subClassOf (owl:Restriction (owl:onProperty s)
                                    (owl:allValuesFrom xsd:integer))))
 (defConcept C4 (rdfs:subClassOf (owl:Restriction (owl:onProperty s)
                                    (owl:allValuesFrom xsd:short))))
 (defConcept C5 (rdfs:subClassOf C4 C2))
 (mop:slot-definition-type (car (mop:compute-slots C5)))
 -&gt; Error: Disjoint pair #&lt;forall s xsd:short&gt; and #&lt;forall s xsd:float&gt; found in slot 
    inheritance computation of #&lt;rdfs:Class C5&gt;.
</CODE></PRE><P>
<P>
 In this imlementation of <I>compute-effective-slot-definition-initargs</I> in SWCLOS, 
 we let the native CLOS routine compute the type option. 
 After the computation for CLOS native effective slots definition, the subject-type option is 
 filled with the value of <I>class</I> parameter in <I>compute-effective-slot-definition-initargs</I>.
<BR>
 However, <I>compute-effective-slot-definition-initargs</I> is redefined in OWL module. 
 In OWL system, the satisfiability among conjunctions in type option is checked.  
 See <I>compute-effective-slot-definition-initargs</I> in OWL system.
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="compute-effective-slot-definition-initargs:class"><A HREF="../RDFS\RDFboot.cl"><B>compute-effective-slot-definition-initargs</B></A></A> <I>(class
                                                                                                                                                                           Class)</I> <I>direct-slotds</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>see above</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 If <I>initargs</I> in making an effective-slot-definition includes :subject-type keyword, the slot-definition must be 
 Property-effective-slot-definition. So, <I>mop:effective-slot-definition-class</I> methods returns the class metaobject. 
 Then, CLOS system takes care of all after.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="effective-slot-definition-class:class"><A HREF="../RDFS\RDFboot.cl"><B>effective-slot-definition-class</B></A></A> <I>(class
                                                                                                                                                     Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>see above</TD>
</TR></TBODY></TABLE></DIV> 
<H2> Hierarchy and Relation around Property</H2>
 An rdf property is an instance of rdf:Property. An rdf property as rdf-object has a slot 
 <B>property-slotds</B> for book-keeping, which holds a list of slot definitions on the property 
 (e.g., eslotd1, eslotd2 eslotd3 for rdfs:label, see below). Each slot definition keeps a class of 
 subjective object in subject-type option. Therefore, we can retrieve every triples with 
 respect to a property (called the extension of property). The object in triple is obtained by 
 accessing slot value to the object with the predicate (slot-name) in the triple.
<PRE><CODE>

 rdfs:Resource ---------------------------------- rdf:Property
                                                       :
                                              ex.  rdfs:label
                                                          |
 Property-effective-slot-definition                       | &lt;-- property-slotds
                    :.....................................|....
                                                          |   :
                                                          +-(eslotd1 eslotd2 eslotd3)
                                                                 |
                                                                 | &lt;-- subject-type
                                                                 |
                                                &lt;a class which this eslotd is attached&gt;
</CODE></PRE><P>
<P>
 Note that the domain and range of owl:equivalentProperty is rdf:Property rather than 
 owl:ObjectProperty.
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="property"><A HREF="../RDFS\RDFboot.cl"><B>Property</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>every property in RDF(S) is an instance of rdf:Property. An instance of this class
has a place holder for all related slot definitions.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:property"><A HREF="../RDFS\RDFboot.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                                  Property)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> rdfs:Class final</H2>
 rdfs:Class is reinitialized with slots. 
 I thank smh for teaching me to use 'reinitialize-instance'.
<P>
<H2> rdfs:Datatype </H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="datatype"><A HREF="../RDFS\RDFboot.cl"><B>Datatype</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdfs:Datatype is a subclass of and an instance of rdfs:Class.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> rdfs:Literal & rdf:XMLLiteral</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="literal"><A HREF="../RDFS\RDFboot.cl"><B>Literal</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdfs:Literal is a subclass of rdfs:Resource and an instance of rdfs:Class.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="xmlliteral"><A HREF="../RDFS\RDFboot.cl"><B>XMLLiteral</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:XMLLiteral is a subclass of rdfs:Literal and an instance of rdfs:Datatype.
   An instance has a value of XMLLiteral data.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="value-of:xmlliteral"><A HREF="../RDFS\RDFboot.cl"><B>value-of</B></A></A> <I>(x
                                                                                                            XMLLiteral)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>retrieves a value of XMLLiteral data.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="value-of:t"><A HREF="../RDFS\RDFboot.cl"><B>value-of</B></A></A> <I>x</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>otherwise returns itself.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> rdfs:Resource final</H2>
 rdfs:Resource is reinitialized with slots.
<P>
<H2> rdf:List</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list"><A HREF="../RDFS\RDFboot.cl"><B>List</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:List is a subclass of rdfs:Resource and an instance of rdfs:Class.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> rdf:Property</H2>
 Now, here many properties are defined.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="label"><A HREF="../RDFS\RDFboot.cl"><B>label</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>may be used to provide a human-readable version of a resource's name.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="comment"><A HREF="../RDFS\RDFboot.cl"><B>comment</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>may be used to provide a human-readable description of a resource.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="isdefinedby"><A HREF="../RDFS\RDFboot.cl"><B>isDefinedBy</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to indicate a resource defining the subject resource. 
This property may be used to indicate an RDF vocabulary in which a resource is described.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domain"><A HREF="../RDFS\RDFboot.cl"><B>domain</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state that any resource that has a given property is an instance of one or more classes.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="range"><A HREF="../RDFS\RDFboot.cl"><B>range</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state that the values of a property are instances of one or more classes.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subclassof"><A HREF="../RDFS\RDFboot.cl"><B>subClassOf</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state that all the instances of one class are instances of another.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subpropertyof"><A HREF="../RDFS\RDFboot.cl"><B>subPropertyOf</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD> is used to state that all resources related by one property are also related by another.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 Seiji Koide Nov-15-2010
<P>
<A NAME="RDFS/GxType.cl"><HR>
<H2>File <A HREF="../RDFS\GxType.cl">RDFS\GxType.cl</A></H2></A>
<P>
<H2> GX Type module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright (c) 2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007-2008, 2009 Seiji Koide
<P>
<P><HR WIDTH=80% ALIGN=left><P>
<P>
<H2> RDF Type Error Condition</H2>
<P>
 Followings are for type error message.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-type-error"><A HREF="../RDFS\GxType.cl"><B>rdf-type-error</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf-type-error inherits data variables and expected-type variables and 
type-error-datum and type-error-expected-type readers. 
format-control and format-arguments are from simple-condition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="cyclic-super/subclasses-error"><A HREF="../RDFS\GxType.cl"><B>cyclic-super/subclasses-error</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Cyclic super/subclass relation is not supported in CLOS.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-check-type"><A HREF="../RDFS\GxType.cl"><B>rdf-check-type</B></A></A> <I>place</I> <I>type</I> <I>&optional</I> <I>type-string</I></TH>
<TD align="right">[macro]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-check-type-1"><A HREF="../RDFS\GxType.cl"><B>rdf-check-type-1</B></A></A> <I>name</I> <I>place</I> <I>type</I> <I>type-string</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME=".rdf-type-error"><A HREF="../RDFS\GxType.cl"><B>.rdf-type-error</B></A></A> <I>datum</I> <I>expected-type</I> <I>&optional</I> <I>format</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="read-evaluated-form"><A HREF="../RDFS\GxType.cl"><B>read-evaluated-form</B></A></A> </TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Non-Unique Name Assumption and Equality</H2>
<P>
 In Semantic Webs, the non Unique Name Assumption (nonUNA) is adopted in principle. 
 Namely, two and more different names or URIs may denote same object in the universe. It is 
 just like as people often call a person by both name and nickname. However, it is, so far, 
 unusual and not adopted in ordinary computer languages. In complete nonUNA principle, we would fall 
 into troublesome situation. For example, the computation could not conclude that (rdf:Description ex:A) 
 and (rdf:Description ex:B) are different or a triple ex:A/ex:p/1 is different from ex:B/ex:p/1. 
 The ex:A and ex:B might denote the same thing in RDF universe, and two graphs might mean same 
 meaning in the world. We need very laborious work in nonUNA principle to describe common knowledge 
 such as ex:Automobile is different from ex:Train, ex:Airplane, and ex:Ship. We must state that 
 xsd:float is different from xsd:integer, xsd:URI, xsd:string, xsd:boolean, etc. for all terms in ontology.
<P>
 Therefore, we set up the flag for non Unique Name Assumption false as default. Namely, 
 if two names or URIs are different, then the two bound objects must be different. When you 
 want to set the nonUNA principle up in program, encode like below. 
<PRE><CODE>
    (let ((*nonUNA* t))
      ... some codes for nonUNA ...
      )
</CODE></PRE><P>
 Note that if two names or URIs are identical then they denote and are bound to an identical object 
 in spite of the value of *nonUNA*. Note also that, for anonymous objects, the graph structures of 
 objects must be compared in spite of the value of *nonUNA*. If two graphs for anonymous objects 
 are equal, then they are equal in RDF semantics. So, the question of equality is how to treat 
 the equality of named objects which have different names when the value of *nonUNA* is true. 
 In this implementation, 
<BR>
<UL>
<LI>if two objects are atomic, namely no graph structure or no slot on rdf properties,
    if two objects have different names, then they are not equal in spite of the value of *nonUNA*.
    if two objects are atomic and anonymous, then they are inevitably equal in spite of the value of *nonUNA*.
<LI>if two objects are not atomic, namely they have composed structure or slots on rdf properties,
    they are equal if their structure is equal else not equal in case that the value of *nonUNA* is true. 
    The name of complex objects are ignored when the value of *nonUNA* is true.
</UL>
<BR>
<P>
 Note that this implementation has no effects yet on owl:equivalentProperty. In SWCLOS, 
 every property must be named and different names must not be identical in equality checking. 
<P>
 Note that even though *nonUNA* is true or false, owl:sameAs and owl:differentFrom conduct SWCLOS and affect the 
 computation of equality in OWL.
<P>
 Note that owl:equivalentClass affects the computation of subsumption in OWL but does not affect the equality as 
 object or individual. See details in OWL module.
<P>
 Note that owl:disjointWith affects the computation of subsumption in OWL. Two concepts disjoint each other are 
 also different as object or individual. See details in OWL module.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*nonuna*"><A HREF="../RDFS\GxType.cl"><B>*nonUNA*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>A flag for non-UNA, it is false as default. Namely, the logic does not obey nonUNA as default.
   In order to set up complete nonUNA for Semantic Webs, set this value true. 
   Caution: we have seldom experienced on *nonUNA* = true.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Algorithm of Equality in RDF Universe</H2>
<P>
 The algorithm of equality in RDF is described as follows, See RDF Primer specification from W3C, and
 http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-Literal-Equality.
<BR>
<OL>
<LI>Two plane literals (string) without language tags are equal, if and only if they compare as equal,
   character by character.
<LI>Two plane literals with language tags are equal, if and only if the language tags are equal character
   by character without case sensitivity and the strings are equal character by character by case sensitivity.
<LI>Two RDF URI references are equal, if and only if they compare as equal, character by character,
   as Unicode strings.
<LI>Two plane literals as integer are equal, if and only if they are equal as mapped value in value space.
<LI>Two typed literals (xsd:anySimpleType) are equal, if and only if datatype URIs are equal and mapped values
   are equal in value space.
</OL>
<BR>
<P>
 Therefore, in this implementation
<BR>
<OL>
<LI>If <I>x</I> and <I>y</I> are equal as lisp object (integer, string, URI, symbol, CLOS object, etc.),
   then both are equal in RDF.
<LI>If <I>x</I> and <I>y</I> are instances of any datatype (xsd:anySimpleType), both are equal if both data types are
   equal and both values are equal.
<LI>If <I>x</I> and <I>y</I> are named CLOS objects, if both have a same name, then both are equal in RDF.
   If both have different names, the both are not equal when *nonUNA* is false, or the graph equality is 
   checked when *nonUNA* is true.
<LI>If <I>x</I> and <I>y</I> are anonymous CLOS objects, the graph equality is checked.
<LI>If at least one of <I>x</I> and <I>y</I> is an anonymous object then graph equality is checked.
<LI>If either <I>x</I> and <I>y</I> are URI or symbol and the relevant CLOS object exists as value,
   then the object is taken and recursively tested.
<LI>If either <I>x</I> and <I>y</I> are URI or symbol and no relevant CLOS object, then both are not equal.
<LI>If <I>x</I> and <I>y</I> are instances of rdf:inLang (literal with language tag), both are equal if both tags are
   equal without case sensitivity and the strings are equal with case sensitivity.
</OL>
<BR>
 To test the equality in semantics of RDF, <B>rdf-equalp</B> is available. See the following example.
<PRE><CODE>
 (rdf-equalp "this is string." "this is string.")                  -&gt; true
 (rdf-equalp "string" "string"@en)                                 -&gt; false
 (rdf-equalp "wine"@en (@ "wine" "EN"))                            -&gt; true
 (rdf-equalp 1 1.0)                                                -&gt; true
 (rdf-equalp 1 "1"^^xsd:integer)                                   -&gt; false
 (rdf-equalp "1"^^xsd:integer (^^ 1 xsd:integer))                  -&gt; true
 (rdf-equalp "1"^^xsd:integer (^^ 1 xsd:nonNegativeInteger))       -&gt; false
 (rdf-equalp (iri "http://somewhere") (iri "http://somewhere"))    -&gt; true
 (rdf-equalp (iri "http://somewhere") (iri "http://some%20where")) -&gt; false
 (rdf-equalp 'foo 'bar)                                            -&gt; false
 (defIndividual foo)                                     -&gt; #&lt;|rdfs:Resource| foo&gt;
 (defIndividual bar)                                     -&gt; #&lt;|rdfs:Resource| bar&gt;
 (rdf-equalp foo bar)                                              -&gt; false
 (let ((gx::*nonUNA* t)) (rdf-equalp foo bar))                     -&gt; false
</CODE></PRE><P>
 However, if uris are bound to anonymous object, this predicate changes the result, 
 because SWCLOS retrieves the bound values by resolution, and compares two anonymous 
 objects. 
<PRE><CODE>
 (rdf-equalp &lt;http://somewhere&gt; &lt;http://anotherplace&gt;)             -&gt; false
 (setf (iri-value &lt;http://somewhere&gt;)
   (addForm '(rdf:Description )))             -&gt; #&lt;|rdfs:Resource| :anonymous&gt;
 (setf (iri-value &lt;http://anotherplace&gt;)
   (addForm '(rdf:Description )))             -&gt; #&lt;|rdfs:Resource| :anonymous&gt;
 (rdf-equalp &lt;http://somewhere&gt; &lt;http://anotherplace&gt;)             -&gt; false
 (let ((*nonUNA* t))
   (rdf-equalp &lt;http://somewhere&gt; &lt;http://anotherplace&gt;))          -&gt; true
</CODE></PRE><P>
 At the last case above, in nonUNA condition, two bound values are compared. 
 Then, two anonymous rdf-object are equal as graph structure, whereas the URIs are 
 different. 
<P>
 Note that the reader macro '&lt;' gives URI.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%rdf-equalp"><A HREF="../RDFS\GxType.cl"><B>%rdf-equalp</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>this is not revolve version of rdf-equalp.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-equalp"><A HREF="../RDFS\GxType.cl"><B>rdf-equalp</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> and <I>y</I> is equal in the semantics of RDF(S). 
   This function resolves syntactical difference among symbol, uri, and object identification.
   This function uses <B>rdf-graph-equalp</B> internally.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-equalp"><A HREF="../RDFS\GxType.cl"><B>owl-equalp</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is supplied as a hook for the eqaulity in OWL system. In this RDF module, 
   it is same as <B>rdf-equalp</B>. This is overloaded when OWL system is loaded.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-same-p"><A HREF="../RDFS\GxType.cl"><B>owl-same-p</B></A></A> <I>x</I> <I>y</I> <I>&optional</I> <I>pairs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Hook for OWL. In RDFS module.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="definitely-%owl-same-p"><A HREF="../RDFS\GxType.cl"><B>definitely-%owl-same-p</B></A></A> <I>x</I> <I>y</I> <I>&optional</I> <I>pairs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%owl-same-p:t"><A HREF="../RDFS\GxType.cl"><B>%owl-same-p</B></A></A> <I>x</I> <I>y</I> <I>&optional</I> <I>pairs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Non resolution version. This is used in <B>owl-equalp</B> and <B>owl-equivalent-p</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Equivalency as Class</H2>
<P>
 <B>owl-equivalent-p</B> tests equivalency as class. Namely, the equivalent two object have 
 the same class extension, even if the both is not equal as class individual. 
 However, if two objects are equal as class individuial, then the both are equivalent as class.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-equivalent-p"><A HREF="../RDFS\GxType.cl"><B>owl-equivalent-p</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is a hook for OWL. In RDFS module, same as <B>rdf-equalp</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-ordinal-property-from-number"><A HREF="../RDFS\GxType.cl"><B>make-ordinal-property-from-number</B></A></A> <I>n</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an ordinal property symbol like 'rdf:_<I>n</I>' to which an instance of 
rdfs:ContainerMembershipProperty is bound.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-container-members"><A HREF="../RDFS\GxType.cl"><B>collect-container-members</B></A></A> <I>container</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>container</I> is an instance of rdfs:Container. This function retrieves all members in <I>container</I>, 
and returns a list of them.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-graph-equalp"><A HREF="../RDFS\GxType.cl"><B>rdf-graph-equalp</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function is effective for instances of rdf:Bag, rdf:Alt, rdf:Seq, rdf:List, and blank nodes.
For rdf:Bag, both member values of <I>x</I> and <I>y</I> are compared as set. For rdf:Alt, two first member value and two set 
of rest member values are compared. For rdf:Seq, two member values are compared as sequence. In other 
cases, each value is compared with each slot name.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-equalp-for-refining"><A HREF="../RDFS\GxType.cl"><B>owl-equalp-for-refining</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>x</I> and <I>y</I> must be clos objects but may be anonymous.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-graph-different-p"><A HREF="../RDFS\GxType.cl"><B>rdf-graph-different-p</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="equivalent-property-p"><A HREF="../RDFS\GxType.cl"><B>equivalent-property-p</B></A></A> <I>x</I> <I>y</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Disjointness</H2>
<P>
 CLOS classes are pairwise disjoint in ANSI Common Lisp, unless they have a common subclass 
 or one class is a subclass of the other. This agreement is supported by the premise that an 
 object in CLOS is typed to only one class. In the RDF universe, an entity can be typed to 
 multiple classes. So, the nature of disjointness in CLOS is not applicable in the RDF 
 universe. However, in SWCLOS, the pseudo multiple-classing is implemented by the special 
 mechanism called shadowed-class using CLOS class and metaclass mechanism. Therefore, from 
 the viewpoint of CLOS, the algorithm of disjointness for CLOS is also applicable in the RDF 
 universe in the virtue of CLOS.
<P>
 See also the explanation in OWL module.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="disjoint-p"><A HREF="../RDFS\GxType.cl"><B>disjoint-p</B></A></A> <I>c</I> <I>d</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>c</I> and <I>d</I> are disjoint in OWL.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="check-instance-sharing"><A HREF="../RDFS\GxType.cl"><B>check-instance-sharing</B></A></A> <I>c1</I> <I>c2</I> <I>&optional</I> <I>visited</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks disjointWith constraint of <I>c1</I> against <I>c2</I> and its subclasses.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%disjoint-p"><A HREF="../RDFS\GxType.cl"><B>%disjoint-p</B></A></A> <I>c</I> <I>d</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subs"><A HREF="../RDFS\GxType.cl"><B>collect-all-subs</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns all subclasses of <I>class</I> but <I>class</I> itself. 
   Note that this function uses only <I>mop:class-direct-subclasses</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Subtypep Utilities</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%clos-subtype-p"><A HREF="../RDFS\GxType.cl"><B>%clos-subtype-p</B></A></A> <I>c1</I> <I>c2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if CLOS metaobject <I>c1</I> eql <I>c2</I> or <I>c1</I> is a subtype of <I>c2</I> 
   using the class precedence list (cpl) of <I>c1</I>. This is more efficient than (<B>subtypep</B> <I>c1</I> <I>c2</I>)
   when <I>c1</I> and <I>c2</I> are CLOS objects.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%resource-subtype-p"><A HREF="../RDFS\GxType.cl"><B>%resource-subtype-p</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as (<B>subtypep</B> <I>class</I> <B>rdfs:Resource</B>) in CLOS, but more efficient.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%rdf-class-subtype-p"><A HREF="../RDFS\GxType.cl"><B>%rdf-class-subtype-p</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as (<B>subtypep</B> <I>class</I> <I>rdfs:Class</I>) in CLOS, but more efficient.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Forall, Exists, and Fills for Slot Definition Type Option</H2>
<P>
 In addition to concepts (classes) of RDFS and OWL, following CLOS classes may be 
 set into the type option of slot definition objects and used in subsumption computation
 between slot-type-constraints in subsumees and restrictions in subsumers.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slot-type-constraint"><A HREF="../RDFS\GxType.cl"><B>slot-type-constraint</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is the top abstract constraint for slot type constraints.
A subclass of this class is a metaclass.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 To compare slot-type-constraints with t (which is supplied by system as default type option)
 using cl:subtypep in the standard protocol of mop:compute-effective-slot-definition, 
 we needed slot type constraints as type or class, or else the default value t remains in 
 the type slot option together with slot type constraints. So, we needed following metaclasses 
 to create type slot constraints as class so as to eliminate t from type options in slot definitions.
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="forall"><A HREF="../RDFS\GxType.cl"><B>forall</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>type slot constraint metaclass for universal value constraints</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="exists"><A HREF="../RDFS\GxType.cl"><B>exists</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>type slot constraint metaclass for full existential constraints</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="fills"><A HREF="../RDFS\GxType.cl"><B>fills</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>type slot constraint metaclass for filler constraints</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:forall"><A HREF="../RDFS\GxType.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                               forall)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:exists"><A HREF="../RDFS\GxType.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                               exists)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:fills"><A HREF="../RDFS\GxType.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                              fills)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Subtyping from Slot Type Option</H2>
<P>
<P>
 From range constraints, C(y) comes up as this role extension R(x,y), here x is subjective object, and x is slot value.
 From allValuesFrom,  R(x,y)->C(y) comes up as this role extension R(x,y).
 From someValuesFrom, R(x,y)^C(y)  comes up as this role extension R(x,y).
 From hasValue, R:b,  R(x,b)       comes up as this role extension R(x,b).
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="strict-subsumed-p"><A HREF="../RDFS\GxType.cl"><B>strict-subsumed-p</B></A></A> <I>c1</I> <I>c2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="clos-strict-supertype-p"><A HREF="../RDFS\GxType.cl"><B>clos-strict-supertype-p</B></A></A> <I>c2</I> <I>c1</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>c1</I> is a supertype of <I>c2</I> in CLOS but not equal.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-resolve"><A HREF="../RDFS\GxType.cl"><B>rdf-resolve</B></A></A> <I>x</I> <I>&optional</I> <I>head-adding-stuff</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>transforms any element in tree <I>x</I> to rdf object from QName symbol and uri, if possible.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Subtypep in Semantics of RDF(S)</H2>
<P>
 To test rdfs:subClassOf relation including the transitivity, use <B>rdf-subtypep</B> for RDF(S) semantics.
 Note that the counterpart of <B>rdf-subtypep</B> in OWL semantics is <B>subsumed-p</B>.
<BR>
 Note that <I>cl:subtypep</I> in Common Lisp returns two values, e.g., value1 and value2.
 If value1 is true, then value2 is definitely true. So, a pair &lt;t nil&gt; never happens.
 The following table is taken from ANSI Common Lisp specs.
<PRE><CODE>
  value1   value2   meaning
 ---------------------------------------------------------------------
  true     true    type1 is definitely a subtype of type2.
  false    true    type1 is definitely not a subtype of type2.
  false    false   subtypep could not determine the relationship, 
                   so type1 might or might not be a subtype of type2. 
 ---------------------------------------------------------------------
</CODE></PRE><P>
 See, http://www.franz.com/support/documentation/8.1/ansicl/dictentr/subtypep.htm
<P>
 We carry out this semantics in <B>subtypep</B>, <B>rdf-subtypep</B>, and <B>subsumed-p</B>.
 We capture &lt;true true&gt; is true value (expressed as T), &lt;false true&gt; is false value (expressed as F), 
 and &lt;false false&gt; is unknown value (expressed as U) in RDF(S) and OWL semantics. 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subtypep"><A HREF="../RDFS\GxType.cl"><B>subtypep</B></A></A> <I>type1</I> <I>type2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>subtype relation in RDF(S) is equivalent to CLOS except URIs and QName symbol resolution.
   Therefore, after resolving URIs and QNames this function calls cl:subtypep.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subsumed-p"><A HREF="../RDFS\GxType.cl"><B>subsumed-p</B></A></A> <I>type1</I> <I>type2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is a hook for OWL. It is same as <B>rdf-subtypep</B> in RDFS.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 Function <B>subtypep</B> produces same logic as CLOS. However, in OWL semantics, it is wrong in reality. 
 More precisely, CLOS adopts Unique Name Assumption and do not have the explicit notion of disjointness. 
 Thus, if two classes are independent (not in relation of super-sub classes), then they seems to be disjoint. 
 However, if concept C and (not D) is compared in Allegro Common Lisp, ACL tends to fall into conclusion unknown. 
 It seems that CLOS does not have clear semantics on class extension. In RDF semantics, 
 every entity is a member of RDF universe, then the complement of xsd:integer or (not xsd:integer) extends out 
 of xsd:integer extension and xsd:decimal in RDF universe. For example, an instance of vin:Wine is not an 
 instance of xsd:integer. Therefore, it is obvious that (not xsd:integer) is not a subclass of xsd:integer and 
 xsd:decimal. However, cl:subtypep does not infer it (at least for ACL). 
<P>
 Furthermore, we have notions of equivalency and disjointness on class relation in OWL. 
 Therefore, the equivalency and disjointness must be checked in addition of super-sub class relation. 
 Specifically, if SWCLOS cannot infer two concepts are in relations of rdfs:subClassOf (and owl:intersectionOf, 
 owl:unionOf in OWL), then the relation of owl:equivalentClass, owl:disjointWith, owl:complementOf, owl:sameAs, 
 owl:differentFrom must be checked. Function <B>subsumed-p</B> returns unknown value only if there is no information of 
 super-sub class relation, equality, and disjointness. See <B>subsumed-p</B> in OWL module.
<P>
 To compute <B>rdf-subtypep</B> and <B>subsumed-p</B>, which takes care of unknown, 
 the following ternary truth table is used for T, F, and U.
<PRE><CODE>
  Ternary Truth Table 
 ----------------------
     conjunction
     |  T    U    F
  ---+--------------    e.g.,
   T |  T    U    F     True  ^ Unknown  =&gt; Unknown
   U |  U    U    F
   F |  F    F    F     False ^ Unknown  =&gt; False

     disjunction    
     |  T    U    F
  ---+--------------    e.g.,
   T |  T    T    T     True  v Unknown  =&gt; True
   U |  T    U    U
   F |  T    U    F     False v Unknown  =&gt; Unknown

      negation
    x | T    U    F
  ----+--------------    e.g.,
   ~x | F    U    T     ~Unkonw =&gt; Unkown
</CODE></PRE><P>
 The following table shows rewriting rules for inclusiveness.
 Where '&lt;' stands for subtype relation. '^' means conjunction and 'v' means disjunction. 
<PRE><CODE>
      C &lt; (A ^ B)  &lt;=&gt;  (C &lt; A) ^ (C &lt; B)
      C &lt; (A v B)  &lt;=&gt;  (C &lt; A) v (C &lt; B)
      (A ^ B) &lt; C  &lt;=&gt;  (A &lt; C) v (B &lt; C)
      (A v B) &lt; C  &lt;=&gt;  (A &lt; C) ^ (B &lt; C)

 (A v B) &lt; (C ^ D) &lt;=&gt;  (A &lt; C) ^ (A &lt; D)  ^  (B &lt; C) ^ (B &lt; D) 
 (A ^ B) &lt; (C v D) &lt;=&gt;  (A &lt; C) v (A &lt; D)  v  (B &lt; C) v (B &lt; D) 
 (A ^ B) &lt; (C ^ D) &lt;=&gt; ((A &lt; C) ^ (A &lt; D)) v ((B &lt; C) ^ (B &lt; D))
 (A v B) &lt; (C v D) &lt;=&gt; ((A &lt; D) v (A &lt; D)) ^ ((B &lt; C) v (B &lt; D))

           ~A &lt; ~B &lt;=&gt; B &lt; A
</CODE></PRE><P>
 <B>rdf-subtypep</B> has almost same logic as <B>subtypep</B> but it is only different with 
 respect to known/unknown. See following example.
<PRE><CODE>
 (rdf-subtypep xsd:long xsd:decimal)         -&gt; &lt;t t&gt;
 (subtypep xsd:long xsd:decimal)             -&gt; &lt;t t&gt;
 (rdf-subtypep `(not ,xsd:long) xsd:decimal) -&gt; &lt;nil t&gt;
 (subtypep `(not ,xsd:long) xsd:decimal)     -&gt; &lt;nil nil&gt;
 (rdf-subtypep xsd:decimal `(not ,xsd:long)) -&gt; &lt;nil t&gt;
 (subtypep xsd:decimal `(not ,xsd:long))     -&gt; &lt;nil nil&gt;
</CODE></PRE><P>
 In this example, xsd:long is subsumed by and not equal to xsd:decimal. Therefore, 
 there is the intersection between xsd:long and xsd:decimal.
 The complement of xsd:long extends over the boundary of xsd:decimal, then the extension 
 of (not xsd:long) is not included by the extension of xsd:decimal, and the extension of 
 the intersection between xsd:long and xsd:decimal is not included by (not xsd:long).
<P>
 Function <B>rdf-subtypep</B> obeys the set-theoretic semantics of RDF(S), but <B>subtypep</B> does not follow 
 the semantics of RDF(S) exactly. Even so, there is no difference between both, if only the 
 first value is used in program.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-subtypep"><A HREF="../RDFS\GxType.cl"><B>rdf-subtypep</B></A></A> <I>type1</I> <I>type2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>type1</I> is subsumed by <I>type2</I> in the sense of RDF(S).
   URIs and QName symbols are acceptable and resolved into resource objects. 
   Instances of Datatypes are also acceptable.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%rdf-subtypep"><A HREF="../RDFS\GxType.cl"><B>%rdf-subtypep</B></A></A> <I>type1</I> <I>type2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as rdf-subtypep but <I>type1</I> and <I>type2</I> must be an RDF object or cons.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Most Specific Concepts (MSCs)</H2>
<P>
 Function <B>most-specific-concepts</B> is used to compute the most specific concepts among classes.
 For example, xsd:integer is a superclass of xsd:int, and xsd:nonNegativeInteger is a superclass 
 of xsd:positiveInteger, then those superclasses disappear in the most specific concepts among them.
<PRE><CODE>
 (most-specific-concepts
   (list xsd:integer xsd:int xsd:positiveInteger
            xsd:nonNegativeInteger xsd:unsignedInt))
 -&gt; (#&lt;rdfs:Datatype xsd:unsignedInt&gt; #&lt;rdfs:Datatype xsd:positiveInteger&gt;
     #&lt;rdfs:Datatype xsd:int&gt;)
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-concepts"><A HREF="../RDFS\GxType.cl"><B>most-specific-concepts</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns the most specific concepts in RDF(S) and OWL semantics, or classes minus duplicates 
   and superclasses of other classes in <I>classes</I>. This function internally uses <B>subsumed-p</B> and 
   <B>owl-equivalent-p</B>. Note that this function does not check disjointness of classes. 
   <B>subsumed-p</B> is equal to <B>rdf-subtypep</B>, <B>owl-equivalent-p</B> is same 
   as <B>rdf-equalp</B> in RDF(S) module. Then, OWL module overwrites them. 
   This function allows <I>|rdfs:Resource|</I>, a temporal alternative of rdfs:Resource, and can accepts
   cons concepts as class. This function is taken from Memory Organization Package by Schank.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-abstract-concepts"><A HREF="../RDFS\GxType.cl"><B>most-abstract-concepts</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns the most abstract concepts in RDF(S) semantics, or classes minus duplicates and subclasses
   of other classes in <I>classes</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="strict-abstp"><A HREF="../RDFS\GxType.cl"><B>strict-abstp</B></A></A> <I>abst</I> <I>spec</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Is <I>abst</I> strictly (not equal to) superclass of <I>spec</I>?</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="strict-specp"><A HREF="../RDFS\GxType.cl"><B>strict-specp</B></A></A> <I>spec</I> <I>abst</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Is <I>spec</I> strictly (not equal to) subclass of <I>abst</I>?</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-concepts-by-superclasses"><A HREF="../RDFS\GxType.cl"><B>most-specific-concepts-by-superclasses</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as <B>most-specific-concepts</B> but uses <B>clos-strict-supertype-p</B> instead of <B>strict-abstp</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-concepts-by-clos-supers"><A HREF="../RDFS\GxType.cl"><B>most-specific-concepts-by-clos-supers</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as <B>most-specific-concepts</B> but uses <B>clos-strict-supertype-p</B> instead of <B>strict-abstp</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-concepts-for-slotd-type"><A HREF="../RDFS\GxType.cl"><B>most-specific-concepts-for-slotd-type</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as <B>most-specific-concepts</B> but understand forall, exists, and has in addition to subtypep.
   This is used for slot type reduction. If subtype relation is unknown, then the two remains in the list.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Miscellaneous Utilities for Typing</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rsc-object-p"><A HREF="../RDFS\GxType.cl"><B>rsc-object-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an RDF(S) metaclass, class, instance object, and xsd typed data, and not lisp data.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-thing-p"><A HREF="../RDFS\GxType.cl"><B>owl-thing-p</B></A></A> <I>obj</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Hook</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-class-p"><A HREF="../RDFS\GxType.cl"><B>rdf-class-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an RDF(S) metaclass and class object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-metaclass-p"><A HREF="../RDFS\GxType.cl"><B>rdf-metaclass-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an RDF(S) metaclass resource object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="strict-class-p"><A HREF="../RDFS\GxType.cl"><B>strict-class-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an RDF(S) class but not a metaclass.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-instance-p"><A HREF="../RDFS\GxType.cl"><B>rdf-instance-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an instance of rdfs:Resource but not rdfs:Class.
   This returns true if <I>x</I> is a lisp string, a list number, a uri.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%instance-p"><A HREF="../RDFS\GxType.cl"><B>%instance-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>when <I>x</I> is a CLOS object, if <I>x</I> is an instance of rdfs:Resource but not rdfs:Class, this returns true, 
   otherwise nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="datatype?"><A HREF="../RDFS\GxType.cl"><B>datatype?</B></A></A> <I>symbol</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Does this <I>symbol</I> denote an instance of rdfs:Datatype?</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="datatype-p"><A HREF="../RDFS\GxType.cl"><B>datatype-p</B></A></A> <I>obj</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Is <I>obj</I> an instance of rdfs:Datatype?</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="role-p"><A HREF="../RDFS\GxType.cl"><B>role-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an instance of rdf:Property.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%rdf-property-subtype-p"><A HREF="../RDFS\GxType.cl"><B>%rdf-property-subtype-p</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>x</I> is an instance of rdf:Property. <I>x</I> must be a CLOS object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="metaclass?"><A HREF="../RDFS\GxType.cl"><B>metaclass?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>name</I> is a symbol that has a value of an RDF(S) metaclass resource 
   object. If <I>name</I> is not a symbol an error is signaled.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="class?"><A HREF="../RDFS\GxType.cl"><B>class?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>name</I> is a symbol that has an RDF(S) metaclass, class, 
   and instance object. If <I>name</I> is not a symbol an error is signaled.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="object?"><A HREF="../RDFS\GxType.cl"><B>object?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>name</I> is a symbol that has an RDF(S) metaclass, class, 
   and instance object. If <I>name</I> is not a symbol an error is signaled.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="resource?"><A HREF="../RDFS\GxType.cl"><B>resource?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>same as <B>object?</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="role?"><A HREF="../RDFS\GxType.cl"><B>role?</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>name</I> is a symbol whose symbol value is an instance of 
   rdf:Property. If <I>name</I> is not a symbol an error is signaled.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="initarg="><A HREF="../RDFS\GxType.cl"><B>initarg=</B></A></A> <I>initarg1</I> <I>initarg2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="initarg-include-p"><A HREF="../RDFS\GxType.cl"><B>initarg-include-p</B></A></A> <I>initarg1</I> <I>initarg2</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Subsumption on Property</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subproperty-p"><A HREF="../RDFS\GxType.cl"><B>subproperty-p</B></A></A> <I>subprop</I> <I>superprop</I> <I>&optional</I> <I>visited</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>subprop</I> is a sub-property of <I>superprop</I> or 
   <I>superprop</I> itself. Otherwise returns nil</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="strict-subproperty-p"><A HREF="../RDFS\GxType.cl"><B>strict-subproperty-p</B></A></A> <I>subprop</I> <I>superprop</I> <I>visited</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>subprop</I> is not equal to and subproperty of <I>superprop</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Type System</H2>
<P>
 Lisp types are mapped to RDF(S) types as shown in the table below.
 If you want to use the Lisp nature <B>typep</B> and <B>type-of</B>, use cl:typep and cl:type-of. 
<PRE><CODE>
  Lisp          RDF(S)
 --------------------------------------
  null         rdfs:List
  cons         rdfs:List
  uri          xsd:anyURI
  symbol       &lt;type of symbol's value&gt;
  string       xsd:string
  fixnum       xsd:byte, xsd:short, xsd:int
  bignum       xsd:int, xsd:long, xsd:integer
  inLang       rdf:XMLLiteral
  &lt;a shadowed-class&gt; names of multiple classes
  &lt;a resource&gt; cl:type-of value
  rdfs:Class   rdfs:Class
  &lt;others&gt;     cl:type-of value
 --------------------------------------
</CODE></PRE><P>
 Example
<PRE><CODE>
  (type-of 32767)               =&gt; xsd:short
  (type-of 2147483647)          =&gt; xsd:int
  (type-of 9223372036854775807) =&gt; xsd:long
  (type-of "string?")           =&gt; xsd:string
  (type-of "Literal?"@en)       =&gt; rdf:XMLLiteral
  (type-of ())                  =&gt; rdf:List
  (type-of '(a b c))            =&gt; rdf:List
  (type-of xsd:true)            =&gt; rdf:boolean
  (type-of rdfs:label)          =&gt; rdf:Property
  (type-of rdf:Property)        =&gt; rdfs:Class
  (type-of rdfs:Class)          =&gt; rdfs:Class
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="type-of"><A HREF="../RDFS\GxType.cl"><B>type-of</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>extended version of cl:type-of function for RDF(S) and OWL.
   This function returns type(s) of <I>x</I> as symbol. See above example.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Type Predicate</H2>
<P>
 Type predicate <B>typep</B> is an extension of cl:typep for RDF(S) and OWL.
<BR>
 The algorithm of the type predicate is described below. Here, <I>a</I> is an argument for 
 instance, <I>c</I> is an argument for class. I(<I>a</I>) means a resolved CLOS object for <I>a</I> against URI, 
 QName, and object itself, I(<I>c</I>) also means a resolved CLOS object for <I>c</I>.  Namely, I(<I>a</I>) and 
 I(<I>c</I>) are interpreted and tested as CLOS object. Note that T or true is expressed by two values 
 &lt;t t&gt;, F(alse) is expressed by two values &lt;nil t&gt;, and U(nknown) is expressed by two values 
 &lt;nil nil&gt;.
<BR>
<OL>
<LI>If <I>c</I> is t, returns T.
<LI>If <I>c</I> is nil, returns F.
<LI>If <I>a</I> is nil, returns T.
<LI>If <I>c</I> is an instance of rdfs:Resource,
<BR>
<UL>
<LI TYPE="circle">If <I>a</I> is an instance of rdfs:Resource, then calls %type with <I>a</I> and <I>c</I>.
<LI TYPE="circle">If <I>a</I> can be resolved, then calls %type with I(<I>a</I>) and <I>c</I>.
<LI TYPE="circle">else calls %type with <I>a</I> and <I>c</I>.
</UL>
<LI>If <I>c</I> is not an instance of rdfs:Resource,
<BR>
<UL>
<LI TYPE="circle">If <I>c</I> can be resolved, then recursively calls with <I>a</I> and I(<I>c</I>).
<LI TYPE="circle">If <I>c</I> is a list and logic form, then returns truth value according to the ternary table.
<LI TYPE="circle">else calls %type with <I>a</I> and <I>c</I>.
</OL>
<BR>
<P>
 Here is the algorithm of subfunction <B>%typep</B>.  
<BR>
<OL>
<LI>If <I>c</I> is an instance of rdfs:Class,
<BR>
<UL>
<LI TYPE="circle">If <I>a</I> is an instance of rdfs:Resource,
     * If (cl:typep <I>a</I> <I>c</I>) is true, then returns T.
     * If (cl:typep <I>c</I> <I>a</I>) is true, then returns F.
     * Else returns the value of (<B>%%typep</B> <I>a</I> <I>c</I>). 
</UL>
<LI>If <I>c</I> is an instance of rdfsClass, it implies <I>c</I> is rdfs:Class, then
<BR>
<UL>
<LI TYPE="circle">if <I>a</I> is rdfs:Class, then retursn T.
<LI TYPE="circle">if (cl:typep <I>a</I> <I>c</I>) is true, then returs T, else returns F.
</UL>
<LI>If <I>c</I> is an instance of rdfs:Resource, it implies a strict instance, so returns F.
<LI>Otherwise returns U.
</OL>
<BR>
<P>
 <B>%%typep</B> works for an rdf object and a class as follows. 
 Here <I>C</I> stands for equivalent classes of <I>c</I> including <I>c</I> itself.
<BR>
<OL>
<LI>If for some <I>c</I> of <I>C</I> (<B>%typep-without-type-equivalents</B> <I>a</I> <I>c</I>), then returns T. Otherwise returns F or U
   according to the accumulation of each equivalent class of <I>C</I>. 
</OL>
<BR>
<P>
 <B>%typep-without-type-equivalents</B> works for an rdf object and a class as follows.
 Note that <I>A</I> stands for same objects of <I>a</I> including <I>a</I> itself.
<BR>
<OL>
<LI>If for some <I>a</I> of <I>A</I> (<B>typep-without-sames-and-equivalents-in-owl</B> <I>a</I> <I>c</I>), then returns T.
   Otherwise returns F or U according to the accumulation of each same object of <I>A</I>.
</OL>
<BR>
<P>
 <B>typep-without-sames-and-equivalents-in-owl</B> works as follows.
<BR>
<OL>
<LI>If <I>c</I> is an intersection of concepts, returns the result of <B>owl-intersection-type-p</B> for the intersections.
<LI>If <I>c</I> is an union of concepts, returns the result of <B>owl-union-type-p</B> for the unions.
<LI>If <I>c</I> is an complement concepts, returns the result of <B>owl-complement-type-p</B> for the complement.
<LI>If <B>*autoepistemic-local-closed-world*</B> is true, returns F else returns U.
</OL>
<BR>
<BR>
<P>
 Examples of xsd data types
<PRE><CODE>
 (typep 1 xsd:positiveInteger)
 (typep -1 xsd:negativeInteger)
 (typep 0 xsd:nonNegativeInteger)
 (typep 0 xsd:nonPositiveInteger)
 (typep 32767 xsd:short)
 (typep 32768 xsd:int)
 (typep 2147483647 xsd:int)
 (typep 2147483648 xsd:long)
 (typep 9223372036854775807 xsd:long)
 (typep 9223372036854775808 xsd:integer)
 (typep 1 xsd:decimal)
 (typep (cl:rational 1.0) xsd:decimal)
 (typep 1.0e0 xsd:float)
 (typep 1.0d0 xsd:double)
 (typep "string?" xsd:string)
 (typep "string?"@en xsd:string)
 (typep (net.uri:uri "http://somewhere") xsd:anyURI)
 (typep xsd:false xsd:boolean)
 (typep 1 xsd:anySimpleType)
 (typep 1 rdf:XMLLiteral)
 (typep "1"^^xsd:positiveInteger xsd:positiveInteger)
 (typep "1"^^xsd:positiveInteger xsd:anySimpleType)
 (typep "1"^^xsd:positiveInteger rdf:XMLLiteral)
</CODE></PRE><P>
<P>
 Examples of Literals
<PRE><CODE>
 (typep 1 rdfs:Literal)
 (typep 1 rdfs:Resource)
 (typep "1"^^xsd:positiveInteger rdfs:Literal)
 (typep "1"^^xsd:positiveInteger rdfs:Resource)
 (typep "subway"@en rdf:XMLLiteral)
 (typep "subway"@en rdfs:Literal)
 (typep rdfs:label rdf:Property)
</CODE></PRE><P>
<P>
 Examples of Others
<PRE><CODE>
 (typep (list 1 2 3) rdf:List)
 (typep 1 (list 'and xsd:integer rdf:XMLLiteral))
 (typep 1 (list 'or xsd:integer xsd:float))
 (typep rdf:Property rdfs:Class)
 (typep rdfs:Class rdfs:Class)
 (typep rdfs:label rdfs:Resource)
 (typep rdf:Property rdfs:Resource)
 (typep rdfs:Class rdfs:Resource)
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="typep"><A HREF="../RDFS\GxType.cl"><B>typep</B></A></A> <I>object</I> <I>type</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>extended typep function for Semantic Web. This function resolves the difference among 
   URI, QName, and object for parameters. Namely, if a parameter is URI or symbol, then 
   the related CLOS object is taken to test it.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%typep"><A HREF="../RDFS\GxType.cl"><B>%typep</B></A></A> <I>object</I> <I>type</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>object</I> and <I>type</I> is an object in RDF universe.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%%typep"><A HREF="../RDFS\GxType.cl"><B>%%typep</B></A></A> <I>object</I> <I>type</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Hook for OWL. See OWL module.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%typep-for-mscs"><A HREF="../RDFS\GxType.cl"><B>%typep-for-MSCs</B></A></A> <I>object</I> <I>type</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>type</I> is a CLOS object including rdfs:Literal including datatypes (instances of rdf:Datatype).
   Note that this subfunction is invoked with <I>type</I> that is a CLOS class.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-oneof-p"><A HREF="../RDFS\GxType.cl"><B>owl-oneof-p</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Hook for OWL.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="same-as-of"><A HREF="../RDFS\GxType.cl"><B>same-as-of</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Hook for OWL.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="disjoint-pairs-p"><A HREF="../RDFS\GxType.cl"><B>disjoint-pairs-p</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Negation Normal Form (NNF)</H2>
<P>
 NNF is a logical form in which negation is applied to only logical atom.
 In the following routine, non-NNF should be a prefix form in S-expression.
<PRE><CODE>
  &lt;form&gt; ::= &lt;atom&gt; | (not &lt;form&gt;) | (and &lt;form&gt;*) | (or &lt;form&gt;*) | 
             (forall &lt;var&gt; &lt;form&gt;*) | (exists &lt;var&gt; &lt;form&gt;*) | (fills &lt;var&gt; &lt;form&gt;)
  &lt;NNF&gt;  ::= &lt;atom&gt; | (not &lt;atom&gt;) | (and &lt;NNF&gt;*)  | (or &lt;NNF&gt;*)
             (forall &lt;var&gt; &lt;NNF&gt;) | (exists &lt;var&gt; &lt;NNF&gt;) | (fills &lt;var&gt; &lt;NNF&gt;)
 Ex.
 (-&gt;nnf '(not (and (not (or (not A) (and C (not D)))))))
  -&gt; (or (not A) (and C (not D)))
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="->nnf"><A HREF="../RDFS\GxType.cl"><B>->nnf</B></A></A> <I>P</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>transforms non-NNF S-expression <I>P</I> to NNF and returns it.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 This program is borrowed from AIMA
<P>
 Note that <B>move-not-inwards</B> returns ~P for P.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="move-not-inwards"><A HREF="../RDFS\GxType.cl"><B>move-not-inwards</B></A></A> <I>P</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Given P, return ~P, but with the negation moved as far in as possible.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="conjunction"><A HREF="../RDFS\GxType.cl"><B>conjunction</B></A></A> <I>args</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Form a conjunction with these args.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="disjunction"><A HREF="../RDFS\GxType.cl"><B>disjunction</B></A></A> <I>args</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Form a disjunction with these args.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-exp"><A HREF="../RDFS\GxType.cl"><B>make-exp</B></A></A> <I>op</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>makes a form of <I>op</I> and <I>args</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="op"><A HREF="../RDFS\GxType.cl"><B>op</B></A></A> <I>exp</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Operator of an expression</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="args"><A HREF="../RDFS\GxType.cl"><B>args</B></A></A> <I>exp</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Arguments of an expression</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="arg1"><A HREF="../RDFS\GxType.cl"><B>arg1</B></A></A> <I>exp</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>First argument</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="arg2"><A HREF="../RDFS\GxType.cl"><B>arg2</B></A></A> <I>exp</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Second argument</TD>
</TR></TBODY></TABLE></DIV> 
<A NAME="RDFS/DomainRange.cl"><HR>
<H2>File <A HREF="../RDFS\DomainRange.cl">RDFS\DomainRange.cl</A></H2></A>
<P>
<H2> Domain and Range module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT.
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright  2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007 Seiji Koide
<P><HR WIDTH=80% ALIGN=left><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*autoepistemic-local-closed-world*"><A HREF="../RDFS\DomainRange.cl"><B>*autoepistemic-local-closed-world*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Unsatisfiable Error</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rdf-unsatisfiable"><A HREF="../RDFS\DomainRange.cl"><B>rdf-unsatisfiable</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domain-condition-unsatisfiable"><A HREF="../RDFS\DomainRange.cl"><B>domain-condition-unsatisfiable</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="range-condition-unsatisfiable"><A HREF="../RDFS\DomainRange.cl"><B>range-condition-unsatisfiable</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="invalid-slot-value-for-range"><A HREF="../RDFS\DomainRange.cl"><B>invalid-slot-value-for-range</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><HR WIDTH=80% ALIGN=left><P>
<P>
<H2> Top Class rdfs:Resource and Top Metaclass rdfs:Class</H2>
<P>
 In the RDF universe, the top class, that is a superclass of every class, is rdfs:Resource.
 The top metaclass, that is a class of every class, is rdfs:Class.
 Note that the direct class of rdfs:Class is (virtually) rdfs:Class (actually rdfsClass in lisp), 
 but the superclass of rdfs:Resource is (virtually) null (actually gx::gnode in lisp).
 In our OWL connection to RDF, the OWL universe is included into and inherites characteristics from 
 the RDF universe. The top concept is rdfs:Resource and the top meta concept is rdfs:Class in 
 the OWL universe, too. 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*top*"><A HREF="../RDFS\DomainRange.cl"><B>*top*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>The top concept, i.e. rdfs:Resource in RDFS, and in OWL, too.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*meta*"><A HREF="../RDFS\DomainRange.cl"><B>*meta*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>The top meta-object, i.e. rdfs:Class in RDFS, and in OWL, too.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<P>
<H2> Domain Value</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domain-value:property"><A HREF="../RDFS\DomainRange.cl"><B>domain-value</B></A></A> <I>(property
                                                                                                                      Property)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>retrieve the domain value of <I>property</I>, or returns nil if not exists.
   Note that this method is refined for owl:ObjectProperty.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%domain-value"><A HREF="../RDFS\DomainRange.cl"><B>%domain-value</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns a list of domains for property or null list.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%get-domain"><A HREF="../RDFS\DomainRange.cl"><B>%get-domain</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-inherited-domain"><A HREF="../RDFS\DomainRange.cl"><B>most-specific-inherited-domain</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-domain"><A HREF="../RDFS\DomainRange.cl"><B>get-domain</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns domain of <I>property</I> or nil. This function searches the super-properties and 
   returns the most specific domain.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="more-specific-domain"><A HREF="../RDFS\DomainRange.cl"><B>more-specific-domain</B></A></A> <I>property</I> <I>domain</I> <I>super</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-domains"><A HREF="../RDFS\DomainRange.cl"><B>collect-domains</B></A></A> <I>properties</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collects domain information from <I>properties</I>. A property must be a symbol.
   If anyone in properties is not defined, this function executes rdf1 entaiment rule.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domainp"><A HREF="../RDFS\DomainRange.cl"><B>domainp</B></A></A> <I>property</I> <I>domain</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>property</I>'s domain is a subclass of <I>domain</I>, or if 
   some of <I>property</I>'s super-properties has a subclass domain of <I>domain</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2>  Range Value</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="range-value:property"><A HREF="../RDFS\DomainRange.cl"><B>range-value</B></A></A> <I>(property
                                                                                                                    Property)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>retrieve the range value of <I>property</I>, or returns nil if not exists.
   This method is refined for owl:ObjectProperty.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%range-value"><A HREF="../RDFS\DomainRange.cl"><B>%range-value</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns a list of ranges for property or null list.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-inherited-range"><A HREF="../RDFS\DomainRange.cl"><B>most-specific-inherited-range</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-range"><A HREF="../RDFS\DomainRange.cl"><B>get-range</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns range of <I>property</I> or nil. This function searches the super-properties and 
   returns the most specific range.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%get-range"><A HREF="../RDFS\DomainRange.cl"><B>%get-range</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="more-specific-range"><A HREF="../RDFS\DomainRange.cl"><B>more-specific-range</B></A></A> <I>property</I> <I>range</I> <I>super</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-ranges"><A HREF="../RDFS\DomainRange.cl"><B>collect-ranges</B></A></A> <I>properties</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collects range information from <I>properties</I>. A property must be a symbol.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rangep"><A HREF="../RDFS\DomainRange.cl"><B>rangep</B></A></A> <I>property</I> <I>range</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns true if <I>property</I>'s range is a subclass of <I>range</I>, or if 
   some of <I>property</I>'s super-properties has a subclass range of <I>range</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domains-satisfied-p"><A HREF="../RDFS\DomainRange.cl"><B>domains-satisfied-p</B></A></A> <I>instance</I> <I>domains</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Is every domain satisfied?</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domain-check-for-class"><A HREF="../RDFS\DomainRange.cl"><B>domain-check-for-class</B></A></A> <I>class</I> <I>domain</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks <I>class</I> for <I>domain</I> constraint, if <I>class</I> violates the constraint,
   entailment is invoked as much as possible. This function returns either class or domain.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="domain-check-for-instance"><A HREF="../RDFS\DomainRange.cl"><B>domain-check-for-instance</B></A></A> <I>instance</I> <I>domain</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks <I>instance</I> for <I>domain</I> constraint, if <I>instance</I> violates the constraint,
   entailment is invoked as much as possible.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slot-value-range-check"><A HREF="../RDFS\DomainRange.cl"><B>slot-value-range-check</B></A></A> <I>role</I> <I>value</I> <I>range</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks <I>value</I> for <I>range</I> constraint, if <I>value</I> violates the constraint,
   entailment is invoked as much as possible. Otherwise error caused.
   This function returns <I>value</I>. 
   NOTE. this function does not infer on oneOf information. This is important
   for establishing oneOf entailment.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%slot-value-range-check"><A HREF="../RDFS\DomainRange.cl"><B>%slot-value-range-check</B></A></A> <I>role</I> <I>value</I> <I>range</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>range is an atom.</TD>
</TR></TBODY></TABLE></DIV> 
<A NAME="RDFS/RdfsObjects.cl"><HR>
<H2>File <A HREF="../RDFS\RdfsObjects.cl">RDFS\RdfsObjects.cl</A></H2></A>
<P>
<H2> RDFS Objects module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT.
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright  2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007 Seiji Koide
<P><HR WIDTH=80% ALIGN=left><P>
<P>
<H2> Shadow Class</H2>
 When an object belongs to multiple classes, SWCLOS sets up a class that has the multiple classes in superclass list, 
 and change the class of the object to the new class instead of multiple classes. 
 Such a special class is called a shadow class which is an instance of metaclass <I>shadowed-class</I>.
 See following example in Wine Ontology.
<PRE><CODE>
  (mclasses vin:SaucelitoCanyonZinfandel1998)
   -&gt; (#&lt;owl:Class vin:Zinfandel&gt; #&lt;owl:Class vin:Vintage&gt;)
 
  (class-of vin:SaucelitoCanyonZinfandel1998)
   -&gt; #&lt;shadowed-class vin:Zinfandel.34&gt;
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shadowed-class"><A HREF="../RDFS\RdfsObjects.cl"><B>shadowed-class</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>The shadow class for multiple classing.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 The classes of object are stored in <B>mclasses</B> slot of object. In <B>mclasses</B> slot list, every element is 
 not a shadow class. In order to obtain the most specific non-shadow superclass list of a class 
 <B>get-mclasses-from</B> function is used.
<P>
<PRE><CODE>
  (get-mclasses-from (class-of vin:SaucelitoCanyonZinfandel1998))
   -&gt; (#&lt;owl:Class vin:Zinfandel&gt; #&lt;owl:Class vin:Vintage&gt;)
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-mclasses-from"><A HREF="../RDFS\RdfsObjects.cl"><B>get-mclasses-from</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>retrieves all superclasses of <I>class</I> which are not a shadow class. If a super is a shadow class,
   recusively its non shadow superclasses are retrieved and collected. Note that the return value 
   may include duplicates or not-most-special supers.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shadow-name"><A HREF="../RDFS\RdfsObjects.cl"><B>shadow-name</B></A></A> <I>abst</I> <I>mclasses</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>creates and returns a name for shadowing class from <I>abst</I>.
   Note that 'shadow-name' is expressed as '<I>abst-name</I>.nn'. If <I>abst</I> is null, 
   the first class in <I>mclasses</I> that has name is used instead.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-shadow"><A HREF="../RDFS\RdfsObjects.cl"><B>make-shadow</B></A></A> <I>old-class</I> <I>mclasses</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>changes <I>old-class</I> to a shadow class with <I>mclasses</I> as superclasses and returns it.
   Note that this function does not make a new shadow class, if mclasses of <I>old-class</I> 
   is a same set to <I>mclasses</I> or if some of subclasses of someone of <I>mclasses</I> is a 
   same set to <I>mclasses</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="destroyed-class"><A HREF="../RDFS\RdfsObjects.cl"><B>destroyed-class</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
 class-direct-instances are maintained by update-instance-for-different-class:after(gnode).
 Therefore, old-class is cleared when it falls here.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="update-instance-for-different-class:resource"><A HREF="../RDFS\RdfsObjects.cl"><B>update-instance-for-different-class</B></A></A> <I>(previous
                                                                                                                                                                    Resource)</I> <I>current</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="destroy"><A HREF="../RDFS\RdfsObjects.cl"><B>destroy</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="most-specific-concepts-for-refining"><A HREF="../RDFS\RdfsObjects.cl"><B>most-specific-concepts-for-refining</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function is used for class refining for an instance. So, we treat only rigid classes.
   <I>classes</I> must be clos objects.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Properties Final</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="seealso"><A HREF="../RDFS\RdfsObjects.cl"><B>seeAlso</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to indicate a resource that might provide additional information about the subject resource.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="type"><A HREF="../RDFS\RdfsObjects.cl"><B>type</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state that a resource is an instance of a class.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="predicate"><A HREF="../RDFS\RdfsObjects.cl"><B>predicate</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state the predicate of a statement.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subject"><A HREF="../RDFS\RdfsObjects.cl"><B>subject</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state the subject of a statement.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="object"><A HREF="../RDFS\RdfsObjects.cl"><B>object</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>is used to state the object of a statement.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="statement"><A HREF="../RDFS\RdfsObjects.cl"><B>Statement</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>It is intended to represent the class of RDF statements. 
An RDF statement is the statement made by a token of an RDF triple.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> rdfs:Datatype and rdf:XMLLiteral</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:xmlliteral"><A HREF="../RDFS\RdfsObjects.cl"><B>print-object</B></A></A> <I>(object
                                                                                                                        XMLLiteral)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This method is not intended to use by programmer. XMLLiteral data is printed as 1^^xsd:nonNegativeInteger.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ill-structured-xmlliteral"><A HREF="../RDFS\RdfsObjects.cl"><B>ill-structured-XMLLiteral</B></A></A> </TH>
<TD align="right">[class]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:ill-structured-xmlliteral"><A HREF="../RDFS\RdfsObjects.cl"><B>print-object</B></A></A> <I>(object
                                                                                                                                       ill-structured-XMLLiteral)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Datatype Objects</H2>
<P>
 Every RDFS datatype is defined as lisp type and RDF resource, too.
 As lisp type, data as lisp object is typed as follows.
<PRE><CODE>
  (cl:typep 1 'xsd:nonNegativeInteger)
</CODE></PRE><P>
 See XML module.
<P>
 As RDFS datatype, RDF resource is typed as follows.
<PRE><CODE>
  (setq foo (^^ 1 xsd:nonNegativeInteger))
  (typep foo xsd:nonNegativeInteger)
</CODE></PRE><P>
<P>
 Note that excl:sub-subtypep works well on the following datatype classes
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="anysimpletype"><A HREF="../RDFS\RdfsObjects.cl"><B>anySimpleType</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:anySimpleType class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="decimal"><A HREF="../RDFS\RdfsObjects.cl"><B>decimal</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:decimal class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="integer"><A HREF="../RDFS\RdfsObjects.cl"><B>integer</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:integer class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="nonpositiveinteger"><A HREF="../RDFS\RdfsObjects.cl"><B>nonPositiveInteger</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:nonPositiveInteger class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="negativeinteger"><A HREF="../RDFS\RdfsObjects.cl"><B>negativeInteger</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:negativeInteger class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="long"><A HREF="../RDFS\RdfsObjects.cl"><B>long</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:long class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="int"><A HREF="../RDFS\RdfsObjects.cl"><B>int</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:int class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="short"><A HREF="../RDFS\RdfsObjects.cl"><B>short</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:short class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="byte"><A HREF="../RDFS\RdfsObjects.cl"><B>byte</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:byte class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="nonnegativeinteger"><A HREF="../RDFS\RdfsObjects.cl"><B>nonNegativeInteger</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:nonNegativeInteger class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="positiveinteger"><A HREF="../RDFS\RdfsObjects.cl"><B>positiveInteger</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:positiveInteger class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="unsignedlong"><A HREF="../RDFS\RdfsObjects.cl"><B>unsignedLong</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:unsignedLong class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="unsignedint"><A HREF="../RDFS\RdfsObjects.cl"><B>unsignedInt</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:unsignedInt class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="unsignedshort"><A HREF="../RDFS\RdfsObjects.cl"><B>unsignedShort</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:unsignedShort class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="unsignedbyte"><A HREF="../RDFS\RdfsObjects.cl"><B>unsignedByte</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:unsignedByte class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="string"><A HREF="../RDFS\RdfsObjects.cl"><B>string</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:string class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="float"><A HREF="../RDFS\RdfsObjects.cl"><B>float</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:float class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="double"><A HREF="../RDFS\RdfsObjects.cl"><B>double</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:double class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="anyuri"><A HREF="../RDFS\RdfsObjects.cl"><B>anyURI</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:anyURI class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="boolean"><A HREF="../RDFS\RdfsObjects.cl"><B>boolean</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:boolean class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="true"><A HREF="../RDFS\RdfsObjects.cl"><B>true</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:boolean instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="false"><A HREF="../RDFS\RdfsObjects.cl"><B>false</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:boolean instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="duration"><A HREF="../RDFS\RdfsObjects.cl"><B>duration</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xsd:duration class object</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-object:duration"><A HREF="../RDFS\RdfsObjects.cl"><B>print-object</B></A></A> <I>(obj
                                                                                                                      duration)</I> <I>stream</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This method is not intended to be used by users.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="nil"><A HREF="../RDFS\RdfsObjects.cl"><B>nil</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:List instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="first"><A HREF="../RDFS\RdfsObjects.cl"><B>first</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:Property instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="rest"><A HREF="../RDFS\RdfsObjects.cl"><B>rest</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:Property instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="value"><A HREF="../RDFS\RdfsObjects.cl"><B>value</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:Property instance</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Containers in RDF</H2>
 rdfs:Container, rdfs:member, rdfs:ContainerMembershipProperty, 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="container"><A HREF="../RDFS\RdfsObjects.cl"><B>Container</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>The class of RDF containers.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="member"><A HREF="../RDFS\RdfsObjects.cl"><B>member</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdf:Property instance</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="containermembershipproperty"><A HREF="../RDFS\RdfsObjects.cl"><B>ContainerMembershipProperty</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>The class of RDF containers.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-props-from-initargs"><A HREF="../RDFS\RdfsObjects.cl"><B>collect-props-from-initargs</B></A></A> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<A NAME="RDFS/RdfsKernel.cl"><HR>
<H2>File <A HREF="../RDFS\RdfsKernel.cl">RDFS\RdfsKernel.cl</A></H2></A>
<P>
<H2> Rdfs Kernel module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT.
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan.
<P>
 Copyright  2002-2005 Galaxy Express Corporation
<BR>
 Copyright (c) 2007 Seiji Koide
<P><HR WIDTH=80% ALIGN=left><P>
<H2> MOP Programming Layer out of Three Layers in RDF(S) and OWL Definition</H2>
<P>
 There are three layers for resource definition, i.e., 
 (i) top level macro layer, 
 (ii) intermediate function/method layer, and 
 (iii) MOP programming layer.
 The top level macro layer, which includes three macros, <B>defConcept</B>, <B>defProperty</B>, and <B>defIndividual</B>,
 allows users to input RDF(S) and OWL entities in S-expression just in the same feeling as defining classes 
 or structures in lisp. 
 The intermediate layer composed of several functions and methods mediates inputs at the top level to the 
 MOP programming layer. 
 The MOP programming layer constitutes a bunch of MOP methods that are programmed in order to tailor 
 the CLOS orignal functionality to RDF(S) and OWL semantics using the Meta-Object Protocol (MOP).
<P>
 This file includes (iii) the MOP programming layer. 
 The other layers are contained in Rdfs Core module.
<P>
<H2> Method Invocation Orders and their Procedures</H2>
<P>
 The procedure of make-instance is as follows.
<BR>
<OL>
<LI>make-instance:around ((eql owl:Class)), see leanOWL file
<BR>
<UL>
<LI TYPE="circle">make sure this class has owl:Thing as superclass
</UL>
<LI>make-instance:around (owl:Class), see leanOWL file
<BR>
<UL>
<LI TYPE="circle">make sure this class has owl:Thing as superclass
</UL>
<LI>make-instance:around (rdfs:Class), see RdfsCore file
<BR>
<UL>
<LI TYPE="circle">ensure slot definitions for this <I>class</I>, then domain constraints are also taken care
</UL>
<LI>make-instance:around (rdfsClass), see RdfsCore file
<BR>
<UL>
<LI TYPE="circle">ensure slot definitions for this <I>class</I>, then domain constraints are also taken care
</OL>
<BR>
 There is no initialize-instance in this implementation.
<BR>
 The procedure of reinitialize-instance is as follows.
<BR>
<OL>
<LI>reinitialize-instance:around (rdfs:Class)
<BR>
<UL>
<LI TYPE="circle">remove direct-slots initarg and its value, if its value is nil.
</UL>
<LI>reinitialize-instance:before (rdfs:Resource)
<BR>
<UL>
<LI TYPE="circle">after ensuring slot definitions at the class of instance, change-class if more special type(s) is derived from domain constraints
</OL>
<BR>
<P>
 The procedure of shared-initialize is as follows.
<BR>
<OL>
<LI>shared-initialize:around (rdf:Property)
<BR>
<UL>
<LI TYPE="circle">if both old and new domain/range exist, rewrite initargs with their MSC
</UL>
<LI>shared-initialize:around (rdfs:Class)
<BR>
<UL>
<LI TYPE="circle">assure the MSG for direct-superclasses, if they exist in initargs
<LI TYPE="circle">in redefinition, prepare all old slot difinitions and merge them with new definitions in initargs,
</UL>
<LI>shared-initialize :around (rdfsClass)
<LI>shared-initialize:after(gnode)
<BR>
<UL>
<LI TYPE="circle">maintain mclasses slot and direct-instances slot
</UL>
<LI>shared-initialize:after (rdfs:Resource)
<BR>
<UL>
<LI TYPE="circle">book keeping for reification
</UL>
<LI>shared-initialize:after (owl:Class)
<BR>
<UL>
<LI TYPE="circle">subClassOf
<LI TYPE="circle">intersectionOf
<LI TYPE="circle">unionOf
<LI TYPE="circle">equivalentClass
<LI TYPE="circle">disjointWith
<LI TYPE="circle">complementOf
</UL>
<LI>shared-initialize:after (owl:Thing)
<BR>
<UL>
<LI TYPE="circle">owl:sameAs
<LI TYPE="circle">owl:differentFrom
<LI TYPE="circle">functional property maintenance
<LI TYPE="circle">symmetric property maintenance
<LI TYPE="circle">transitive property maintenance
<LI TYPE="circle">oneOf check
<LI TYPE="circle">refine instance in OWL
</UL>
<LI>shared-initialize:after (OneOf)
<LI>shared-initialize:after(rdf:Property)
<BR>
<UL>
<LI TYPE="circle">super/sub property book-keeping
<LI TYPE="circle">equivalent property maintain
<LI TYPE="circle">define this property slot to domain, if suplied
<LI TYPE="circle">domain checking and range checking to every related extensions.
</OL>
<BR>
<P>
 The rule rdfs8 indicates the default top class in triple should be rdfs:Resource.
 The rule rdfs13 indicates the default data type in triple should be rdfs:Datatype.
 The following methods assure rdfs8 and rdfs13 rules.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="default-direct-superclasses:class"><A HREF="../RDFS\RdfsKernel.cl"><B>default-direct-superclasses</B></A></A> <I>(class
                                                                                                                                                Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Rdfs8 rule is implemented at this method.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="default-direct-superclasses:datatype"><A HREF="../RDFS\RdfsKernel.cl"><B>default-direct-superclasses</B></A></A> <I>(class
                                                                                                                                                   Datatype)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Rdfs13 rule is implemented at this method.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-instance:(eql class)"><A HREF="../RDFS\RdfsKernel.cl"><B>make-instance</B></A></A> <I>(class
                                                                                                                          (eql
                                                                                                                           Class))</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-instance:(eql datatype)"><A HREF="../RDFS\RdfsKernel.cl"><B>make-instance</B></A></A> <I>(class
                                                                                                                             (eql
                                                                                                                              Datatype))</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="asyclic-property-termilogy-error"><A HREF="../RDFS\RdfsKernel.cl"><B>asyclic-property-termilogy-error</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="metamodeling-error"><A HREF="../RDFS\RdfsKernel.cl"><B>metamodeling-error</B></A></A> </TH>
<TD align="right">[condition]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
 Class Precedence List
<P>
<P>
<H2> Shared-initialize for Property</H2>
<P>
<BR>
<OL>
<LI><B>shared-initialize</B>:around(rdf:Property)
<BR>
<UL>
<LI TYPE="circle">When redefining a property, if both olddomains and newdomains are exists,
   the most specific concepts (MSC) are set for domain initargs, and if both oldranges and newrages are exists, 
   the most specific concepts (MSC) are set for range initargs. Otherwise nothing done for initargs. The next method 
   processes initargs regularly.
</UL>
<LI><B>shared-initialize</B>:after (rdf:Property)
<BR>
<UL>
<LI TYPE="circle">When rdfs:subPropertyOf is supplied, the inverse relation is registered for book-keeping.
<LI TYPE="circle">When owl:equivalentPropety is supplied, the equivalent property group is maintained.
<LI TYPE="circle">When rdfs:domain is supplied, the direct-slot-definition for this property is added to the directed domain class.
<LI TYPE="circle">When rdfs:domain is supplied, the domain constraints are checked for every subject of the extension of this property.
<LI TYPE="circle">When rdfs:range is supplied, the range constraints are checked for every object of the extension of this property.
</OL>
<BR>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:property"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(instance
                                                                                                                               Property)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>After regular processing, property specific procedure is processed here, i.e., book-keeping for 
   super/sub relation maintenance, the equivalent property group maintencne, adding slot definition to 
   the domain class, and finally constraint propergation of domain and range constraints.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="book-keeping-super/sub-property"><A HREF="../RDFS\RdfsKernel.cl"><B>book-keeping-super/sub-property</B></A></A> <I>property</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>puts this property into the subproperty slot of super property.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="equivalentproperty-maintain"><A HREF="../RDFS\RdfsKernel.cl"><B>equivalentProperty-maintain</B></A></A> <I>instance</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This is hook for OWL module. See <B>equivalentProperty-maintain</B> in OWL module.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Slot Attaching Functions</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="add-direct-slots-to-domain"><A HREF="../RDFS\RdfsKernel.cl"><B>add-direct-slots-to-domain</B></A></A> <I>instance</I> <I>newdomain</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>add the direct slot definitions to new domains from <I>initargs</I> for this property definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="associated-p"><A HREF="../RDFS\RdfsKernel.cl"><B>associated-p</B></A></A> <I>role</I> <I>domain</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>does this <I>domain</I> has directly the slot definition of this <I>role</I>?</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Shared Initialize for rdfs:Resource</H2>
<P>
 When any setting value in initargs is already set in the existing slot, it is eliminated from 
 initargs. This is for supressing meaningless redefining messages.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(instance
                                                                                                                               Resource)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Shared Initialize for rdfs:Class</H2>
<P>
 Note that even if you want to add more abstract concept as superclass, 
 you cannot do it when system knows the MSC concept that is more specific than your indication.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:class"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(class
                                                                                                                            Class)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When initialization rewrite direct-superclasses with MSCs of direct-superclasses in 
   <I>initargs</I>. When reinitialization rewrite direct-superclasses with MSCs of old superclasses 
   and new superclasses, then, old direct slot definitions are recovered into def-form and 
   merged with new definition.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-initargs-from-slotds"><A HREF="../RDFS\RdfsKernel.cl"><B>make-initargs-from-slotds</B></A></A> <I>slotds</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-initarg-from-slotd"><A HREF="../RDFS\RdfsKernel.cl"><B>make-initarg-from-slotd</B></A></A> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-this-supers:class"><A HREF="../RDFS\RdfsKernel.cl"><B>make-this-supers</B></A></A> <I>(class
                                                                                                                          Class)</I> <I>superclasses</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns MSCs of <I>old-supers</I> and <I>new-supers</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="aggregate-args"><A HREF="../RDFS\RdfsKernel.cl"><B>aggregate-args</B></A></A> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:class"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(class
                                                                                                                            Class)</I> <I>slot-names</I> <I>&key</I> <I>(direct-superclasses
                                                                                                                                                                         nil
                                                                                                                                                                         direct-superclasses-p)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks C subclassof D and D subclassof C, that implies equality.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(instance
                                                                                                                               Resource)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize-before-in-rdf"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize-before-in-RDF</B></A></A> <I>instance</I> <I>slot-names</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize-before-in-owl"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize-before-in-OWL</B></A></A> <I>instance</I> <I>slot-names</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="type-option-check-with-cardinality"><A HREF="../RDFS\RdfsKernel.cl"><B>type-option-check-with-cardinality</B></A></A> <I>instance</I> <I>filler</I> <I>slotd</I> <I>oldval</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="satisfy-filler"><A HREF="../RDFS\RdfsKernel.cl"><B>satisfy-filler</B></A></A> <I>x</I> <I>R</I> <I>y</I> <I>type</I> <I>maxc</I> <I>minc</I> <I>oldval</I> <I>slotd</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:class"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(class
                                                                                                                            Class)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks C subclassof D and D subclassof C, that implies equality.
Checks the residual mclasses of all instances of <I>class</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="check-shadowed-class-and-propagate-to-subs"><A HREF="../RDFS\RdfsKernel.cl"><B>check-shadowed-class-and-propagate-to-subs</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="update-instance-for-unshadowing"><A HREF="../RDFS\RdfsKernel.cl"><B>update-instance-for-unshadowing</B></A></A> <I>shadow?</I> <I>class</I> <I>supers</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>updates mclasses of all instances of class, if mclasses includes shadowed-classes that is unshadowable.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:datatype"><A HREF="../RDFS\RdfsKernel.cl"><B>shared-initialize</B></A></A> <I>(class
                                                                                                                               Datatype)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="change-class:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>change-class</B></A></A> <I>(instance
                                                                                                                     Resource)</I> <I>(new-class
                                                                                                                                       cons)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="change-class:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>change-class</B></A></A> <I>(instance
                                                                                                                     Resource)</I> <I>(new-class
                                                                                                                                       standard-class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="change-class:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>change-class</B></A></A> <I>(instance
                                                                                                                     Resource)</I> <I>(new-class
                                                                                                                                       Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>If <I>instance</I> has a slot value and <I>new-class</I> has no slot definitions on it,
   then add the slot definitions into <I>new-class</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="change-class:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>change-class</B></A></A> <I>(instance
                                                                                                                     Resource)</I> <I>(new-class
                                                                                                                                       Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="change-class:resource"><A HREF="../RDFS\RdfsKernel.cl"><B>change-class</B></A></A> <I>(instance
                                                                                                                     Resource)</I> <I>(new-class
                                                                                                                                       Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="compute-slot-value"><A HREF="../RDFS\RdfsKernel.cl"><B>compute-slot-value</B></A></A> <I>value</I> <I>oldval</I> <I>slotd</I> <I>instance</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="cardinality-ok-p:t"><A HREF="../RDFS\RdfsKernel.cl"><B>cardinality-ok-p</B></A></A> <I>value</I> <I>slotd</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-instances-of:symbol"><A HREF="../RDFS\RdfsKernel.cl"><B>collect-all-instances-of</B></A></A> <I>(class
                                                                                                                                           symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-instances-of:class"><A HREF="../RDFS\RdfsKernel.cl"><B>collect-all-instances-of</B></A></A> <I>(class
                                                                                                                                          Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="delete-slot"><A HREF="../RDFS\RdfsKernel.cl"><B>delete-slot</B></A></A> <I>class</I> <I>slot-name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<A NAME="RDFS/GxForwardRef.cl"><HR>
<H2>File <A HREF="../RDFS\GxForwardRef.cl">RDFS\GxForwardRef.cl</A></H2></A>
<P>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="finalize-inheritance:class"><A HREF="../RDFS\GxForwardRef.cl"><B>finalize-inheritance</B></A></A> <I>(class
                                                                                                                                    Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="check-superclasses-order"><A HREF="../RDFS\GxForwardRef.cl"><B>check-superclasses-order</B></A></A> <I>self</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="repair-inconsistent-ordering"><A HREF="../RDFS\GxForwardRef.cl"><B>repair-inconsistent-ordering</B></A></A> <I>inconsistents</I> <I>self</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="owl-restriction-p"><A HREF="../RDFS\GxForwardRef.cl"><B>owl-restriction-p</B></A></A> <I>obj</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="std-compute-class-precedence-list"><A HREF="../RDFS\GxForwardRef.cl"><B>std-compute-class-precedence-list</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-superclasses*"><A HREF="../RDFS\GxForwardRef.cl"><B>collect-superclasses*</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="local-precedence-ordering"><A HREF="../RDFS\GxForwardRef.cl"><B>local-precedence-ordering</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="topological-sort"><A HREF="../RDFS\GxForwardRef.cl"><B>topological-sort</B></A></A> <I>elements</I> <I>constraints</I> <I>tie-breaker</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="std-tie-breaker-rule"><A HREF="../RDFS\GxForwardRef.cl"><B>std-tie-breaker-rule</B></A></A> <I>minimal-elements</I> <I>cpl-so-far</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*reify-p*"><A HREF="../RDFS\GxForwardRef.cl"><B>*reify-p*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>when this flag is true, every statement is reified and strored in system.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="book-keeping-for-reification"><A HREF="../RDFS\GxForwardRef.cl"><B>book-keeping-for-reification</B></A></A> <I>instance</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="reify"><A HREF="../RDFS\GxForwardRef.cl"><B>reify</B></A></A> <I>subject</I> <I>predicate</I> <I>object</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<A NAME="RDFS/RdfsCore.cl"><HR>
<H2>File <A HREF="../RDFS\RdfsCore.cl">RDFS\RdfsCore.cl</A></H2></A>
<P>
<H2> Rdfs Core module</H2>
<P>
 IT Program Project in Japan: 
    Building Operation-Support System for Large-scale System using IT.
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan,
<P>
 Copyright (c) 2002, 2003, 2004, Galaxy Express Corporation
<BR>
 Copyright (c) 2007-2008, Seiji Koide
<P><HR WIDTH=80% ALIGN=left><P>
<H2> Top Level Macro and Intermediate Layers out of Three Layers in RDF(S) and OWL Definition</H2>
<P>
 There are three layers for resource definition, i.e., 
 (i) top level macro layer, 
 (ii) intermediate function/method layer, and 
 (iii) MOP programming layer.
 The top level macro layer, which includes three macros, <B>defConcept</B>, <B>defProperty</B>, and <B>defIndividual</B>,
 allows users to input RDF(S) and OWL entities in S-expression just in the same feeling as defining classes 
 or structures in lisp. 
 The intermediate layer composed of several functions and methods mediates inputs at the top level to the 
 MOP programming layer. 
 The MOP programming layer constitutes a bunch of MOP methods that are programmed in order to tailor 
 the CLOS orignal functionality to RDF(S) and OWL semantics using the Meta-Object Protocol (MOP).
<P>
 This file includes (i) the top level macro layer and (ii) the intermediate function/method layer. 
 The MOP programming layer is contained in Rdfs Kernel module.
<P>
<H2> Some Global Vars</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="lang-env"><A HREF="../RDFS\RdfsCore.cl"><B>lang-env</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>xml:lang evnironment</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Syntax of Top Level Definition</H2>
 The syntax of top level macros are as follows.
<BR>
<OL>
<LI><B>defConcept</B>   : define a resource class in RDF(S) or OWL.
<LI><B>defProperty</B>   : define a property in RDF(S) or OWL.
<LI><B>defIndividual</B> : define an individual or instance in RDF(S) or OWL.
<PRE><CODE>
  &lt;defform&gt; ::= &lt;resource-def&gt; | &lt;property-def&gt; | &lt;individual-def&gt;
  &lt;resource-def&gt;   ::= (defConcept &lt;resource-name&gt; &lt;slot-form&gt;* )
  &lt;property-def&gt;   ::= (defProperty &lt;property-name&gt; &lt;slot-form&gt;* )
  &lt;individual-def&gt; ::= (defIndvidual &lt;individual-name&gt; &lt;slot-form&gt;* )
  &lt;slot-form&gt; ::= (&lt;role&gt; [&lt;lang&gt;] &lt;form&gt; &lt;form&gt;*)
  &lt;form&gt;      ::= (&lt;typetag&gt; [&lt;name&gt;] [&lt;lang-form&gt;] &lt;slot-form&gt;*)
                | (&lt;datatype&gt; &lt;data&gt;) | (&lt;lang&gt; &lt;form&gt;) 
                | &lt;cl:string&gt; | &lt;cl:number&gt; | &lt;uri&gt; 
  &lt;lang-form&gt; ::= (xml:lang &lt;lang&gt;)
</CODE></PRE><P>
</OL>
<BR>
 <I>resource-name</I>, <I>propety-name</I>, <I>individua-name</I> is a symbol that represents QName of resource.
 <I>role</I> is a symbol that represents a property QName.
 <B>lang</B> is a language tag such as :en or :ja.
 <I>typetag</I> is a symbol that represents a resource class QName.
 <I>datatype</I> is a symbol that represents a xsd datatype QName.
<P>
 To direct a class in defining an entity, rdf:type is used in <I>slot-form</I> as same as other slot-forms. For example,
<PRE><CODE>
    (defIndividual vin::ElyseZinfandel (rdf:type vin::Zinfandel)).
</CODE></PRE><P>
 As default, rdf:Property is used for property class in <B>defProperty</B>. 
 To direct an object property in OWL, rdf:type is used in <B>defProperty</B> as follows.
<PRE><CODE>
    (defProperty vin::hasColor (rdf:type owl::ObjectProperty))
</CODE></PRE><P>
 Note that owl:FunctionalProperty is not a subclass of owl:ObjectProperty, while 
 owl:InverseFunctionalProperty is a subclass of owl:ObjectProperty. Therefore, it may 
 be needed to add owl:ObjectProperty with owl:FunctionalProperty as follows.
<PRE><CODE>
  (defProperty vin::hasMaker 
    (rdf:type owl:FunctionalProperty owl:ObjectProperty))

  (defProperty vin::producesWine
    (rdf:type owl:InverseFunctionalProperty)
    (owl:inverseOf vin::hasMaker))
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="defresource"><A HREF="../RDFS\RdfsCore.cl"><B>defResource</B></A></A> <I>name</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[macro]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines a class in OWL or a resource class in RDF(S). 
   This macro sets the class object to the symbol <I>name</I> 
   and returns the class object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="defconcept"><A HREF="../RDFS\RdfsCore.cl"><B>defConcept</B></A></A> <I>name</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[macro]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines a class in OWL or a resource class in RDF(S). 
   This macro sets the class object to the symbol <I>name</I> 
   and returns the class object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="defproperty"><A HREF="../RDFS\RdfsCore.cl"><B>defProperty</B></A></A> <I>name</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[macro]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines an instance of rdf:Property. 
   This macro sets a property object to the symbol <I>name</I> and 
   returns the property object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="defindividual"><A HREF="../RDFS\RdfsCore.cl"><B>defIndividual</B></A></A> <I>name</I> <I>&rest</I> <I>args</I></TH>
<TD align="right">[macro]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>defines an individual of owl:Resource 
   with <I>name</I> and slots.  This macro sets the individual object to 
   the symbol <I>name</I> and the object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="addrdfxml"><A HREF="../RDFS\RdfsCore.cl"><B>addRdfXml</B></A></A> <I>description</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="lasyaddrdfxml"><A HREF="../RDFS\RdfsCore.cl"><B>lasyAddRdfXml</B></A></A> <I>description</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function lazily <B>addForm</B> when it is forced.
   <B>delay</B> must be explicitly called with <B>force</B> function.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Defining Form in S-expression for RDF Entity</H2>
<P>
 The defining macro at the top level mentioned above internally produces the code for input form 
 in S-expression and calls function <B>addForm</B> with it.
 Reading RDF/XML file also makes a sequence of input forms in S-expression (See <B>addRdfXml</B> and <B>Description-form</B>), 
 and such input form is processed by <B>addForm</B>.
<P>
 Input form in S-expression has recursive structures. The BNF syntax for defining an RDF resource in S-expression is as follows.
<PRE><CODE>
  &lt;form&gt; ::= &lt;cl:string&gt; | &lt;cl:number&gt; | &lt;uri&gt; 
           | (&lt;lang&gt; &lt;form&gt;)
           | (&lt;^^&gt; &lt;data&gt;) 
           | (&lt;typetag&gt; [&lt;lang-form&gt;] &lt;slot-form&gt;*)
  &lt;slot-form&gt;   ::= &lt;about-form&gt; | &lt;id-form&gt; | &lt;nodeID-form&gt; | &lt;name-form&gt; | &lt;prop-form&gt;
  &lt;about-form&gt;  ::= (rdf:about &lt;uri&gt;)
  &lt;id-form&gt;     ::= (rdf:ID &lt;name&gt;)
  &lt;nodeID-form&gt; ::= (rdf:nodeID &lt;name&gt;)
  &lt;name-form&gt;   ::= (:name &lt;name&gt;)
  &lt;lang-form&gt;   ::= (xml:lang &lt;lang&gt;)
  &lt;prop-form&gt;   ::= (&lt;role&gt; [&lt;lang&gt;] &lt;form&gt; &lt;form&gt;*)
  &lt;data&gt;        ::= &lt;cl:number&gt; | &lt;cl:string&gt;
</CODE></PRE><P>
 Here,
<BR>
<UL>
<LI><I>typetag</I> is a class name in symbol or a symbol 'rdf:Description'.
<LI><I>role</I> is a property name in symbol. Note that this name turns out a name of Property-direct-slot-definition object.
<LI><I>datatype</I> is a QName symbol or URI or URI string for datatype.
<LI><I>data</I> is a lisp string or lisp number, but its interpretation must be coinside with designated xsd type definition.
<LI><I>uri</I> is a uri or uri-string or QName symbol.
<LI><I>cl:string</I> is a lisp string.
<LI><I>cl:number</I> is a lisp number.
<LI><B>lang</B> is a keyword that denotes langugage, e.g., :en, :ja. See <B>lang?</B>
</UL>
<BR>
<P>
<H2> addForm</H2>
<P>
 In lisp, <B>addForm</B> accepts any defining form that defines an entity or a fragment of entity described above 
 and returns the denotation of the form. Namely, 
<BR>
<OL>
<LI>If a form is a number in lisp, then it is returned.
<LI>If a form is a string in lisp, then it is read and interpreted as one of RDF datatype
   (when <I>role</I> is supplied and the range constraint is effective), or plane literal without language option 
   or with language option (when some <B>lang</B> is set up in the environment). See <B>read-data</B>. 
<LI>If a form is a URI, then if <I>role</I> suggensts URI such as rdf:about or "imports" it is returned,
   else its QName is obtained and recurses with the QName.
<LI>If a form is a symbol, then it must be a QName and the denoted object is returned if exists,
   else the denoted object is newly created at the minimal constraint from role range or rdfs4b rule. 
   See <B>make-object-with-minimal-contraint</B>.
<LI>If a form is (<B>lang</B> <I>form</I>), then the <I>form</I> is <B>addForm</B>ed in <B>lang</B> environment.
<LI>If a form is (<I>datatype</I> <I>data</I>), then the typed data is created and returned.
<LI>Otherwise the form denotes a complex entity, then each subforms are evaluated through <B>form2slot</B>
   and the form replaced with results is computed by <B>%addForm</B>.
</OL>
<BR>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="addform"><A HREF="../RDFS\RdfsCore.cl"><B>addForm</B></A></A> <I>form</I> <I>&optional</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>form</I> is a form described above, and <I>role</I> is nil in calling at top level 
   but a role for <I>form</I> as filler in recursive call.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="form2slot"><A HREF="../RDFS\RdfsCore.cl"><B>form2slot</B></A></A> <I>slot-form</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>accepts a <I>slot-form</I> and evaluates the filler using <B>addForm</B> and returns a slot, namely it makes a filler object 
   or data, and returnes a list of role and filler.
   when a slot-form is a non-nil symbol, it should be a name of resource
   and a name slot is created and returned.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-object-with-minimal-contraint"><A HREF="../RDFS\RdfsCore.cl"><B>make-object-with-minimal-contraint</B></A></A> <I>name</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function returns a resource entity (object) of which class is 
   suggested by range constraint of <I>role</I> or several entailment rules.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-object-with-minimal-constraint"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-object-with-minimal-constraint</B></A></A> <I>obj</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an <I>obj</I> that satisfies constraints by <I>role</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="aggregate-slots"><A HREF="../RDFS\RdfsCore.cl"><B>aggregate-slots</B></A></A> <I>slots</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function collects fillers in several slots on an identical role and makes them in one slot.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-range-constraint-from"><A HREF="../RDFS\RdfsCore.cl"><B>get-range-constraint-from</B></A></A> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns range constraint of <I>role</I> if exists, otherwise returns nil. In case that 
   <I>role</I> is rdf:List, this function returns an appropriate class for the element of list.
   See also <B>get-range-constraint-from</B> in OWL module.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> %addForm for RDF</H2>
 <B>%addForm</B> is a set of methods that are dedicated to each type of RDF entity.
 These methods are called with instantiated slots and returns an instance object of <I>type</I>.
<P>
 Calling sequence: %addForm (<I>type</I> <I>slots</I> <I>role</I>)
<BR>
<UL>
<LI><I>slots</I> - aggregated slots such as ((<I>role</I>1 <I>filler</I>11 <I>filler</I>12 ...) (<I>role</I>2 <I>filler</I>21 <I>filler</I>22 ...) ...),
   where every <I>role</I>-n is a symbol and every <I>filler</I>-n is a designated value object.
<LI><I>role</I>  - a role symbol that plays the rage constraint for (<I>role</I> <I>form</I>).
<LI><I>type</I>  - a type of entity to be made.
</UL>
<BR>
 Main purpose of these methods as a whole is to decide the type of object before the object creation.
 In most of cases, the most specific concept (MSC) among domain constraints from roles that are included in <I>slots</I>,
 a range constraint of pair <I>role</I> in slot of upper nests, and rdf:type filler in <I>slots</I> is computed and used.
 If any roles in <I>slots</I> are not defined, they are tentatively defined as instance of rdf:Property. In case that,
<BR>
<UL>
<LI>%addForm((eql 'rdf:Description)) - If MSC from constraints exists it is used, otherwise the value of
   *top*(=rdfs:Resource) is <I>type</I>.
<LI>%addForm((eql rdfs:Class)) - If MSC is more special than rdfs:Class,
   it is used otherwise rdfs:Class is used for <I>type</I>.
<LI>%addForm((eql owl:Class)) - If MSC is more special than owl:Class,
   it is used otherwise owl:Class is used for <I>type</I>.
<LI>%addForm((eql rdfs:Resource)) - If MSC is more special than rdfs:Resource,
   it is used otherwise rdfs:Resource is used for <I>type</I>.
<LI>%addForm((eql owl:Thing)) - If MSC exists, it is used, else owl:Thing is used for <I>type</I>.
<LI>%addForm((eql owl:Restriction) t t) - MSC is used for type. Note that more special
   restrictions than owl:Restriction are computed from role domain constraints. For exmaple, 
   owl:allValuesFrom's domain is set to owl:allValuedFromRestriction.
<LI>%addForm(rdfsClass) - Error. Never happen because %addForm((eql rdfs:Class)) supersedes this.
<LI>%addForm(rdfs:Class) - Indicated type is used.
<LI>%addForm(rdfs:Resource) - An instance is indicated for type. After changing it to a class,
   it or MSC is used.
<LI>%addForm(symbol) - If the type is already defined, recurse with the symbol value.
   Otherwise it is defined by metaclass that is computed from the MSC.
</UL>
<BR>
 In short, if a more special class than rdfs:Class is indicated for <I>type</I>, it is used 
 whether or not more special MSC exists. Otherwise, MSC is computed and it is used.
<P>
 See the following example. Here Species and EndangeredSpecies are defined as metaclass. 
<PRE><CODE>
 (addForm
   '(rdfs:Class Species
      (rdfs:subClassOf rdfs:Class)        ; this makes Species a metaclass
      (rdfs:comment "This example is for the demonstration of addForm.")))
 (addForm
   '(rdfs:Class EndangeredSpecies
      (rdfs:subClassOf Species)))         ; a subclass of metaclass is a metaclass
 (addForm
   '(rdf:Property estimatedPopulation
      (rdfs:domain EndangeredSpecies)
      (rdfs:range xsd:nonNegativeInteger)))
 (addForm
   '(rdfs:Class Hawk
      (estimatedPopulation 2000)))         ; MSC is computed as EndangeredSpecies
 (addForm '(Hawk Harry))
</CODE></PRE><P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%addform"><A HREF="../RDFS\RdfsCore.cl"><B>%addForm</B></A></A> <I>type</I> <I>slots</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>subfunction for <B>%addForm</B>. To be here, <I>type</I> must be fixed.
   This function creates an object with <I>type</I> and <I>slots</I> using <B>addObject</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-proxy"><A HREF="../RDFS\RdfsCore.cl"><B>make-proxy</B></A></A> <I>types</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-coined-name"><A HREF="../RDFS\RdfsCore.cl"><B>make-coined-name</B></A></A> <I>types</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="accumulate-defined-name"><A HREF="../RDFS\RdfsCore.cl"><B>accumulate-defined-name</B></A></A> <I>name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This function is called at top level of input form and accumulate the name of entity 
   as defined name into <B>*defined-resources*</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> addObject</H2>
<P>
 <B>addObject</B>s are a set of methods of which main purpose is to distinguish creating a class or 
 creating an instance, and additionally recognize an instance of OneOf. See also <B>addObject</B> in OWL module. 
<P>
<BR>
<OL>
<LI><B>addObject</B>(rdfs:Class) - main routine
<LI><B>addObject</B>(rdfsClass)  - accepts only rdfs:Class, the body is same as the main routine above.
<LI><B>addObject</B>:around(rdfs:Class) - for OneOf processing, see OneOf module
<LI><B>addObject</B>:around(rdfsClass)  - same as <B>addObject</B>:around(rdfs:Class)
<LI><B>addObject</B>:before(rdfs:Class) - for container membership property
</OL>
<BR>
 Note that if there is no information on <I>type</I> or superclasses of an object, due to the forward reference, 
 the object is created as instance even though it is changed to a class later when the regular expression
 are stated.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="addobject"><A HREF="../RDFS\RdfsCore.cl"><B>addObject</B></A></A> <I>type</I> <I>slot-forms</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>type</I> is a class or a meta-class except rdfs:Class. Every slot-filler is already objectized if it is an resource object.
   This method sets up QName's package in uri-namedspace from name in <I>slot-forms</I>, then calls <B>ensure-meta-absts</B> 
   to fix the meta class and abst classes for this object. Finally, calls <B>addClass</B> if the meta class or abst exists, else 
   calls <B>addInstance</B>. If optional <I>domains</I> is not supplied, the domain constrant is computed and it is used for ensuring 
   the metaclass and abst classes. To suppress domain computing, supply nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Ensuring Meta Classes and Abst(Super) Classes</H2>
<BR>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-meta-absts"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-meta-absts</B></A></A> <I>class</I> <I>slot-forms</I> <I>domains</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>picks up metaclasses and superclasses from <I>slot-forms</I>. If rdf:type slot is included in <I>slot-forms</I>,
   the range constraint supplies meta class(es). If rdfs:subClassOf slot is included, the range constraint 
   supplies superclasses (absts).</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-meta-absts-using-class:t"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-meta-absts-using-class</B></A></A> <I>meta</I> <I>class</I> <I>slot-forms</I> <I>domains</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-meta-absts-using-class:class"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-meta-absts-using-class</B></A></A> <I>(meta
                                                                                                                                                  Class)</I> <I>(class
                                                                                                                                                                 Resource)</I> <I>slot-forms</I> <I>domains</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>class</I> must be an instance.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-meta-absts-using-class:rdf-node"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-meta-absts-using-class</B></A></A> <I>(meta
                                                                                                                                                     rdf-node)</I> <I>(class
                                                                                                                                                                       rdfsClass)</I> <I>slot-forms</I> <I>domains</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>class</I> must be rdfs:Class</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-meta-absts-using-class:class"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-meta-absts-using-class</B></A></A> <I>(meta
                                                                                                                                                  Class)</I> <I>(class
                                                                                                                                                                 Class)</I> <I>slot-forms</I> <I>domains</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD><I>class</I> must be a class or metaclass.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="refine-concept-by-intersection"><A HREF="../RDFS\RdfsCore.cl"><B>refine-concept-by-intersection</B></A></A> <I>classes</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>hook for OWL</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> addClass</H2>
<P>
 Principles in multiple typing
<BR>
<OL>
<LI>The association between a type and slots attached to it should be given by user, except the case that a slot states its domain.
<LI>Even if slots is defined in multiple classes that relates in super/sub class relation, system does not care of the redundancy of slots.
</OL>
<BR>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*subjects-defined*"><A HREF="../RDFS\RdfsCore.cl"><B>*subjects-defined*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>storage where all subjects defined are stored</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="addclass"><A HREF="../RDFS\RdfsCore.cl"><B>addClass</B></A></A> <I>classes</I> <I>class</I> <I>absts</I> <I>&optional</I> <I>islots</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>create a class of metaclass <I>classes</I> with <I>class</I>, <I>absts</I>, and <I>islots</I>.
   Each of <I>classes</I> must be an object. An element of <I>islots</I> is '(<I>role</I> . <I>fillers</I>)'.
   Note that <I>islots</I> are not slot definition for class but slots for this class.
   <I>absts</I> are already entailed and objectized. There is no undefined property in slots. 
   Slot definitions for <I>islots</I> are automatically defined by system, if 
   not defined yet. This function can process multiple different typing for existing objects.
   If any element in <I>classes</I> is a class but not a mete class, it is changed to a meta class.
   This function stores the result object into <B>*subjects-defined*</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> addInstance</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="addinstance"><A HREF="../RDFS\RdfsCore.cl"><B>addInstance</B></A></A> <I>classes</I> <I>instance</I> <I>&optional</I> <I>slots</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>creates a new instance or redefines the instance with <I>instance</I> and <I>slots</I>. 
   <I>instance</I> must be a symbol, a URI, or resource object.
   Each of <I>classes</I> must be defined and <I>classes</I> must be MSCs. 
   An element of <I>slots</I> is '(<I>role</I> . <I>fillers</I>)'.
   In new creation, the car of <I>classes</I> is used for class of this instance. If there are multiple classes, 
   a shadow class for <I>classes</I> is made based the car of <I>classes</I>. In redefinition, 
   * if the old instance belongs to everyone in <I>classes</I>, <B>reinitialize-instance</B> method is invoked.
   * if a single new class is indicated, <B>change-class</B> is invoked.
   * if every new class is a subclass of some of old classes, then <B>change-class</B> is invoked, and shadowes for multiple classes.
   * otherwise, the MSCs are computed and <B>change-class</B> and shadowing are done.
   This function stores the result object into <B>*subjects-defined*</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Make Instance</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ensure-class-slotds"><A HREF="../RDFS\RdfsCore.cl"><B>ensure-class-slotds</B></A></A> <I>class</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>checks properties in <I>initargs</I> and adds the new slot definitions to <I>class</I>.
   Note that initargs are for an instance of <I>class</I>, not for <I>class</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-instance:class"><A HREF="../RDFS\RdfsCore.cl"><B>make-instance</B></A></A> <I>(class
                                                                                                                  Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-domains-from-initargs"><A HREF="../RDFS\RdfsCore.cl"><B>collect-domains-from-initargs</B></A></A> <I>class</I> <I>initargs</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD> returns a list of domains for <I>class</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-instance:class"><A HREF="../RDFS\RdfsCore.cl"><B>make-instance</B></A></A> <I>(class
                                                                                                                  Class)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>This method accepts any class and metaclass including rdfs:Class.
   Before calling the primary method, ensure slot definitions for this <I>class</I> for initargs.
   Domain constraints are also taken care, and make a shadow class if multiple classes indicated.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Reinitialize Instance</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="reinitialize-instance:resource"><A HREF="../RDFS\RdfsCore.cl"><B>reinitialize-instance</B></A></A> <I>(instance
                                                                                                                                     Resource)</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>After ensuring that every slot is effectively defined at the class of <I>instance</I>,
   if new type option derived from domain constraints are special than the old class, 
   change-class is invoked before primary method of <B>reinitialize-instance</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="read-data"><A HREF="../RDFS\RdfsCore.cl"><B>read-data</B></A></A> <I>type</I> <I>str</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>read <I>str</I> as <I>type</I> and returns an instance of <I>type</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="read-in-lang-env"><A HREF="../RDFS\RdfsCore.cl"><B>read-in-lang-env</B></A></A> <I>str</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>reads <I>str</I> with language option in RDF, and returns an instance of rdf:inLang. See also, <B>lang-env</B>.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> Slots := (role . forms) | (role filler)</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="create-slot"><A HREF="../RDFS\RdfsCore.cl"><B>create-slot</B></A></A> <I>role</I> <I>filler</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slot-role"><A HREF="../RDFS\RdfsCore.cl"><B>slot-role</B></A></A> <I>slot</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slot-forms"><A HREF="../RDFS\RdfsCore.cl"><B>slot-forms</B></A></A> <I>slot</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slot-filler"><A HREF="../RDFS\RdfsCore.cl"><B>slot-filler</B></A></A> <I>slot</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-filler"><A HREF="../RDFS\RdfsCore.cl"><B>get-filler</B></A></A> <I>slots</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Containers in RDF</H2>
<BR>
 See, RDFboot module.
<P>
<H2> Rdfs12</H2>
 If <I>uuu</I> rdf:type rdfs:ContainerMembershipProperty, 
 then, <I>uuu</I> rdfs:subPropertyOf rdfs:member.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:containermembershipproperty"><A HREF="../RDFS\RdfsCore.cl"><B>shared-initialize</B></A></A> <I>(instance
                                                                                                                                                ContainerMembershipProperty)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>adds rdfs:member info into <I>instance</I> according to rdfs12 rule.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subclassof"><A HREF="../RDFS\RdfsCore.cl"><B>subClassOf</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="subpropertyof"><A HREF="../RDFS\RdfsCore.cl"><B>subPropertyOf</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Automatated ContainerMembershipProperty Creation</H2>
 If <I>x</I> rdf:type rdfs:Container and <I>x</I> <I>p</I> <I>vvv</I>,
 then <I>p</I> rdf:type rdfs:ContainerMembershipProperty,
 and <I>p</I> rdfs:subPropertyOf rdfs:member.
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="check-ordinal-properties"><A HREF="../RDFS\RdfsCore.cl"><B>check-ordinal-properties</B></A></A> <I>slot-forms</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-ordinal-property"><A HREF="../RDFS\RdfsCore.cl"><B>make-ordinal-property</B></A></A> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> From Schank's M-SEQUENCE in Memory Organization Package (MOP)</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list2seq"><A HREF="../RDFS\RdfsCore.cl"><B>list2seq</B></A></A> <I>l</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an instance of rdf:Seq with members from <I>l</I>. The first element of 
   <I>l</I> fills the first role rdf:_1, the second fills the second role rdf:_2, and so on. 
   If <I>l</I> is empty, rdf:nil is returned.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list2bag"><A HREF="../RDFS\RdfsCore.cl"><B>list2bag</B></A></A> <I>l</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an instance of rdf:Seq with members from <I>l</I>. The first element of 
   <I>l</I> fills the first role rdf:_1, the second fills the second role rdf:_2, and so on. 
   If <I>l</I> is empty, rdf:nil is returned.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list2alt"><A HREF="../RDFS\RdfsCore.cl"><B>list2alt</B></A></A> <I>l</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an instance of rdf:Seq with members from <I>l</I>. The first element of 
   <I>l</I> fills the first role rdf:_1, the second fills the second role rdf:_2, and so on. 
   If <I>l</I> is empty, rdf:nil is returned.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="shared-initialize:resource"><A HREF="../RDFS\RdfsCore.cl"><B>shared-initialize</B></A></A> <I>(instance
                                                                                                                             Resource)</I> <I>slot-names</I> <I>&rest</I> <I>initargs</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>book-keeping for reification seiji</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-owl-role-name-if"><A HREF="../RDFS\RdfsCore.cl"><B>collect-owl-role-name-if</B></A></A> <I>test</I> <I>obj</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<P>
 Seiji Koide Aug-04-2009
<P>
<A NAME="RDFS/gxutils.cl"><HR>
<H2>File <A HREF="../RDFS\gxutils.cl">RDFS\gxutils.cl</A></H2></A>
<P>
<H2> GXUtils module</H2>
<P>
 IT Program Project in Japan: 
          Building Operation-Support System for Large-scale System using IT
<P>
 Copyright (c) 2002, 2003 by Galaxy Express Corporation
<P>
 Copyright (c) 2008 Seiji Koide
<P>
<P>
<H2> All Entities</H2>
<P>
 Every resource URI in SWCLOS is interned into the default uri space. Note that this default 
 uri space is independent from Named Spaces for prefix (package) and local name (env) for QName. 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="print-all-entity-uris"><A HREF="../RDFS\gxutils.cl"><B>print-all-entity-uris</B></A></A> <I>&optional</I> <I>stream</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>prints out all entities as uri to <I>stream</I>. This function does not print blank nodes.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="do-all-entity-uris"><A HREF="../RDFS\gxutils.cl"><B>do-all-entity-uris</B></A></A> <I>fun</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>invokes <I>fun</I> for all entities as uri. <I>fun</I> should be one parameter funcallable object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entity-uris"><A HREF="../RDFS\gxutils.cl"><B>list-all-entity-uris</B></A></A> </TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collects all entities as uri, and returs it. Here, entity means ontologies 
   designated by owl:Ontology+rdf:about and entities in ontologies.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> All NamedSpace</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-uri-namedspaces"><A HREF="../RDFS\gxutils.cl"><B>list-all-uri-namedspaces</B></A></A> </TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns an association list of prefix name (package name) and uri on all ones in the system.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="do-all-uri-namedspaces"><A HREF="../RDFS\gxutils.cl"><B>do-all-uri-namedspaces</B></A></A> <I>fun</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>invokes <I>fun</I> for all namedspaces. <I>fun</I> should be one parameter funcallable object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entities-in"><A HREF="../RDFS\gxutils.cl"><B>list-all-entities-in</B></A></A> <I>namespace</I> <I>&optional</I> <I>uri?</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>These methods return all entities in <I>namespace</I>, namely all external symbol in <I>namespace</I> package. 
Note that it is not cared that symbols are bound to resource objects or not.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entities-in:string"><A HREF="../RDFS\gxutils.cl"><B>list-all-entities-in</B></A></A> <I>(namespace
                                                                                                                                string)</I> <I>&optional</I> <I>uri?</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When <I>namespace</I> is a string, recursively called with a uri of <I>namespace</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entities-in:uri"><A HREF="../RDFS\gxutils.cl"><B>list-all-entities-in</B></A></A> <I>(namespace
                                                                                                                             uri)</I> <I>&optional</I> <I>uri?</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When <I>namespace</I> is a uri, the related package is retrieved of <I>namespace</I>, then recursively called with the package.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entities-in:symbol"><A HREF="../RDFS\gxutils.cl"><B>list-all-entities-in</B></A></A> <I>(namespace
                                                                                                                                symbol)</I> <I>&optional</I> <I>uri?</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When <I>namespace</I> is a non-nil symbol, recursively called with a package of <I>namespace</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-entities-in:package"><A HREF="../RDFS\gxutils.cl"><B>list-all-entities-in</B></A></A> <I>(namespace
                                                                                                                                 package)</I> <I>&optional</I> <I>uri?</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>When <I>namespace</I> is a package, every external symbol in <I>namespace</I> is collected, 
   and it is returned as a list of symbol (when uri? is false) or uri (when uri? is true).</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="named-p"><A HREF="../RDFS\gxutils.cl"><B>named-p</B></A></A> <I>resource</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="anonymous-p"><A HREF="../RDFS\gxutils.cl"><B>anonymous-p</B></A></A> <I>resource</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-form"><A HREF="../RDFS\gxutils.cl"><B>get-form</B></A></A> <I>resource</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="slots-of"><A HREF="../RDFS\gxutils.cl"><B>slots-of</B></A></A> <I>ins</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-slots"><A HREF="../RDFS\gxutils.cl"><B>get-slots</B></A></A> <I>obj</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>get-slots <I>obj</I>
   returns a slot list of <I>obj</I>. Note that nil is returned if <I>obj</I> 
   is not a resource.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-slots:class"><A HREF="../RDFS\gxutils.cl"><B>get-slots</B></A></A> <I>(obj
                                                                                                         Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-slots:resource"><A HREF="../RDFS\gxutils.cl"><B>get-slots</B></A></A> <I>(obj
                                                                                                            Resource)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-slots:symbol"><A HREF="../RDFS\gxutils.cl"><B>get-slots</B></A></A> <I>(obj
                                                                                                          symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-slots:t"><A HREF="../RDFS\gxutils.cl"><B>get-slots</B></A></A> <I>obj</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="make-anonymous-label"><A HREF="../RDFS\gxutils.cl"><B>make-anonymous-label</B></A></A> <I>ins</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="mop-specs"><A HREF="../RDFS\gxutils.cl"><B>mop-specs</B></A></A> <I>mop</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>mop-specs <I>mop</I>
   returns a list of direct specials of <I>mop</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="tree->list"><A HREF="../RDFS\gxutils.cl"><B>tree->list</B></A></A> <I>mop</I> <I>fn</I> <I>visited</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>tree->list <I>mop</I> <B>function</B> <I>mop-list</I>
   returns a list starting with <I>mop</I>, followed by the elements of
   the list returned by calling <B>function</B> with <I>mop</I> and <I>mop-list</I>
   updated to include <I>mop</I>. If <I>mop</I> is already in <I>mop-list</I>, just
   a list with <I>mop</I> is returned.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="dah"><A HREF="../RDFS\gxutils.cl"><B>dah</B></A></A> <I>mop</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>dah <I>mop</I>
   prints all the specalizations under <I>mop</I>. The name is short for
   'display abstraction hierarchy'</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="specs->list"><A HREF="../RDFS\gxutils.cl"><B>specs->list</B></A></A> <I>mop</I> <I>visited</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>SPECS->LIST <I>mop</I> <I>mop-list</I>
   returns a list starting with <I>mop</I>, followed by the specialization
   tree under each specializations of <I>mop</I>.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-about-slot:property"><A HREF="../RDFS\gxutils.cl"><B>get-about-slot</B></A></A> <I>(mop
                                                                                                                      Property)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-about-slot:resource"><A HREF="../RDFS\gxutils.cl"><B>get-about-slot</B></A></A> <I>(mop
                                                                                                                      Resource)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="path-filler"><A HREF="../RDFS\gxutils.cl"><B>path-filler</B></A></A> <I>mop</I> <I>path</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>path-filler <I>mop</I> <I>path</I>
   returns the filler for <I>path</I> in <I>mop</I>. A path is a list of roles, and 
   path-filler follows that list in order, using get-filler. A role is a 
   property object.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subproperties"><A HREF="../RDFS\gxutils.cl"><B>collect-all-subproperties</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-superproperties"><A HREF="../RDFS\gxutils.cl"><B>collect-all-superproperties</B></A></A> <I>property</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="constraint-filter"><A HREF="../RDFS\gxutils.cl"><B>constraint-filter</B></A></A> <I>mop</I> <I>type</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="->"><A HREF="../RDFS\gxutils.cl"><B>-></B></A></A> <I>mop</I> <I>&rest</I> <I>roles</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>-> <I>mop</I> <I>role1</I> <I>role2</I> ...
   returns the filler found by tracing <I>role1</I> <I>role2</I> ... from the <I>mop</I>.
   In other words, inherited filler of <I>mop</I> and <I>role1</I> is used in next 
   filler-retlieving with <I>role2</I>, and the result is used in next ..., and so 
   on.  <I>mop</I> is a mop object or a slot-list.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="setf"><A HREF="../RDFS\gxutils.cl"><B>setf</B></A></A> <I>value</I> <I>mop</I> <I>&rest</I> <I>roles</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%setfvalue"><A HREF="../RDFS\gxutils.cl"><B>%setfvalue</B></A></A> <I>value</I> <I>type</I> <I>roles</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-direct-subtypes:symbol"><A HREF="../RDFS\gxutils.cl"><B>collect-direct-subtypes</B></A></A> <I>(class
                                                                                                                                      symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-direct-subtypes:class"><A HREF="../RDFS\gxutils.cl"><B>collect-direct-subtypes</B></A></A> <I>(class
                                                                                                                                     Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subtypes:symbol"><A HREF="../RDFS\gxutils.cl"><B>collect-all-subtypes</B></A></A> <I>(class
                                                                                                                                symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subtypes:class"><A HREF="../RDFS\gxutils.cl"><B>collect-all-subtypes</B></A></A> <I>(class
                                                                                                                               Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subsumed-types:symbol"><A HREF="../RDFS\gxutils.cl"><B>collect-all-subsumed-types</B></A></A> <I>(class
                                                                                                                                            symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-subsumed-types:class"><A HREF="../RDFS\gxutils.cl"><B>collect-all-subsumed-types</B></A></A> <I>(class
                                                                                                                                           Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-direct-instances-of:symbol"><A HREF="../RDFS\gxutils.cl"><B>collect-direct-instances-of</B></A></A> <I>(class
                                                                                                                                              symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-direct-instances-of:class"><A HREF="../RDFS\gxutils.cl"><B>collect-direct-instances-of</B></A></A> <I>(class
                                                                                                                                             Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-instances-generator:symbol"><A HREF="../RDFS\gxutils.cl"><B>all-instances-generator</B></A></A> <I>(class
                                                                                                                                      symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-instances-generator:class"><A HREF="../RDFS\gxutils.cl"><B>all-instances-generator</B></A></A> <I>(class
                                                                                                                                     Class)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-supers"><A HREF="../RDFS\gxutils.cl"><B>collect-all-supers</B></A></A> <I>class</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-extensions-of:symbol"><A HREF="../RDFS\gxutils.cl"><B>collect-all-extensions-of</B></A></A> <I>(property
                                                                                                                                          symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-extensions-of:property"><A HREF="../RDFS\gxutils.cl"><B>collect-all-extensions-of</B></A></A> <I>(property
                                                                                                                                            Property)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-all-extensions-of-1:property"><A HREF="../RDFS\gxutils.cl"><B>collect-all-extensions-of-1</B></A></A> <I>(property
                                                                                                                                                Property)</I> <I>collector</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-extensions-of-generator:symbol"><A HREF="../RDFS\gxutils.cl"><B>all-extensions-of-generator</B></A></A> <I>(property
                                                                                                                                              symbol)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-extensions-of-generator:property"><A HREF="../RDFS\gxutils.cl"><B>all-extensions-of-generator</B></A></A> <I>(property
                                                                                                                                                Property)</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*system-properties*"><A HREF="../RDFS\gxutils.cl"><B>*system-properties*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-properties"><A HREF="../RDFS\gxutils.cl"><B>list-all-properties</B></A></A> <I>&optional</I> <I>with-system-property-p</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>lists all properties. If calling with parameter t, it forces to output 
   properties including system predefined properties. Otherwise only user
   properties.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*system-resources*"><A HREF="../RDFS\gxutils.cl"><B>*system-resources*</B></A></A> </TH>
<TD align="right">[constant]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-resources"><A HREF="../RDFS\gxutils.cl"><B>list-all-resources</B></A></A> <I>&optional</I> <I>with-system-rsc-object-p</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%list-all-resources"><A HREF="../RDFS\gxutils.cl"><B>%list-all-resources</B></A></A> <I>root</I> <I>with-system-rsc-object-p</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="list-all-statements"><A HREF="../RDFS\gxutils.cl"><B>list-all-statements</B></A></A> </TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-domain-properties"><A HREF="../RDFS\gxutils.cl"><B>collect-domain-properties</B></A></A> <I>subject</I> <I>&optional</I> <I>prop</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collect all properties under <I>prop</I> that have <I>subject</I> as domain.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-range-properties"><A HREF="../RDFS\gxutils.cl"><B>collect-range-properties</B></A></A> <I>object</I> <I>&optional</I> <I>prop</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>collect all properties under <I>prop</I> that have <I>object</I> as range.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
<H2> DIG interface</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-concept-names"><A HREF="../RDFS\gxutils.cl"><B>all-concept-names</B></A></A> <I>&optional</I> <I>ns</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns all named concept names in <I>ns</I>.
   If <I>ns</I> is neither a uri-namedspace uri nor string nor package
   nor package name symbol, then returns nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-role-names"><A HREF="../RDFS\gxutils.cl"><B>all-role-names</B></A></A> <I>&optional</I> <I>ns</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns all role names in <I>ns</I>.
   If <I>ns</I> is neither a uri-namedspace uri nor string nor package
   nor package name symbol, then returns nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="all-individuals"><A HREF="../RDFS\gxutils.cl"><B>all-individuals</B></A></A> <I>&optional</I> <I>ns</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns all individuals or instances in <I>ns</I>.
   If <I>ns</I> is neither a uri-namedspace uri nor string nor package
   nor package name symbol, then returns nil.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="concept-parents"><A HREF="../RDFS\gxutils.cl"><B>concept-parents</B></A></A> <I>concept</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="get-value"><A HREF="../RDFS\gxutils.cl"><B>get-value</B></A></A> <I>object</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>gets all values with sameAs definition. See rdfp11.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%get-value"><A HREF="../RDFS\gxutils.cl"><B>%get-value</B></A></A> <I>object</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>rdfs7 + inverserole</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%get-inverse-prop"><A HREF="../RDFS\gxutils.cl"><B>%get-inverse-prop</B></A></A> <I>prop</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%get-hasfiller-inherited"><A HREF="../RDFS\gxutils.cl"><B>%get-hasfiller-inherited</B></A></A> <I>class</I> <I>role</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:class"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                         Class)</I> <I>(role
                                                                                                                        (eql
                                                                                                                         type))</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:class"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                         Class)</I> <I>(role
                                                                                                                        (eql
                                                                                                                         subClassOf))</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:resource"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                            Resource)</I> <I>(role
                                                                                                                              (eql
                                                                                                                               type))</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:resource"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                            Resource)</I> <I>(role
                                                                                                                              (eql
                                                                                                                               subClassOf))</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:resource"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                            Resource)</I> <I>(role
                                                                                                                              Property)</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:resource"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>(object
                                                                                                            Resource)</I> <I>(role
                                                                                                                              symbol)</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="put-value:t"><A HREF="../RDFS\gxutils.cl"><B>put-value</B></A></A> <I>object</I> <I>role</I> <I>value</I></TH>
<TD align="right">[method]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P>
<H2> Utilities for RDF Semantics</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="memoize"><A HREF="../RDFS\gxutils.cl"><B>memoize</B></A></A> <I>fn-name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Replace fn-name's global definition with a memoized version.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="memo"><A HREF="../RDFS\gxutils.cl"><B>memo</B></A></A> <I>fn</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Return a memo-function of fn.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="memoize2"><A HREF="../RDFS\gxutils.cl"><B>memoize2</B></A></A> <I>fn-name</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Replace fn-name's global definition with a memoized version with arity 2.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="memo2"><A HREF="../RDFS\gxutils.cl"><B>memo2</B></A></A> <I>fn</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>Return a memo-function of fn with arity 2.</TD>
</TR></TBODY></TABLE></DIV> 
<P>
 Seiji Koide Aug-04-2009
<P>
<A NAME="RDFS/rdfwriter.cl"><HR>
<H2>File <A HREF="../RDFS\rdfwriter.cl">RDFS\rdfwriter.cl</A></H2></A>
<P>
<H2> RDFWriter module</H2>
<P>
 IT Program Project in Japan: 
          Building Operation-Support System for Large-scale System using IT.
<P>
 This code is written by Seiji Koide at Galaxy Express Corporation, Japan,
 for the realization of the MEXT IT Program in Japan,
<P>
 Copyright  2004 by Galaxy Express Corporation
<BR>
 Copyright (c) 2008 Seiji Koide
<P><HR WIDTH=80% ALIGN=left><P>
<P>
<H2> RDF Writer</H2>
<P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="*force-recursive-p*"><A HREF="../RDFS\rdfwriter.cl"><B>*force-recursive-p*</B></A></A> </TH>
<TD align="right">[variable]</TD></TR>
</TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="dont-expand-p"><A HREF="../RDFS\rdfwriter.cl"><B>dont-expand-p</B></A></A> <I>resource</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-used-packaged-from"><A HREF="../RDFS\rdfwriter.cl"><B>collect-used-packaged-from</B></A></A> <I>x</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="%collect-used-packaged-from"><A HREF="../RDFS\rdfwriter.cl"><B>%collect-used-packaged-from</B></A></A> <I>slots</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-xml"><A HREF="../RDFS\rdfwriter.cl"><B>write-xml</B></A></A> <I>x</I> <I>&optional</I> <I>stream</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-resource"><A HREF="../RDFS\rdfwriter.cl"><B>write-resource</B></A></A> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>prints each element as resource</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collection-p"><A HREF="../RDFS\rdfwriter.cl"><B>collection-p</B></A></A> <I>resources</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-slot-subclassof"><A HREF="../RDFS\rdfwriter.cl"><B>write-slot-subclassof</B></A></A> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-slot"><A HREF="../RDFS\rdfwriter.cl"><B>write-slot</B></A></A> <I>slot</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-it"><A HREF="../RDFS\rdfwriter.cl"><B>write-it</B></A></A> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-about="><A HREF="../RDFS\rdfwriter.cl"><B>write-about=</B></A></A> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>prints <I>TYPE rdf:about='uri' </I></TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-datatype="><A HREF="../RDFS\rdfwriter.cl"><B>write-datatype=</B></A></A> <I>role</I> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>prints <I>ROLE rdf:datatype='type' </I>value<I>/ROLE</I></TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-resource="><A HREF="../RDFS\rdfwriter.cl"><B>write-resource=</B></A></A> <I>role</I> <I>resource</I> <I>s</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>prints <I>ROLE rdf:resource='uri' /</I></TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="lisp2rdf"><A HREF="../RDFS\rdfwriter.cl"><B>lisp2rdf</B></A></A> <I>&optional</I> <I>infile</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="ask-user-cl-file"><A HREF="../RDFS\rdfwriter.cl"><B>ask-user-cl-file</B></A></A> </TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>asks an common lisp file to user.</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="lisp2rdf*"><A HREF="../RDFS\rdfwriter.cl"><B>lisp2rdf*</B></A></A> <I>&optional</I> <I>infile</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="s2rdf"><A HREF="../RDFS\rdfwriter.cl"><B>S2RDF</B></A></A> <I>instream</I> <I>outstream</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="read-entity"><A HREF="../RDFS\rdfwriter.cl"><B>read-entity</B></A></A> <I>instream</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="collect-instance-slots"><A HREF="../RDFS\rdfwriter.cl"><B>collect-instance-slots</B></A></A> <I>instance</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD>returns instance slots with slot form (role filler1 ...)</TD>
</TR></TBODY></TABLE></DIV> 
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-rdf-all-entities-in"><A HREF="../RDFS\rdfwriter.cl"><B>write-rdf-all-entities-in</B></A></A> <I>package</I> <I>&optional</I> <I>stream-or-file</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<P><TABLE width="100%" cellpadding="0" frame="below">
<TR><TH align="left"><A NAME="write-xml-all-entities-in"><A HREF="../RDFS\rdfwriter.cl"><B>write-xml-all-entities-in</B></A></A> <I>package</I> <I>&optional</I> <I>stream-or-file</I></TH>
<TD align="right">[function]</TD></TR></TABLE>
<DIV align="right"><TABLE width="90%" cellpadding="0"><TBODY><TR>
<TD></TD>
</TR></TBODY></TABLE></DIV> <P>
<HR>
<TABLE BORDER=4 CELLPADDING=4 CELLSPACING=0><tr>
<td> <A HREF="http://www-kasm.nii.ac.jp/~koide/SWCLOS2-en.htm">SWCLOS Home</A>
<td> <A HREF="../../contact.html">Authors</A>
<td> <A HREF="overview.html">Lisp Code Overview</A>
</TABLE>
</BODY> 
</HTML>
